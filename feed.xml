<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="https://seongtaekkim.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://seongtaekkim.github.io/" rel="alternate" type="text/html" /><updated>2021-08-18T02:02:53+09:00</updated><id>https://seongtaekkim.github.io/feed.xml</id><title type="html">웹개발자</title><subtitle>IT</subtitle><entry><title type="html">토비의스프링1권 9장 내용</title><link href="https://seongtaekkim.github.io/spring-toby1_9" rel="alternate" type="text/html" title="토비의스프링1권 9장 내용" /><published>2021-08-18T01:36:01+09:00</published><updated>2021-08-18T01:36:01+09:00</updated><id>https://seongtaekkim.github.io/spring-toby1_9</id><content type="html" xml:base="https://seongtaekkim.github.io/spring-toby1_9">&lt;p&gt;&lt;span class=&quot;table-of-contents-list&quot;&gt;– 토비의스프링 1권 정리&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;table-of-contents-list&quot;&gt;
    &lt;li&gt;&lt;a href=&quot;./spring-toby1_9&quot;&gt;토비의스프링1권 9장&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;9장에서는&lt;/p&gt;

&lt;p&gt;스프링을 이용해 애플리케이션 프로젝트를 처음 구성할 때 알아야 할 기본적인 내용을 다룬다.&lt;/p&gt;

&lt;p&gt;또, 스프링 개발에 도움이 되는 개발 툴과 빌드 방법도 살펴볼 것이다.&lt;/p&gt;

&lt;p&gt;마지막으로 스프링을 애플리케이션에 적용할 수 있는 아키텍처의 종류와 특징에 대해서도 알아본다.&lt;/p&gt;

&lt;p&gt;스프링은 어떤 종류의 애플리케이션에도 잘 들어맞도록 매우 유연하게 설계된 범용 프레임워크다.&lt;/p&gt;

&lt;p&gt;그래서 아키텍처의 종류나 프로젝트를 구성하는 방법에 대한 자유도가 매우 높다.&lt;/p&gt;

&lt;p&gt;그만큼 프로젝트 구성 방법이나 아키텍처를 선택할 때 주의를 기울일 필요가 있다. 스프링이 유연하다고 해서 아무렇게나 가져다 쓰면 스프링이 주는 유익을 제대로 얻지 못할수도 있기 때문이다.&lt;/p&gt;

&lt;h1 id=&quot;91-자바엔터프라이즈-플랫폼과-스프링-애플리케이션&quot;&gt;9.1 자바엔터프라이즈 플랫폼과 스프링 애플리케이션&lt;/h1&gt;

&lt;p&gt;스프링으로 만들 수 있는 애플리케이션의 종류에는 제한이 없다.&lt;/p&gt;

&lt;p&gt;자바 언어를 사용하는 모든 종류의 프로젝트라면 어디든 사용할 수 있다. 웹을 이용히는 자바 엔터프라이즈 시스템 개발에도 사용할 수 있고, 스윙이나 이클립스 RCP로 만드는 독립형 standalone 프 로그램에도 적용 가능하다. 사용할 수 있는 기능에 제한이 있기는 하겠지만 애플릿이나 모바일 애플리케이션 개발에도 이용할 수 있다. 심지어 스프링을 핵심 엔진으로 사용하는 엔터프라이즈 미들웨어 제품도 있다.&lt;/p&gt;

&lt;p&gt;그러나 스프링의 탄생 배경이나 스프링이 주로 제공하는 기능의 목록을 봐도 알 수있듯이, 스프링은 주로 자바 엔터프라이즈 환경에서 동작하는 애플리케이션을 개발하는 목적으로 사용된다.&lt;/p&gt;

&lt;p&gt;서버에서 동작히는 엔터프라이즈 애플리케이션을 제외한 다른 형태의 애플리케이션에 스프링을 제대로 적용하기 위해서는 SpringRCP 프로젝트나 &lt;a href=&quot;http://spring.me/&quot;&gt;Spring.ME&lt;/a&gt; 같은 추가적인 스프링 지원기술이 필요하다.&lt;/p&gt;

&lt;p&gt;따라서 이 책에서는 자바 엔터 프라이즈 환경에서 사용되는 스프링 개발에 관한 내용만을 다룰 것이다.&lt;/p&gt;

&lt;p&gt;자바 엔터프라이즈 애플리케이션은 서버에서 동작하며 클라이언트를 상대로 서비스를 제공하도록 되어 있다. 즉 클라이언트의 요청을 받아서 그에 대한 작업을 수행하고 그 결과를 돌려주는 것이 기본적인 동작 방식이다. 하지만 클라이언트의 요청 없이도 정해진 시간이나 특정 이벤트 발생에 따라 독자적으로 작업을 수행하기도 한다.&lt;/p&gt;

&lt;h2 id=&quot;911--클라이언트와-백엔드-시스템&quot;&gt;9.1.1  클라이언트와 백엔드 시스템&lt;/h2&gt;

&lt;p&gt;엔터프라이즈 애플리케이션은 자신이 클라이언트가 돼서 또 다른 엔터프라이즈 시스템에 서비스를 요청할 수도 있다.&lt;/p&gt;

&lt;p&gt;또는 데이터베이스나 레거시 시스템 같은 엔터프라이즈 정보 시스템(EIS) 이라고 불리는 백엔드 시스템의 기능을 이용해 동작하기도 한다.&lt;/p&gt;

&lt;p&gt;가장 많이 사용되는 구조는 클라이언트가 웹 브라우저이고 백엔드 시스템이 DB인 구성이다.&lt;/p&gt;

&lt;p&gt;간단히 ‘DB를 사용히는 웹 애플리케이션’이라고 한다. 웹 클라이언트와 DB 가 사용되지 않는 시스템은 거의 없으니, 이를 스프링이 사용되는 애플리케이션의 기본 구조라고 생각할 수도 있다.&lt;/p&gt;

&lt;p&gt;그런 면에서 스프링의 주요 기능은 웹 브라우저를 클라이언트로 하고 DB에 데이터를 저장, 조회하는 데 집중되어 있다. 그렇다고 해서 꼭 클라이언트는 웹 브라우저여야 하며 백엔드 시스렘은 DB를 이용 해야만  하는 것만은 아니다. 웹 브라우저에서 동작하기는 하지만, HTML을 사용하는 표준 웹 클라이언트 외에도 Flex 나 X 인터넷 제품처럼 독립적으로 강력한 기능을 가진 RIA Rich Internet Application 클라이언트가 사용되기도 한다.&lt;/p&gt;

&lt;p&gt;또는 HTTP 프로토콜을 이용해 통신하는 다른 엔터프라이즈 시스템일 때도 있다.&lt;/p&gt;

&lt;p&gt;자바 서버가 받아들일 수 있는 방식으로 요청을 보내기만 한다면 어떤 종류의 클라이언트이든 상관없다.&lt;/p&gt;

&lt;p&gt;실제로 MS 의 .NET 애플리케이션도 스프링을 이용하는 클라이언트로 많이 사용된다. 하나의 스프링 애플리케이션이 동시에 여러 종류의 클라이언트를 상대로 서비스를 제공하는 경우도 흔하다. 스프링 엔터프라이즈 애플리케이션이 이용하는 백엔드 시스템으로는 DB는 물론이고 메시징 서버， 메일 서버， 메인프레임도 가능하다.&lt;/p&gt;

&lt;p&gt;자바가 제공하는 접속 방식을 지원 하는 시스템이면 된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;웹 서비스를 제공하는 서버도 자주 사용된다.&lt;/li&gt;
  &lt;li&gt;원격 EJB 서버를 사용할 수도 있다.&lt;/li&gt;
  &lt;li&gt;한 번에 여러 종류의 백엔드 시스템을 이용할 수 있다.&lt;/li&gt;
  &lt;li&gt;여러 개의 DB를 동시에 이용하는 것도 가능하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c4da229c-911e-4824-bebb-5d36d73c03b8/Untitled.png&quot; alt=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c4da229c-911e-4824-bebb-5d36d73c03b8/Untitled.png&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;912-애플리케이션-서버&quot;&gt;9.1.2 애플리케이션 서버&lt;/h2&gt;

&lt;p&gt;스프링으로 만든 애플리케이션을 자바 서버환경에 배포하려면 JavaEE(또는 J2EE) 서버가 필요하다. JavaEE 표준을 따르는 애플리케이션 서버는 크게 두 가지로 구분할 수 있다. 하나는 JavaEE 의 대부분의 표준 기술을 지원하고 다양한 형태의 모듈로 배포가 가능한 완전한 웹 애플리케이션 서버 WAS 이고,&lt;/p&gt;

&lt;p&gt;다른 하나는 웹 모듈의 배포만 기능한 경량급 WAS 또는 서블릿 /JSP 컨테이너다.&lt;/p&gt;

&lt;h3 id=&quot;경량급-was서블릿-컨테이너&quot;&gt;경량급 WAS/서블릿 컨테이너&lt;/h3&gt;

&lt;p&gt;스프링은 기본적으로 톰켓Tomcat 이나 제티 Jetty 같은 가벼운 서블릿 컨테이너만 있어도 충분하다. EJB 나 리소스 커넥터, WAS 가 제공하는 분산 서비스 등이 굳이 필요하지 않다면 서블릿 컨테이너로도 엔터프라이즈 애플리케이션에 필요한 핵심기능을 모두 이용할 수 있다.&lt;/p&gt;

&lt;p&gt;기존에 EJB와 WAS를 사용해야 가능했던 선언적인 트랜잭션 이나 선언적 보안, DB 연결 풀링,  리모팅이나 웹 서비스는 물론이고 추가적인 라이브러리의 도움을 받으면 분산/글로벌 트랜잭션까지도 가능하다.&lt;/p&gt;

&lt;h3 id=&quot;was&quot;&gt;WAS&lt;/h3&gt;

&lt;p&gt;물론 고가의 WAS를 사용하면 그만를 장점이 있다. 성능 면에서는 대단히 낫지 않더라도 미션 크리티컬한 시스템에서 요구하는 고도의 안정성이나 고성능 시스템에서 필수적인 안정적인 리소스 관리 레거시 시스템의 연동이나 기존 EJB로 개발된 모듈을 함께 사용되는 등의 필요가 있다면 상용 또는 오픈소스 WAS를 이용할 수 있다.&lt;/p&gt;

&lt;p&gt;또 WAS는 상대적으로 관리 기능이나 모니터링 기능이 뛰어나서 여러 대의 서버를 동시에 운영할 때 유리한 점이 많다.&lt;/p&gt;

&lt;p&gt;무엇보다도 자바 엔터프라이즈 버전(JavaEE) 표준을 최대한 활용할 수 있다.&lt;/p&gt;

&lt;p&gt;스프링은 3.0 기준으로 J2EE 1.4와 JavaEE 5.0에 완벽히 호환된다. 또 일부 JavaEE 6.0의 기능을 지원하기도 한다.&lt;/p&gt;

&lt;p&gt;스프링의 개발팀은 필요할 때는 비용을 들이더라도 적합한 조건을 가진 WAS를 사용할 것을 권장한다. 스프링은 JavaEE와 배타적이라고 생각하는 사람들도 있는데 그렇지 않다. 스프링은 JavaEE 표준 기술을 적극 지원하고 있다. 물론 WAS를 사용할 때는 분명한 이유와 근거가 있는지 먼저 충분히 검토해야 한다. 훨씬 가볍고 빠르며 저렴한 비용으로 사용할 수 있는 서블릿 컨테이너로도 대개는 충분한데 특별한 이유도 없이 무겁고 다루기 힘든데다 비싸기까지 한 WAS 를 사용할 필요는 없기 때문이다.&lt;/p&gt;

&lt;h3 id=&quot;스프링소스-tcserver&quot;&gt;스프링소스 tcServer&lt;/h3&gt;

&lt;p&gt;톰캣에는 없는 고급서버관리기능 배포기능과 진단기능 기술지원을 받을 수 있다. 근데 결국 운영서버,기술지원은 유료임 ;;;&lt;/p&gt;

&lt;p&gt;실제로 개발환경과 운영환경에서 가장 많이 사용되는 자바서버는 웹 모듈만 지원하는 서블릿 컨테이너인 아파치 톰켓이다.&lt;/p&gt;

&lt;p&gt;스프링을 개발을 책임지고 있는 기업인 스프링소스에는 아파치 프로젝트인 HTTPD 서버와 톰켓의 핵심 개발자들이 포진해 있다.&lt;/p&gt;

&lt;p&gt;톰켓 전문가인 이들이 중심이 돼서 톰켓을 기반으로 엔터프라이즈 스프링 애플리케이션에 최적화된 경량급 애플리케이션 서버인 tcServer를 개발했다.&lt;/p&gt;

&lt;p&gt;tcServer를 이용하면 기존 톰켓에서는 아쉬웠던 고급 서버 관리 기능 배포 기능과 진단 기능을 포함해서 톰켓 전문가에게 받는 기술지원도 함께 제공받을 수 있다.&lt;/p&gt;

&lt;p&gt;대부분의 기능은 사용하지도 않을 고급 WAS를 구매하는 데 비싼 비용을 들이기는 부담스럽고, 그렇다고 운영하고 관리 하기 불편한데다 필요할 때 기술지원도 받을 길이 없는 오픈소스 제품인 톰켓을 그대로 시용하기는 불안하다면 tcServer가 좋은 대안이다.&lt;/p&gt;

&lt;p&gt;tcServer의 가장 큰 장점은 스프링 개발회사가 개발하는 것인 만큼 스프링 애플리케이션 개발과 운영에 꼭 필요한 중요한 기능이 많이 제공된다는 점이다. tcSerer는 개발자 버전이 따로 있어서 개발을 위해서 라면 자유롭게 이용 기능하다. 정식 운영서버에서 사용하고 기술지원을 받으려면 유료로 라이선스를 구매해야 한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;결국 유료 ㅡㅡ;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;913-스프링-애플리케이션의-배포단위&quot;&gt;9.1.3 스프링 애플리케이션의 배포단위&lt;/h2&gt;

&lt;p&gt;스프링으로 만든 애플리케이션은 다음의 세 가지 단위로 배포할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;1-독립-웹모듈&quot;&gt;1. 독립 웹모듈&lt;/h3&gt;

&lt;p&gt;스프링은 보통 war로 패키징된 독립 웹 모듈로 배포된다. 톰켓 같은 서블릿 컨테이너를 쓴다면 독립 웹 모듈이 유일한 방법이다.&lt;/p&gt;

&lt;p&gt;WAS 로 배포한다고 하더라도 독립 웹모듈을 사용하는 경우가 대부분일 것이다. EJB모듈을 함께 사용한다거나 여러개의 웹 모듈을 묶어서 하나의 웹 애플리케이션 모듈로 만들지 않는 한 독립 웹 모률이 가장 단순하고 편리한 배포 단위다.&lt;/p&gt;

&lt;h3 id=&quot;2-엔터프라이즈-애플리케이션&quot;&gt;2. 엔터프라이즈 애플리케이션&lt;/h3&gt;

&lt;p&gt;경우에 따라선 확장자가 ear인 엔터프라이즈 애플리케이션으로 패키징해서 배포할 수도 있다.&lt;/p&gt;

&lt;p&gt;스프링 애플리케이션에서 EJB 모듈을 긴밀하게 사용하거나 반대로 EJB모듈에서 스프링으로 만든 애플리케이션을 이용해야 한다면, EJB와 스프링 웹 모듈을 엔터프라이즈 애플리케이션으로 통합해야 한다.&lt;/p&gt;

&lt;p&gt;때로는 EJB 모듈은 없지만 엔터프라이즈 애플리케이션 배포 방식을 선택하는 경우가 있다. 하나 이상의 웹 모듈과 별도로 분리된 공유 기능한 스프링 컨텍스트를 엔터프라이즈 애플리케이션으로 묶어주는방법이다.&lt;/p&gt;

&lt;h3 id=&quot;3-백그리운드-서비스모듈&quot;&gt;3. 백그리운드 서비스모듈&lt;/h3&gt;

&lt;p&gt;이 두 가지 방법 외에도 J2EEl 1.4에서 등장한 rar패키징 방법도 있다. rar는 리소스 커넥터를 만들어 배포할 때 사용하는 방식인데, 만약 스프링으로 만든 애플리케이션이 UI를 가질 필요는 없고 서버 내에서 백그라운드 서비스처럼 동작할 필요가 있다면 rar 모듈로 만들어서 배포할 수 있다.&lt;/p&gt;

&lt;p&gt;이때는 J2EE 1.4나 그 이상의 표준을 따르는 WAS 가 반드시 필요하다.&lt;/p&gt;

&lt;p&gt;운영 플랫폼이나 서버의 종류는 개발 중에라도 언제든지 필요에 따라 변경이 가능하다.&lt;/p&gt;

&lt;p&gt;어차피 서플릿 컨테이너나 웹 모듈 모두 JavaEE 표준의 일부일 뿐이기 때문에 설정만 바꾸면 어렵지 않게 이전이 가능하다.&lt;/p&gt;

&lt;p&gt;다만 특정 서버환경에서만 제공하는기능을 시용한다면 변경이 힘들 수도 있다. 장기적으로 서버를 변경하거나 서버의 종류를 비꿀 가능성이 있다면, 서버의 기능에 종속되지 않도록 주의하거나 손쉽게 다른 서버의 기능 으로 변경 기능하도록 추상화해서 사용해야 한다.&lt;/p&gt;

&lt;h1 id=&quot;92-개발도구와-환경&quot;&gt;9.2 개발도구와 환경&lt;/h1&gt;

&lt;h2 id=&quot;921-javasejdk-javaee&quot;&gt;9.2.1 JavaSE/JDK. JavaEE&lt;/h2&gt;

&lt;h3 id=&quot;javasejdk&quot;&gt;JavaSE/JDK&lt;/h3&gt;

&lt;p&gt;스프링 3.0은 JavaSE 5 버전에서 추가된 새로운 언어와 문법의 특정을 최대한 활용해서 개발됐기 때문에 기본적으로 JDK 5.0 또는 그 이상을 필요로 한다. 또 일부 기능은 JDK 6.0 의 API 를 이용해 개발된 것도 있다. 예를 들어 JDBC 4.0 의 새로운 API를 사용히는 스프링의 기능이 필요하다면 JDK 6.0을 써야 한다. 스프링 3.0 이전에는 JDK 5.0 이싱벼l 서 사용할 수 있는 최적화된 기능을 별도의 모률로 제공했었다. 하지만 이제는 JDK 5.0 이 기본이 됐으므로 스프링 모률에서 그런 구분 자체가 사라졌다. 특별한 상황이 아니라면 이미 씬SUN 에서 공식지원을 종료해서 그 수명이 다한 JDK 1 .4나 그 이전 환경을 고집할 이유는 없다. 아직도 JDK 1 .4 .2에 머물고 있다면 스프링 3.0을 사용하기 위해서라도 JDK 5.0 이나 그 이후 버전으로 업그레이드해야 한다.&lt;/p&gt;

&lt;h3 id=&quot;javaeej2ee&quot;&gt;JavaEE/J2EE&lt;/h3&gt;

&lt;p&gt;스프링 3.0 이 사용될 자바 엔터프라이즈 플랫폼으로는 J2EE 1.4 버전이나 JavaEE 5.0 이 필요하다. 스프링 3.0 자체는 JDK 6.0과 JavaEE 5.0을 기준으로 개발됐지만 주요 기능은 JDK 5.0 에서 동작하는 J2EE 1.4 버전과 호환되게 제작되어 있다. 다만 J2EE 1.4 버전 서버를 사용할 때는 JDK 5.0 에서 동작하는지 반드시 확인해야 한다. 만약 WAS 자체가 JDK 5.0에서는 사용할 수 없다면 스프링 3.0 의 이용은 불가능하다. 상용 WAS 중에서 WebLogic 9 이나 WebSphere 6.1 같은 서버는 J2EE 1.4 서버이긴 하지만 JDK 5.0 에서 사용할 수 있는 것이다. 따라서 스프링 3.0 의 적용이 가능하다.&lt;/p&gt;

&lt;h2 id=&quot;빈-의존관계-그래프&quot;&gt;빈 의존관계 그래프&lt;/h2&gt;

&lt;p&gt;그림 9-8은 스프링 IDE 가 그려준 빈의 의존관계 그래프다. SpringIDE는 XML 설정파일을 읽어서 자동으로 그래프를 그려준다. 각 빈이 서로 어떻게 참조하고 있는 지, 어떤프로퍼티를갖고 있는지를한눈에 볼수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9df43331-4e45-456f-86b5-a6719cc679dd/Untitled.png&quot; alt=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9df43331-4e45-456f-86b5-a6719cc679dd/Untitled.png&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;924-라이브러리-관리와-빌드-툴&quot;&gt;9.2.4 라이브러리 관리와 빌드 툴&lt;/h2&gt;

&lt;h3 id=&quot;라이브러리-관리의-어려움&quot;&gt;라이브러리 관리의 어려움&lt;/h3&gt;

&lt;p&gt;과연 스프링으로 애플리케이션을 만들 때 어떤 라이브러리 파일들이 필요할까? 스프링 자체만 해도 20개 까지 세분화된 jar 모듈이 존재한다. 스프링이 직접 참조하는 필요 라이브러리는 100 개가 넘는다.&lt;/p&gt;

&lt;p&gt;스프링이 직접 참조하지 않는 프레임워크나 라이브러리 까지 포함하면 스프링으로 만드는 프로젝트에 포함될 가능성이 있는 라이브러리의 종류는 수백여 개에 달할 것이다.&lt;/p&gt;

&lt;p&gt;요즘은 웬만한 기능은 기존의 오픈소스 라이브러리를 활용하기 때문에 프레임워크 하나에 적게는 5~6 개에서 많게는 수십 개씩 의존 라이브러리가 필요한 경우도 많다.&lt;/p&gt;

&lt;p&gt;문제는 이런 의존 라이브러리가 항상 필요한 건 아니라는 점이다. 스프링만 해도 20개의 모듈과 100 여 개의 직접 참조라이브러리가 있지만 그 모든 모듈과 라이브러리가 매번 다 쓰이는 건 아니다.     필요한 기능과 시용하기로 결정한 기술에 따라서 적절한 선택이 필요하다.&lt;/p&gt;

&lt;p&gt;라이브러리마다 여러 개의 버전이 있다는 것도 문제다. 각 라이브러리마다 정확히 어떤 버전을 사용해야 할지도 알아야 한다.&lt;/p&gt;

&lt;p&gt;A 라는 기능을 사용하는 데 필요한 라이브러리는 B의 1.0부터 1.2까지 사이여야하고 B가동작하려면 C 라이브러리의 2.0은반드시 필요한데, B 의 일부 기능을 사용할 때는 선택적으로 D 라이브러리의 3.0 이 있어야 한다는 식의 지식이 필요하다는 뜻이다.&lt;/p&gt;

&lt;p&gt;라이브러리 종류는 같지만 버전이 맞지 않으면 컴파일이 되지 않을 수 있고 운이 나쁘면 컴파일은 정상적으로 되고 동작은 하지만 운영 중에 오류가 발생할 수 있다.&lt;/p&gt;

&lt;p&gt;필요한 라이브러리의 조합을 만들다 보면 복잡한 의존관계 속에서 같은 라이브러 리의 다른 버전이 동시에 펼요해서 문제가 발생하기도 한다. 라이브러리 관리 작업에서 발생할 수 있는 가장 골치 아픈 상황이다. 예를 들어 A 라이브러리는 B와 C 에 의존 한다. 그런데 B와 C 가 각각 D 라는 같은 라이브러리를 다시 의존하고 있다. 문제는 B 와 C 가 각각 다른 버전의 D를 사용하는 경우다. 예를 들어 B는 D의 1.0을 이용하는데 C는 D 의 2.0을 이용한다고 해보자.B와 C는 독립적으로 만들어진 프레임워크 또는 라이브러리라 서로의 호환성에 대해 항상 신경 쓸 수는 없기 때문에 이런 문제가 발생하는 것이다.&lt;/p&gt;

&lt;p&gt;라이브러리 2.0 이 1.0과 완벽히 호환된다면 문제가 없다. 이때는 둘 중에서 최신 버전을 선택하면 된다. 하지만 어떤 경우 버전이 올라가면서 같은 클래스인데도 완전히 다른 방식으로 동작하거나 내부 구조가 바뀌어서 전혀 호환되지 않는 경우도 있다.&lt;/p&gt;

&lt;p&gt;자바는 모듈이라는 개념이 없다. 독립 모듈로 패키징이 가능한 Jar 파일이 있는데 무슨 소리냐고 할지 모르겠지만 정말 모듈 개념이 없다. 만약 같은 패키지와 이름을 가진 클래스지만 구현이 다른 클래스 파일이 a.jar와 b.jar 두 개에 있다고 하자.&lt;/p&gt;

&lt;p&gt;그리고 a.jar 와 b.jar가 모두 클래스패스에 있다고 해보자. 이 경우 모듈 a.jar 안에 있는 클래스를 사용하겠다거나 b.jar 안에 있는 클래스를 사용하겠다고 선택할 수 있을까? a.jar와 b.jar 가 같은 웹 모듈의 라이브러리에 등록되어 있다면 Jar 파일 구분은 별 의미가 없다. 자바의 jar는 기본적으로 압축 패키징 방법일 뿐이지 구분 기능한 독립된 모률이 아니다.&lt;/p&gt;

&lt;p&gt;앞에서 설명한 경우를 다시 생각해보자. 그림 9-11 은 같은 라이브러리의 두 가지 버전이 존재하는 애플리케이션의 의존관계를 나타낸다. C 1.0과 C 2.0 에 이름이 같지만 구현이 다른 클래스가 있다면 이에 의존하고 있는 A 나 B 중 하나는 비정상적으로 동작할 것이다. 라이브러리 의존관계 관리의 가장 큰 난제다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c86a5ff4-2c86-4cab-a124-e6cee1e76a8e/Untitled.png&quot; alt=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c86a5ff4-2c86-4cab-a124-e6cee1e76a8e/Untitled.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 문제를 풀 수 있는 가장 간단한 방법은 재패키징(repackaging) 이다. 한쪽 버전의 클래스를 다른 패키지로 옮겨서 서로 구별되는 클래스로 만들어주는 방법이다. 물론 이에 의존히는 라이브러리의 코드도 변경된 패키지 내의 클래스를 사용하도록 수정돼야 한다. C 1.0과 C 2.0 모두 org.library.LibClass 라는 이름의 클래스를 가졌다고 하자. 두 개의 클래스가 이름은 같지만 호환이 안 된다면 그중 한 버전을 org.library.repack.LibClass 와 같은 식으로 패키지를 바꿔주고 이 버전을 사용하는 라이브러리도 org.library.repack 패키지 밑에 있는 클래스를 쓰도록 만들어야 한다.&lt;/p&gt;

&lt;p&gt;이런 재패키징 작업은 간단하진 않다. 모든 소스 또는 바이트코드를 일일이 찾아서 수정해주는 만만치 않은 작업이다. 실제로 이런 문제가 제법 많이 발생하고 있기 때문에 재패키징을 지원해주는 툴도 존재한다.&lt;/p&gt;

&lt;p&gt;구글 코드에서 찾을 수 있는 명령어를 이용하면 간단한 명령으로 한 번에 복잡한 라이브러리 클래스를 모두 재패키징할 수있다. 스프링이 사용히는 라이브러리의 의존관계를 따져보면 이렇게 버전이 다르면서 같은 라이브러리를 사용하는 경우가 여럿 발견된다. 특히 ASM (http ://asm.ow2.org)은 워낙 많은 곳에서 사용되면서 서로 버전이 호환이 안 되는 경우가 많아 자주 문제를 일으키는 악명 높은 라이브러리다. 그래서 스프링은 ASM 라이브러리를 통째로 재패키징해서 org.springframework.asm 이라는 스프링 패키지 밑으로 클래스를 옮겨두고 이를 사용 한다. 그렇게 해야 하이버네이트를 비롯해서 ASM을 사용하는 여타 라이브러리와 버전 충돌문제를 피할 수 있기 때문이다.&lt;/p&gt;

&lt;p&gt;이렇게 스프링을 이용한 애플리케이션을 만들 때 필요한 라이브러리의 종류와 버전을 적절히 선정하고 개발하면서 추가적으로 필요로 하는 라이브러리를 추가하거나 또는 제거하는 등의 관리 작업은 결코 쉬운 일이 아니다.&lt;/p&gt;

&lt;h3 id=&quot;라이브러리선정&quot;&gt;라이브러리선정&lt;/h3&gt;

&lt;p&gt;다행히도 이미 프로젝트의 기본틀이 잡혀 있고 시용할 라이브러리와 프로젝트폴더 구조까지 다 결정된 프로젝트에 참여해서 순수한 애플리케이션 개발에만 전념할 수 있다면 이런 걱정은 일단 덜 수 있다.&lt;/p&gt;

&lt;p&gt;하지만 자신이 직접 프로젝트를구성하고 필요한 라이브러리를 선정하거나 추가 제거하는 등의 관리를 해야 하는 상황이라면 여러모로 신경 써야할게많다.&lt;/p&gt;

&lt;p&gt;가장 먼저 해야 할 작업은 스프링으로 만드는 애플리케이션에서 정확히 어떤 기능이 필요한지를 정리하는 것이다.&lt;/p&gt;

&lt;p&gt;각 기능을 지원하는 기술이 여러 가지 종류가 있다면 그중에서 어떤 것을 사용할지도 결정해야 한다.&lt;/p&gt;

&lt;h3 id=&quot;스프링모듈&quot;&gt;스프링모듈&lt;/h3&gt;

&lt;p&gt;사용할 기능과 기술 목록이 모두 만들어졌으면 일단 스프링 모듈부터 선정한다. 스프링에는 총 20 개의 모듈이 있다. 일부는 거의 모든 애플리케이션에서 공통적으로 사용되는 필수 모듈이다.&lt;/p&gt;

&lt;p&gt;그 외의 모듈은 애플리케이션의 아키텍처와 사용 기술에 따라서 선택적으로 적용할 수 있다. 어떤 경우에 어떤 모듈이 필요한지에 대해서는 부록 A.2 절 ‘스프링 모률의 의존관계’를 참조하기 바란다. 스프링의 모듈 사이에도 의존관계가 있다. 모듈 사이의 의존관계는 필수와 선택 으로 나뉠 수 있다. 예를 들어 A 모듈이 의존하는 모듈은 B, C, D가 있다고 하자. 이중 B는 필수이고 C, D는 선택 가능하다면 A를 사용할 때 B는 무조건 추가해주면 되고 C와 D는 A 모듈이 가진 기능 중 어떤 것을 사용하느냐에 따라서 필요할 수도 있고 필요 없을 수도 있다.&lt;/p&gt;

&lt;p&gt;부록 A 에 나와 있는 모듈의 의존관계와 주요 기능을 잘 살펴보고 필수 의존모듈과 선택 의존모듈을 잘 구분해서 선정하자.&lt;/p&gt;

&lt;h3 id=&quot;라이브러리&quot;&gt;라이브러리&lt;/h3&gt;

&lt;p&gt;스프링의 각 모듈은 또 다른 모듈에 의존하기도 하지만 오픈소스 라이브러리 또는 표준 API를 필요로 하기도 하고 경우에 따라서는 상용 제품의 라이브러리에 의존한다. 부록 B 에 나와 있는 각 모듈과 라이브러리의 의존관계 매트릭스를 보면 각 모듈이 반드시 필요로하는 라이브러리가 무엇인지 선택적으로 사용하는 것은 무엇인지 알 수 있다.&lt;/p&gt;

&lt;p&gt;부록 B 에 나온 스프링 모듈과 그에 의존하는 라이브러리의 종류와 특징을 살펴보고 그 중에서 적절한 라이브러리를 선택한다.&lt;/p&gt;

&lt;p&gt;부록 B 에 소개된 스프링 의존 라이브러리는 스프링이 직접 참조하는 라이브러리일 뿐이다. 때로는 각 라이브리리를 활용하는 방법에 따라서 다른 서드파티 라이브러리를 필요로 하는 경우가 있다.&lt;/p&gt;

&lt;p&gt;예를 들어 하이버네이트는 스프링 애플리케이션에서 자주 사용되고, 스프링이 직접 지원하고 있기 때문에 스프링의 의존 라이브러리에 속한다.&lt;/p&gt;

&lt;p&gt;그런데 하이버네이트 자체를 놓고 보면 다시 세부 기능을 어떻게 사용하느냐에 따라서 또 다른 라이브러리가 필요할 수 있다. 이와 같은 정보는 해당 프레임워크나 라이브러리의 문서를 참조해서 필요한 라이브러리가 어떤 것인지 직접 찾아 봐야한다.&lt;/p&gt;

&lt;p&gt;부록 A와 부록 B 에 나와 있는, 모듈과 라이브러리의 의존관계와 필요한 경우에 대한 설명을 주의 깊게 읽어보고 적용하면 기본적으로 필요한 라이브러리를 선정할 수 있다.&lt;/p&gt;

&lt;p&gt;하지만 때로는 어떤 라이브러리를 추가해야 할지 말지 애매한 경우가 있다. 그런 경우 에는 어쩔 수 없이 시행착오 방법을 이용해야 한다.&lt;/p&gt;

&lt;p&gt;먼저 모든 스프링 관련 라이브러리 jar 파일을 모두 가져다 하나의 폴더에 몰아넣고 각각 별도의 폴더에 압축을 풀어준다. 대부분의 압축 유틸리티가 지원하는 ‘파일 이름을 폴더로 해서 압축 풀기’ 기능을 활용하면 된다.&lt;/p&gt;

&lt;p&gt;그리고 확실히 필요하다고 생각되는 최소한의 라이브러리와 모률만 가지고 일단 개발을 시작한다. 코드를 만들고 테스트를 수행하거나 애플리케이션을 기동하면 아마도 클래스를 찾을 수 없다는 예외 (ClassNotFoundException )를 만나게 될 것이다. 찾을 수 없다는 클래스의 이름을 가지고 라이브러리 압축을풀어둔폴더에서 검색을해본다. OS 의 탐색기의 검색 기능이나명령 행에서 파일을 검색하는 명령을 사용하면 된다. 클래스를 찾게 되면 그 클래스가 어느 라이브러리 jar 파일에서 나온 것인지 확인한 뒤에 해당 파일을 추가해준다. 그리고 다시 태스트나 애플리케이션을 돌려서 필요한 클래스와 라이브러리 파일을 계속 추가 해준다. 애플리케이션의 주요 기능을 가진 간단한 샘플을 하나 만들어가면서 해보면 빠르면 한두 시간 안에 필요한 라이브러리 파일을 모두 찾아낼 수 있을 것이다.&lt;/p&gt;

&lt;p&gt;이왕 이면 어떤 기능을 동작시켰을 때 어떤 클래스와 라이브러리가 필요했는지 기록해두면 나중에 도움이 된다. 단순하고 미련한 방법으로 보이겠지만 스프링 애플리케이션에서꼭 필요한 라이브러리를 찾는 데 가장 효과적인 방법이다.&lt;/p&gt;

&lt;p&gt;인터넷에서 jar 파일을 압축을 풀지 않고 검색하는 방법이나 Jar 파일 검색을 지원히는 툴을 찾아 시용해도 좋을것이다.&lt;/p&gt;

&lt;p&gt;필요한 라이브러리가 없으면 애플리케이션이 동작하다가 에러가 나거나 아예 컴파일되지 않는다. 반대로 필요하지 않은 라이브러리가 있을 땐 아무런 문제가 발생하지 않는다. 하지만 불필요한 라이브러리를 추가해두는 것은 또 다른 위험이 있다.&lt;/p&gt;

&lt;p&gt;때로는 무작정 모든 라이브러리 파일을 다 추가해놓고 사용하는 개발자도 있다. 그 때문에 애플리케이션 모률의 파일 크기가 커지는 것은 물론이고 이후에 라이브러리를 관리히는데 심각한애를먹을수도 있다.&lt;/p&gt;

&lt;p&gt;때로는 의존라이브러리의 버전충돌문제처럼 풀기 어려운 문제가 발생하기도 한다. 따라서 불필요한 라이브러리는 처음부터 추가하지 않아야 하며, 사용 기술이나 기능이 변경돼서 불필요해진 라이브러리도 바로 제거할 수 있도록노력해야만한다.&lt;/p&gt;

&lt;p&gt;물론 라이브러리 관리는 어떤 방법을 쓰더라도 간단하지 않다. 이미 만들어진 다양한 프레임워크와 라이브러리의 조합으로 애플리케이션을 만드는 시대이기 때문이다.&lt;/p&gt;

&lt;p&gt;또 빠르게 업데이트되는 기술과 버전이 주는 부담도 있다. 부록 A와 부록 B 에 나오는 의존관계 정보를 참고해서 성실하고 꼼꼼하게 필요한 라이브러리와 모ㅠ듈을 찾아 사용 하는길이 최선이다.&lt;/p&gt;

&lt;h1 id=&quot;93-애플리케이션-아키텍처&quot;&gt;9.3 애플리케이션 아키텍처&lt;/h1&gt;

&lt;p&gt;클라이언트와 백엔드 시스템의 종류와 사용 기술, 연동 방법을 결정했다면 시스탬 레벨의 아키텍처는 대략 구성된 셈이다. 다음으로 결정할 사항은 스프링 웹 애플리케이션의 아키텍처다.&lt;/p&gt;

&lt;p&gt;아키텍처는 여러 가지 방식으로 정의되고 이해될 수 있는 용어다. 가장 단순한 정의를 보자면 어떤 경계 안에 있는 내부 구성요소들이 어떤 책임을 갖고 있고, 어떤 방식으로 서로 관계를 맺고 동작하는지를 규정히는 것이라고 할 수 있다.&lt;/p&gt;

&lt;p&gt;아키텍처는 단순히 정적인 구조를 나타내는 것으로만 생각하기 쉽지만 실제로는 그 구조에서 일어나는 동적인 행위와 갚은 관계가 있다.&lt;/p&gt;

&lt;h2 id=&quot;931-계층형-아키텍처&quot;&gt;9.3.1 계층형 아키텍처&lt;/h2&gt;

&lt;p&gt;관심, 책임, 성격이 변하는 이유와 방식이 서로 다른 것들을 분리함으로써 분리된 각 요소의 응집도는 높여주고 서로의 결합도를 낮춰췄을 때의 장점과 유익이 무엇인지 살펴 봤다.&lt;/p&gt;

&lt;p&gt;성격이 다른모듈이 강하게 결합되어 한데 모여 있으면 한가지 이유로 변경이 일어날때 그와 상관이 없는 요소도 함께 영향을 받게 된다. 따라서 불필요한 부분까지 변경이 일어나고 그로 인해 작업은 더뎌지고 오류가 발생할 가능성이 높아진다.&lt;/p&gt;

&lt;p&gt;어느 부분을 수정해야 할지를 파악하기도 쉽지 않다. 따라서 인터페이스와 같은 유연한 경계를 만들어두고 분리하거나 모아주는 작업이 필요하다.&lt;/p&gt;

&lt;h3 id=&quot;아키텍처와-soc&quot;&gt;아키텍처와 SoC&lt;/h3&gt;

&lt;p&gt;지금까지는 주로 오브젝트 레벨에서 이런 분리의 문제에 대해 생각해봤다. 성격이 다른 코드가 얽혀 있는 것을 두 개의 오브젝트로 분리하고, 그 사이에 유연한 결합을 가질 수있도록 인터페이스를 두고 그 관계를 맺어주는 제 3 의 존재인 DI 컨테이너를 둬서 오브젝트 끼리는 직접적인 관계를 알지 못하도록 만드는 것이 지금까지 해온 DI를 기반으로한 유연한 설계와 구현 전략이었다.&lt;/p&gt;

&lt;p&gt;이런 원리는 아키텍처 레벨에서 좀 더 큰 단위에 대해서도 동일하게 적용할 수 있다. 오브젝트를 하나의 모듈단위라고 생각해보자. 때론 그보다 작은 단위, 예를 들면 하나의 클래스 안에 있는 메소드 레벨에서도 같은 원리를 적용할 수 있다. 심지어 하나의 메소드 안의 코드에도 같은 방식의 접근이 가능하다. 반대로 모듈의 단위를 크게 확장해 볼수도있다.&lt;/p&gt;

&lt;p&gt;애플리케이션을 구성하는 오브젝트들을 비슷한 성격과 책임을 가진 것들끼리 묶을수 있다.&lt;/p&gt;

&lt;p&gt;예를 들면 데이터 액세스 로직을 담당하는 DAO들은 하나의 단위로 생각해도 좋다. 어떤 DAO든 비슷한 성격을 띠고 유사한 방식으로 다른 오브젝트와 관계를 갖는다.  또 비즈니스 로직을 구현해놓은 비즈니스 서비스 오브젝트들도 같은 성격으로 묶을수 있다. 서비스 오브젝트들은 특정 기술과 환경에 종속되지 않으면서 도메인의 업무에는 밀접하게 관련을 갖고 있는 POJO로 만들어진다.&lt;/p&gt;

&lt;p&gt;주로 DAO를 이용해 정보의 저장과 검색 등을하고, DB 의 엔티티 모델과 유사한 도메인 오브젝트를 이용해 데이터를 저장하고 가공하고 주고받는다. 아직 다루진 않았지만 웹을 처리히는 코드 또한 독자적인 성격으로 분류가 가능하다.&lt;/p&gt;

&lt;p&gt;서블릿 컨테이너로부터 받은 사용자의 요청정보를 해석해서 그것을 POJO 기반의 서비스 오브젝트에 전달해주고, 결과를 받아서 다시 웹 사용자 인터페이스에 표시 가능한 형태로 변환해주는 일을 한다.&lt;/p&gt;

&lt;p&gt;이렇게 애플리케이션의 오브젝트들은 다시 유사한 성격을 띤 그룹으로 나눌 수가 있다. 만약 이렇게 나뉘어 있지 않다면 어떻게 될까?&lt;/p&gt;

&lt;p&gt;DB 에서 정보를 어떻게 가져오는지에 대한 로직을 담은 SQL과, JDBC 코드와 HTML 태그 사이에 읽어온 정보를 넣는 코드가 함께 존재할 수도 있다.&lt;/p&gt;

&lt;p&gt;성격과 책임이 분명히 다른 것들이 한데 모여 얽혀 있으면 많은 문제가 발생한다.&lt;/p&gt;

&lt;p&gt;JSP 만으로 웹 애플리케이션을 작성해본 경험이 있는 사람이라면 이런 문제점을 잘 알고 있을 것이다. 테이블을 어떻게 그리는지를 &amp;lt;table&amp;gt; 태그로 작성하다가, 업무 로직에 따라 값을 계산하기 위해 &amp;lt;% if %&amp;gt; 문을 넣었다가, DB 접속을 위해 &amp;lt;% getConnection( … ) %&amp;gt;을 써서 커넥션을 가져오고 SQL도 적고, 결과에 따라서 다른 화면으로 넘어가게 하는 조건도 달고 … 급한 마옴에 일단 동작은 하도록 어떻게 해서든 만들기는 했지만 나중에 자신이 만든 코드도 다시 손대기 싫을 만큼 지저분한 것을 보고는 차라리 다시 작성하는 편이 빠르겠다고 생각했을지 모르겠다.&lt;/p&gt;

&lt;p&gt;그래서 성격이 다른 것은 아키텍처 레벨에서 분리해주는 게 좋다. 이렇게 분리된 각 오브젝트는 독자적으로 개발과 테스트가 가능해서 개발과 변경 작업이 모두 빨라질 수있다. 또 구현 방법이나 세부 로직은 서로 영향을 주지 않고 변경될 수 있을 만큼 유연하다. 전체를 이해하기도 상대적으로 쉽다. 물론 아주 간단한 Hello World 정도의 프로 그램이라면 JSP 하나에 모아놓고 만드는 게 더 쉬울지 모르지만, 제대로 된 게시판 하나만 만들려고 해도 적절한 분리는 필수다.&lt;/p&gt;

&lt;p&gt;이렇게 책임과 성격이 다른 것을 크게 그룹으로 만들어 분리해두는 것을 아키텍처 차원에서는 계층형 아키택처 layered architecture 라고 부른다.&lt;/p&gt;

&lt;p&gt;또는 계층이라는 의미를 가진 영어 단어인 티어 tier를 써서 멀티티어 아키텍처라고도 한다. 보통 웹 기반의 엔터프라이즈 애플리케이션은 일반적으로 세 개의 계층을 갖는다고 해서 3계층 애플리케이션이라고도 한다. 물론 반드시 모든 엔터프라이즈 애플리케이션을 3계층으로 만들어야만 하는 것은 아니다. 경우에 따라서 전통적인 3계층 방식이 아닌 다른 구분 방법을 선택하기도 한다.&lt;/p&gt;

&lt;p&gt;또 각 계층을 좀 더 세분화해서 더 작은 단위의 계층으로 나눌 수도 있다. 하지만 전형 적인 웹 엔터프라이즈 애플리케이션은 책임과 성격으로 보자면 일단 3계층의 논리적인 분류가 기능하다. 그것을 물리적으로 또는 전략적으로 세분화하거나 또는 더 결합시켜서 만들 수도 있기는 하지만 그래도 각기 다른 세 가지 특성을 가진 코드의 분류는 여전히 유효하다.&lt;/p&gt;

&lt;h3 id=&quot;3계층-아키텍처와-수직-계층&quot;&gt;3계층 아키텍처와 수직 계층&lt;/h3&gt;

&lt;p&gt;3계층 아키텍처는 백엔드의 DB나 레거시 시스템과 연동히는 인터페이스 역할을 하는 데이터 액세스DataAccess 계층, 비즈니스 로직을 담고 있는 서비스 계층, 주로 웹 기반의 UI를 만들어내고 그 흐름을 관리하는 프레젠테이션 계층으로 구분한다.&lt;/p&gt;

&lt;p&gt;그런데 이 3계층 아키텍처의 각 계층을 부르는 이름은 워낙 다양해서 때론 혼란스러울 수도 있다. 각각 의미가 있는 이름이기 때문에 모두 기억해두고 사용히는 것이 좋다. 그림 9-13 은 3계층 아키텍처의 구조와 그 이름을 보여준다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7d3b02f9-e0f3-43c8-b9dc-f8129a0e4c7b/Untitled.png&quot; alt=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7d3b02f9-e0f3-43c8-b9dc-f8129a0e4c7b/Untitled.png&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;데이터액셰스-계층&quot;&gt;데이터액셰스 계층&lt;/h3&gt;

&lt;p&gt;데이터 액세스 계층은 DAO 계층이라고도 불린다. DAO 패턴을 보편적으로 시용하기 때문이다.&lt;/p&gt;

&lt;p&gt;또한 데이터 액세스 계층은 DB 외에도 ERP , 레거시 시스템, 메인프레임 등에 접근하는 역할을 하기 때문에 EIs(Enterprise Information System)계층이 라고도 한다.&lt;/p&gt;

&lt;p&gt;하지만 대개는 장기적인 데이터 저장을 목적으로 하는 DB이용이 주된 책임이 다. 또 외부 시스템을 호출해서 서비스를 이용하는 것은 기반(infrastructure) 계층으로 따로 분류하기도 한다. 따라서 이 책에서는 데이터 액세스 계층이라고 부르겠다.&lt;/p&gt;

&lt;p&gt;데이터 액세스 계층은 사용 기술에 따라서 다시 세분화된 계층으로 구분될 수 있다. 애플리케이션에서 담당하는 역할에 따라 분류한 3계층 구조와 달리, 데이터 액세스계층 안에서 다시 세분화히는 경우는 추상화 수준에 따른 구분이기 때문에 수직적인 계층이라고 부르기도 한다. 기본 3계층은 기술 계층보다는 역할에 따라 구분한 것이므로 보통 그림으로 나타낼 때도 가로로 배열한다.&lt;/p&gt;

&lt;p&gt;반면에 같은 책임을 가졌지만 추상화 레벨에 따라 구분하는 경우는 세로로 배열해서 표현한다. 스프링의 JdbcTemplate을 사용히는 DAO 계층이라면 그림 9-14와 같이 나타낼 수 있다. 이렇게 계층이라는 말은 각각 다른 의미와 상햄서 쓰일 수 있으니 문맥에 맞게 적절한 의미로 이해해야 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8c170ec3-279a-4bf2-97ee-511fff9776b6/Untitled.png&quot; alt=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8c170ec3-279a-4bf2-97ee-511fff9776b6/Untitled.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;JdbcTemplate을 사용히는 데이터 액세스 계층의 특정은 JdbcTemplate 이 추상화를 위한 계층으로 사용돼서 로우레벨의 기반 계층에 존재하는 JDBC와 드라이버, 스프링의 트랜재션 추상화 서비스의 동기화 기능을 간접적으로 이용하게 만든다는 것이다.&lt;/p&gt;

&lt;p&gt;물론 JdbcTemplate이 있어도 DAO 코드에서 강제로 JDBC API를 직접 이용하거나 트랜잭션 동기화 API에 접근하는 것이 불가능하진 않다.&lt;/p&gt;

&lt;p&gt;하지만 추상화 계층구조를 따른다면 항상 JdbcTemplate을 통해 접근하도록 코드를 작성하는 것이 바람직하다. 추상화 계층은 필요하다면 얼마든지 추가할 수 있다. 만약 JdbcTemplate 의 기능과 7장에서 만들었던 SqlService 의 SQL을 가져오는 기능을 묶어서 더 단순한 방법으로 DAO 코드를 작성하고 싶다면 또 하나의 추상 계층을 추가할 수 있다.&lt;/p&gt;

&lt;p&gt;그림 9-15 는 이렇게 새로운 추상 계층을 도입해서 하위 계층의 종류가 다른 서비스를 일관된 방식으로 접근할 수 있게 만들어주는 구조다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f563bf73-0873-4d87-a302-6682e213b0dc/Untitled.png&quot; alt=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f563bf73-0873-4d87-a302-6682e213b0dc/Untitled.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이렇게 새로운 계층을 추가하면 개발자의 애플리케이션 코드에 지대한 영향을 주기 때문에 매우 신중하게 결정해야 한다. 한번 새로운 계층과 API를 만들어 적용하면 이를 최대한 유지할 수 있도록 하위 계층의 변화에 대응해야 하는 책임도 갖게 된다. DAO 코드의 사용 패턴을 개발팀 또는 프로젝트 수준에서 잘 분석하고 정리할 수 있다면 새로운 추상 계층의 도입을 고려해볼 만하다. 만약 추상 계층을 새로 추가하는 것은 부담스럽고 경우에 따라서 유연하게 하위 계층의 API 를 활용할 필요가 있다면, 공통적인 기능을 분리해서 유틸리티나 헬퍼 메소드 또는 오브젝트로 제공해주는 것도 좋은 방법이다. 이때는 하위 계층과 공통 기능의 사용 방법에 대한 가이드라인이나 코딩 정책이 잘 만들어져서 개발자에게 제공될 필요가 있다.&lt;/p&gt;

&lt;h3 id=&quot;서비스계층&quot;&gt;서비스계층&lt;/h3&gt;

&lt;p&gt;서비스 계층은 구조로 보자면 가장 단순하다. 잘 만들어진 스프링 애플리케이션의 서비스계층 클래스는 이상적인 POJO로 작성된다.&lt;/p&gt;

&lt;p&gt;POJO로 만든다면 객체지향적인 설계기법이 적용된 코드를 통해서 비즈니스 로직의 핵심을 잘 담아내고, 이를 쉽게 테스트하고 유연하게 확장할 수 있다. 서비스 계층은 DAO 계층을 호출하고 이를 활용해서 만들어진다.&lt;/p&gt;

&lt;p&gt;때론 데이터 액세스를 위한 기능 외에 서버나 시스템 레벨 에서 제공하는 기반 서비스를 활용할 필요도 있다.&lt;/p&gt;

&lt;p&gt;예를 들어 웹 서비스와 같은 원격 호출을 통해 정보를 가져오거나 메일 또는 메시징 서비스를 이용하는 것이 대표적인 예다. 이런 기반 서비스는 3 계층 어디에서나 접근이 가능하도록 만들 수도 있고， 아키텍처를 설계하기에 따라서 반드시 서비스 계층을 통해 사용되도록 제한할 수도 있다. 코드의 특정과장단점 활용 예를 잘 살펴서 결정하면 된다. 서비스 계층은 특별한 경우가 아니라면 추상화 수직 계층구조를 가질 필요가 없다. 단순히 POJO 레벨에서 비즈니스 로직을 모델링하다가 상속구조를 만들 수 있을진 몰라도 기술 API를 직접 다루는 코드가 아니기 때문에 기술에 일관된 방식으로 접근하게 하거나 편하게 사용하게 해주는 추상화는 필요 없기 때문이다.&lt;/p&gt;

&lt;p&gt;기반 서비스 계층을 사용하는 경우에도 데이터 액세스 계층을 사용하는 경우와 마찬가지로 독립된 계층의 서비스를 이용하는 것으로 봐야 한다.&lt;/p&gt;

&lt;p&gt;비즈니스 로직을 담은 서비스 계층과 엔터프라이즈 서비스를 제공하는 기반 서비스 계층은 이름 때문에 혼동되기 쉬우므로주의하자.&lt;/p&gt;

&lt;p&gt;그림 9-16은 서비스 계층과 기반 서비스 계층 DAO 계층의 관계를 나타낸 것이 다. 여기서는 기반 서비스 계층이 3계층 어디에서나 접근이 가능한 구조로 설정했다. 여기서 눈여겨봐둘 것은 기반 서비스 계층이 서비스 계층의 오브젝트를 호출히는 경우다. 일반적으로는 서비스 계층이 필요에 따라 기반 서비스 계층의 API를 호출해서 이용한다.&lt;/p&gt;

&lt;p&gt;하지만 반대로 서비스 계층의 코드를 기반 서비스 계층에서 실행시키는 경우가 있다.&lt;/p&gt;

&lt;p&gt;스케줄링이 대표적인 경우다. 미리 정해진 시간에 특정 서비스 계층의 로직이 동작하게 만드는 백그라운드 서비스가 필요하다면 그때는 기반 서비스 계층에서 서비스 계층의 오브젝트를 이용하게 할 수도 있다.&lt;/p&gt;

&lt;p&gt;원칙적으로 서비스 계층 코드가 기반 서비스 계층의 구현에 종속되면 안 된다. 서비스 계층의 코드는 추상화된 기반 서비스 인터페이스를 통해서만 접근하도록 만들 어서 특정 구현과 기술에 대한 종속성을 제거해야 한다. 또는 AOP를 통해서 서비스 계층의 코드를 침범하지 않고 부가기능을 추가하는 방법을 활용해야 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3240441b-c84f-4666-9e64-a9e3fc1b40d8/Untitled.png&quot; alt=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3240441b-c84f-4666-9e64-a9e3fc1b40d8/Untitled.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이상적인 서비스 계층은 백엔드 시스템과 연결되는 데이터 액세스 계층이 바뀌고, 클라이언트와 연결되는 프레젠테이션 계층이 모두 바뀌어도 그대로 유지될 수 있어야 한다. 엔터프라이즈 애플리케이션에서 가장 중요한 자산은 도메인의 핵심 비즈니스 로직이 들어 있는 서비스 계층이어야 한다&lt;/p&gt;

&lt;h3 id=&quot;프레젠테이션계충&quot;&gt;프레젠테이션계충&lt;/h3&gt;

&lt;p&gt;프레젠테이션 계층은 가장 복잡한 계층이다. 프레젠테이션 계층은 매우 다양한 기술과 프레임워크의 조합을 가질 수 있다.&lt;/p&gt;

&lt;p&gt;웹과 프레젠테이션 기술은 끊임없이 발전하고 진보하고 새로운 모댈이 등장하기 때문이다. 따라서 프레젠태이션 계층에서 사용할 기술과 구조를 선택하는 일은 간단하지 않다.&lt;/p&gt;

&lt;p&gt;엔터프라이즈 애플리케이션의 프레젠테이션 계층은 클라이언트의 종류와 상관없이 HTTP 프로토콜을 사용하는 서블릿이 바탕이 된다. HTTP 외의 프로토콜을 사용하는 엔터프라이즈 서비스가 전혀 없는 것은 아니지만, 방화벽 문제라든가 통합된 보안의 문제 등으로 인해 HTTP로 모두 수렴되는추세다.&lt;/p&gt;

&lt;p&gt;단순한 HTML과 자바스크립트만을 사용하는 브라우저이든, 다운로드돼서 브라우저의 플러그인 안에서 동작하는 플래시 애플리케이션이나 액티브X 기반의 애플리케이션이든, 닷넷으로 만든 독립형 애플리케이션이든, RESTful 스타일의 클라이언트 또는 WS-* 방식의 웹 서비스 클라이언트든 상관없이 대부분의 엔터프라이즈 애플리케이션을 사용하는 클라이언트들은 HTTP 프로토콜을 선호한다.&lt;/p&gt;

&lt;p&gt;따라서 이런 클라이언트와 연결돼서 동작하는 프레젠테이션 계층은 자바에서 HTTP 프로토콜을 처리하는 가장 기본 엔진이 서블릿 기술을 바탕으로 한다.&lt;/p&gt;

&lt;p&gt;프레젠테이션 계층은 다른 계층과 달리 클라이언트까지 그 범위를 확장될 수도 있다. 초기 클라이언트 모댈은 단순히 HTML로 만들어진 결과를 사람이 볼 수 있도록 그려주고, 폼을 통해 입력받은 값을 전달하는 것이었다. 모든 프레젠테이션 로직은 서버의 프레젠테이션 계층의 컴포넌트에서 처리된다. 화면 흐름을 결정하는 것이나 사용자 입력 값에 대한 검증, 서비스 계층의 호출과 전달되는 값의 포맷의 변화， 뷰View라고 불리는 화면을 어떻게 그릴지에 대한 로직 등이 모두 서버에서 처리됐다.&lt;/p&gt;

&lt;p&gt;이때의 클라이언트는 단순히 서버 프레젠테이션 계층의 기능에 대한 사용자 인터페이스에 불과했다. 하지만 최근에는 점점 많은 프레젠테이션 로직이 클라이언트로 이동하고 있다. RIA (Rich Internet Application) 라고 불리는 기술이나 SOFEA(Service Oriented Front End Architecture) 아키텍처가 대표적인 예다.&lt;/p&gt;

&lt;p&gt;스프링은 웹 기반의 프레젠테이션 계층을 개발할 수 있는 전용 웹 프레임워크를 제공한다. 동시에 스프링은 다양한 서드파티 웹 기술을 지원하기도 한다. 아예 프레젠테이션 계층을 통째로 스프링이 아닌 다른 웹 기술을 가져다 사용할 수도 있다. 스프링 애플리케이션에 적용할 수 없는 웹 기술은 없다고 봐도 좋다. 심지어 JSP를 사용히는 모델 l 을 사용할 수도 있으니 말이다.&lt;/p&gt;

&lt;h3 id=&quot;계층형-아키텍처-설계의-원칙&quot;&gt;계층형 아키텍처 설계의 원칙&lt;/h3&gt;

&lt;p&gt;오브젝트와 그 관계에 적용했던 대부분의 객체지향 설계의 원칙은 아키텍처 레벨의 계층과 그 관계에도 동일하게 적용할 수 있다. 각 계층은 응집도가 높으면서 다른 계층과는 낮은결합도를 유지할수있어야한다.&lt;/p&gt;

&lt;p&gt;각 계층은 자신의 계층의 책임에만 충실해야 한다. 데이터 액세스 계층은 데이터 액세스에 관한 모든 것을 스스로 처리해야 한다. 데이터 액세스 계층에 비즈니스 로직을 담거나 웹 파라미터를 파싱하는 코드나 결과를 화면에 어떻게 뿌릴지 결정히는 코드가 들어간다면 응집도가 낮아진다.&lt;/p&gt;

&lt;p&gt;결과적으로 변화에 대한 유연성이 떨어지고 이해하기 힘든 코드를 가진 계층이 되고 말 것이다. 각 계층은 자신의 역할에만 충실해야 하고 자신과 관련된 기술이 아닌 다른 기술 API 의 사용을 삼가해야 한다. 자신의 역할과 기술에만 충실한 계층을 만들면 각 계층 사이의 결합도는 자연스럽게 낮아진다.&lt;/p&gt;

&lt;p&gt;각 계층이 자신의 책임에 충실하게 작성되어 있다면 필요한 그 밖의 작업은 다른 계층에 요청하게 될 것이다.&lt;/p&gt;

&lt;p&gt;이때는 계층 레벨에 정의한 인터페이스를 통해서 요청을 하게 되고, 계층 간에 사용되는 인터페이스 메소드에는 특정 계층의 기술이 최대한 드러나지 않게 만들어야 한다. 그렇지 않으면 계층 사이에 결합도가 높아질 뿐만 아니라, 계층 간의 기술이나 역할이 서로 침범히는 일이 일어난다.&lt;/p&gt;

&lt;p&gt;종종 실수하는 계층 간 설계의 예를 살펴보자. 다음은 서비스 계층이 DAO를 호출할때 사용하도록 정의한 인터페이스의 메소드다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ResultSet&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;findUsersByName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SQLException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;findUsersByName() 메소드의 문제는 데이터 액세스 계층의 기술과 그 역할을 다른 계층에 노출한다는 점이다.&lt;/p&gt;

&lt;p&gt;결과를 JDBC 의 ResultSet 오브젝트로 돌려주면 이를 사용 하는 서비스 계층의 코드는 ResultSet 이라는 데이터 액세스 계층에서 만들어진 오브젝 트를 직접 다뤄야만 한다. 결국 JDBC 라는 특정 데이터 액세스 계층 기술에 종속되는 서비스 계층의 코드가 되고 만다.&lt;/p&gt;

&lt;p&gt;또한 ResultSet 을 다룰 때 발생하는 예외처리도 필요 하고, 경우에 따라서는 리소스를 반환하거나   DB 커넥션을 종료시키는 등의 데이터 액세스 작업도 맡아야 한다. 예외도 마찬가지다. 앞에서 살펴봤듯이 SQLException 이라는 JDBC 기술 종속 적인 예외를,  그것도 체크 예외로 던져버리면, 이를 사용하는 서비스 계층에서는 SQLException을 해석해서 예외상황을 분석하고 이를 처리하는 코드를 만들어야 한다.&lt;/p&gt;

&lt;p&gt;특정 데이터 액세스 계층의 구현에 종속되는 강한 결합이 만들어진다. 계층 간에 강한 결합이 생기면 유연성이 떨어지기 때문에 각 계층의 내부 구현이 변화되면 다른 계층의 묘드도 함께 수정해줘야 한다. 또한 코드의 중복이 일어날 가능성이 높고 전체 묘드를 이해하기는 힘들어진다. 오브젝트 간의 강한 결합이 있을 때 발생 하는 문제와 성격이 유사하고 그 파장은 훨씬 심각하다.&lt;/p&gt;

&lt;p&gt;계층에는 수많은 오브젝트가 있고 그 오브젝트가 다른 계층의 오브젝트와 어떻게 관계를 맺는지에 대한 일반적인 규칙이 있기 때문이다. 앞의 DAO 인터페이스의 메소드는 다음과 같이 수정돼야 한다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;findUsersByName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DataAccessException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;User는 사용자 정보를 담고 있는 단순한 오브젝트다. 따라서 특정 계층의 기술이나 구현에 종속되지 않는다. 결과는 이렇게 특정 계층에 종속되지 않는 단순한 오브젝트의 형태로 전달해야 한다. 또 데이터 액세스 예외와 같이 특별한 경우에만 전달될 기능성이 있는 것은 스프링의 DataAccessException 처럼 런타임 예외로 만들어야 한다.&lt;/p&gt;

&lt;p&gt;그래서 대개는 그 존재를 무시해도 되도록 만들어야 한다. 특별한 이유로 데이터 액세스 예외를 다뤄야 히는 경우에라도 JOBC , JPA , JDO , 하이버네이트처럼 특정 구현 방식에 종속되지 않는 추상적인형태로 만들어줘야 한다.&lt;/p&gt;

&lt;p&gt;그렇게 해야만 낮은 결합도를 유지할수 있고유연한변경이 가능해진다.&lt;/p&gt;

&lt;p&gt;또， 흔히 저지르는 실수 중의 하나는 프레젠테이션 계층의 오브젝트를 그대로 서비스 계층으로 전달하는 것이다. 서블릿의 HttpServletRequest 나 HttpServletResponse HttpSession 같은 타입을 서비스 계층 인터페이스 메소드의 파라미터 타입으로 사용하면 안된다.&lt;/p&gt;

&lt;p&gt;계층의 경계를넘어갈때는반드시 특정 계층에종속되지 않는 오브젝트 형태로 변환해줘야한다.&lt;/p&gt;

&lt;p&gt;만약 서비스 계층의 코드에 웹 프레젠테이션 계층의 기술을 노출했다고 해보자. 웹방식의 클라이언트가 아닌 다른 시스템에서 요청을 받아서 처리해야 하는 경우에는 웹기술에 종속된 코드는 재사용이 불가능해진다.&lt;/p&gt;

&lt;p&gt;결국 같은 로직을 가졌지만 클라이언트의 종류에 따라서 비즈니스 로직 코드가 달라지는 결과를 초래할 수도 있다. 서비스 계층에서 웹과 관련된 예외가 발생할 수도 있다. 이때 문제의 원인을 찾기가 어려워지기 쉽다. 더 큰 문제는 테스트다. 서비스 계층에 웹 관련 오브젝트가 존재하면 POJO 기반의 빠르고 간단한 단위 테스트를 작성하기 힘들어진다.&lt;/p&gt;

&lt;p&gt;어떤 경우에라도 계층 사이의 낮은 결합도를 깨뜨리지 않도록 설계해야 한다.&lt;/p&gt;

&lt;p&gt;당연히 계층 사이의 호출은 인터페이스를 통해 이뤄져야 한다. 인터페이스를 하나 더 만드는 것이 번거롭다고 그냥 클래스를 이용해서는 안 된다.&lt;/p&gt;

&lt;p&gt;인터페이스를 사용하게 한다는건 각 계층의 경계를 넘어서 들어오는 요청을 명확히 정의하겠다는 의미다. 여기서 말하는 인터페이스란 단지 자바의 interface 키워드를 사용하라는 의미가 아니다. 인터 페이스에 아무 생각 없이 클래스의 모든 public 메소드를 추가한다면 인터페이스를 사용하는 가치가 떨어진다.&lt;/p&gt;

&lt;p&gt;한번 정의돼서 다른 계층에서 사용하기 시작한 엔터페이스 메소드는 변경이 매우 까다롭고 비용이 많이 든다. 따라서 매우 신중하게 결정해야 하며 계층 내부의 예상되는 변화에도 쉽게 바뀌지 않도록 주의해서 만틀어야 한다. 당연히 다른 계층에서 꼭 필요한 메소드만 노출해야 한다.&lt;/p&gt;

&lt;p&gt;스프링의 DI 는 기본적으로 오브젝트 사이의 관계를 다룬다. 따라서 계층 사이의 경계나 그 관계에 직접적으로 관여하지 않는다. 하지만 모든 경계에는 오브젝트가 존재하고 그 사이의 관계도 오브젝트 대 오브젝트로 정의되기 마련이다. 그런 면에서 스프링의 DI가 계층사이의 관계에도 적용된다고볼수 있다. 하지만 DI는 계층을구분해주지 않기 때문에 빈 사이의 의존관계를 만들 때 주의해야 한다.&lt;/p&gt;

&lt;p&gt;한 계층의 내부에서만 사용 되도록 만든 빈 오브젝트가 있는데 이를 DI 를 통해 다른 계층에서 함부로 가져다 쓰는 일은 피해야 한다는 말이다. 또, 중간 계층을 건너뛰어서 관계를 갖지 않는 계층의 빈을 직접 DI 하지 않도록주의해야한다.&lt;/p&gt;

&lt;h2 id=&quot;932-애플리케이션-정보-아키텍처&quot;&gt;9.3.2 애플리케이션 정보 아키텍처&lt;/h2&gt;

&lt;p&gt;엔터프라이즈 시스템은 본질적으로 동시에 많은 작업이 빠르게 수행돼야 하는 시스템이다. 사용자의 작업 상태를 오래 유지할 수 있는 독립 애플리케이션과 달리 엔터프라이즈 애플리케이션은 일반적으로 사용자의 요청을 처리하는 동안만 간단한 상태를 유지한다.&lt;/p&gt;

&lt;p&gt;애플리케이션의 주요 상태정보는 클라이언트나 백엔드 시스템에 분산돼서 보관된다. 비교적 장기간 보관되는 상태정보는 주로 DB 나 메인프레임 같은 EIS 백엔드 시스랩에 저장된다.&lt;/p&gt;

&lt;p&gt;하나의 업무 작업이 여러 번의 요청과 페이지에 걸쳐 일어나는 경우에 유지돼야 하는 임시 상태정보는 클라이언트에 일시적으로 보관되기도 하고 서버의 사용자별 세션 메모리에 저장되기도 한다.&lt;/p&gt;

&lt;p&gt;이렇게 애플리케이션을 사이에 두고 흘러다니는 정보를 어떤 식으로 다룰지를 결정하는 일도 아키텍처를 결정할 때 매우 중요한 기준이 된다.&lt;/p&gt;

&lt;p&gt;엔터프라이즈 애플리케이션에 존재하는 정보를 단순히 데이터로 다루는 경우와 오브젝트로 다루는 경우, 두 가지 기준으로 구분해볼 수 있다.&lt;/p&gt;

&lt;p&gt;데이터 중심 아키텍처는 애플리케이션에 흘러다니는 정보를 단순히 값이나 값을 담기 위한 목적의 오브젝트 형태로 취급히는 구조다 DB나 백엔드 시스템에서 가져온 정보를 값으로 다루고 그 값을 취급하는 코드를 만들어 로직을 구현하고 값을 그대로 프레젠태이션 계층의 뷰, 즉 사용자가 보는 화면과 연결해주는 것이다.&lt;/p&gt;

&lt;p&gt;이런 방식은 객체지향 기술이나 언어를 사용하지 않던 시절의 엔터프라이즈 애플리케이션과 크게 다를 바 없다.&lt;/p&gt;

&lt;p&gt;데이터 중심 설계의 특징은 비즈니스 로직이 DB 내부의저장 프로시저나 SQL 에 담겨 있는 경우가 많다는 점이다.&lt;/p&gt;

&lt;p&gt;보통 DB 에서 돌려주는 내용을 그대로 맵이나 단순 결과 저장용 오브젝트에 넣어서 전달한다. DB 결과 값을 사용 하는 일부 비즈니스 로직이 서비스 계층에 존재하기도 하고 아무런 가공 없이 그대로 프레젠테이션 계층에 전달되어 사용자에게 보이기도 한다.&lt;/p&gt;

&lt;p&gt;데이터 중심 아키텍처는 핵심 비즈니스 로직을 어디에 많이 두는지에 따라서 DB에 무게를 두는 구조와 서비스 계층의 코드에 무게를 두는 구조로 구분할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;dbsql-중심의-로직-구현-방식&quot;&gt;DB/SQL 중심의 로직 구현 방식&lt;/h3&gt;

&lt;p&gt;데이터 중심 구조의 특징은 하나의 업무 트랜잭션에 모든 계층의 코드가 종속되는 경향이 있다는 점이다. 예를 들어 사용자의 이름으로 사용자 정보를 검색해서 일치하는 사용자의 아이디, 비밀번호， 이름, 가입일자만을 보여주는 작업이 있다고하자.&lt;/p&gt;

&lt;p&gt;이것이 하나의 업무 단위가 되면 모든 계층의 코드가 이 기준에 맞춰서 만들어진다. 사용자 조회 라는 단위 업무를 위해서만 존재하는 각 계층의 코드가 만들어진다는 뜻이다.&lt;/p&gt;

&lt;p&gt;검색조건은 SQL로 만들어진다. 사용자 정보를 웹 페이지에 나타낼 때 가입일자 중에서 연도만 보여줘야 한다면, 가입일자 필드에서 연도를 추출하는 것은 SQL 의 날짜처리 펑션을 이용해야 한다.&lt;/p&gt;

&lt;p&gt;그래야 SQL의 결괴를 그대로 웹 페이지의 정보 필드에 1: 1로 매핑해서 넣어줄 수 있기 때문이다.&lt;/p&gt;

&lt;p&gt;결국 SQL은 이미 화면에 어떤 식으로 출력이 될지 알고 있는 셈이다.&lt;/p&gt;

&lt;p&gt;SQL 의 결과는 컬럼 이름을 키로 갖는 맵에 저장되거나 조회 페이지에 필요한 네 가지 정보를 담을 수 있는 단순한 오브젝트를 저장돼서 전달된다.&lt;/p&gt;

&lt;p&gt;서비스계층은 별로 할일이 없다. 프레젠테이션 계층의 JSP 뷰는 DAO의 SQL에서 정확히 어떤 펼드 값을 리턴할지, 어떤 포맷으로 전달할지 알고 있다.&lt;/p&gt;

&lt;p&gt;SQL의 SELECT 절에 나오는 컬럼 이름을 그대로 사용해서 전달된 맵이나 결과를 저장히는 오브젝트에서 값을 가져와 화면에 출력한다. 만약 새로운 필드가 추가되거나 DB 테이블의 컬럼 이름이 변경됐다면, 그에 따라서 맵이나 오브젝트에 저장될 엔트리 또는 프로퍼티 이름이 바뀌거나 추가될 것이 고 그에 맞게 뷰의 내용도 변경된다.&lt;/p&gt;

&lt;p&gt;모든 계층의 코드는 ‘이름을 이용한 고객 조회’라는 업무에 종속된다.&lt;/p&gt;

&lt;p&gt;또한 업무의 내용이 바뀌면 모든 계층의 코드가 함께 변경된다.&lt;/p&gt;

&lt;p&gt;종속적일 뿐 아니라 배타적이어서 다른 단위 업무에 재시용되기 힘들다. 유사한 방법의 사용자 조회용 DAO 메소드라도 화면에 나타날 정보가 다르면 SQL 이 달라지기 때문에 새로 만들어야 한다.&lt;/p&gt;

&lt;p&gt;대용량 데이터를 다루면서 빠른 처리가 필요한 경우에는 일부 로직을 DB 내에 존재하는 PL/SQL과 같은 저장 프로시저 형태로 만들기도 한다. 조회 로직이 조건이 많고 복잡하다면 그만큼 복잡한 SQL 이 만들어 질 것이다. 자바 코드의 로직은 기껏해야 사용자 요청에 따라서 어떤 SQL을 가진 DAO를 실행할지 를 결정히는 정도일 것이다.&lt;/p&gt;

&lt;p&gt;대부분의 코드는 대응되는작업 단위에 1 : 1 로 매핑된다. 여러 작업에서 반복되는 기능이 었다면 그에 대한 코드는 중복되기 쉽다. 보통 작업 단위,  즉 업무 트랜잭션 단위로 코드를 묶어서 만들지 기능을 세분화해서 분리하고 재사용하지 않기 때문이다. 하나의 업무 트랜잭션을 모두 담은 서비스 계층 코드와 해당 업무에 특화된 SQL을 담은 하나 또는 여러 개의 DAO 메 소드로 구성된다.&lt;/p&gt;

&lt;p&gt;서비스 계층이 프레젠테이션 계층에 전달 하는 결과의 포맷은 보통 DAO 의 SQL 결과와 같고, 웹페이지의 출력 내용과도 1: 1 로대응된다. 그림 9-17은 이런 방식의 아키텍처 구조를 나타낸다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/27a8efba-c9cd-4756-910a-01350fad4c63/Untitled.png&quot; alt=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/27a8efba-c9cd-4756-910a-01350fad4c63/Untitled.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이런 식의 개발 방법과 아키텍처는 사실 자바 기술이 발전하기 이전의 엔터프라이즈 시스템에서 흔히 발견할 수 있다. 굳이 자바라는 객체지향 언어와 프로그래밍 기술을 사용하지 않더라도 3계층구조로 만드는전통적인 개발방법에서, 또는 서비스계층이 별의미가 없으므로 주요로직을 클라이언트의 독립 프로그램에 담아두고 DB 처리 로직만 DB 에 분리해둔 2계층 구조에서도 비슷하게 발견할 수 있다.&lt;/p&gt;

&lt;p&gt;이런 방식은 개발하기 쉽다는 장점이 있다. 적어도 처음에는 그렇다.&lt;/p&gt;

&lt;p&gt;대부분의 개발 자는 이미 복잡한 로직을 SQL로 작성하는 데 익숙하다. 계층으로 세분화되기는 하지만 업무 트랜잭션, 또는 요구사항별로 구분해서 코드로 만드는 건 쉽다. 각 업무의 핵심을 담은 SQL을 중심으로 DAO부터 사용자가 보는 화면까지 한 벌씩 만들면 되기 때문에 툴이나 코드 생성기를 이용해서 자동화하는 데도 유리하다.&lt;/p&gt;

&lt;p&gt;하지만 이런 방식은 자바 코드를 단지 DB 와 웹 화면을 연 결 해주는 단순한 인터페이스 도구로 전락시키는 것이다. 자바의 오브젝트는 단지 HTTP 서비스 채널을 만들어주고 JDBC를 이용해 DB 기능을 사용하게 히는 스크립트 정도로 역할이 축소된다.&lt;/p&gt;

&lt;p&gt;굳이 자바를 쓰지 않고 전통적인 언어나 단순한 스크립트 언어 또는 DB 등에서 제공히는 툴로 대치하더라도 별 차이가 없을 것이다.&lt;/p&gt;

&lt;p&gt;이렇게 DB 중심의 업무 단위로 코드를 만들면 애플리케이션 내에서 흘러다니는 정보는 항상 단순한 포맷의 데이터다. 간혹 필요하다면 SQL 의 결과로 가져온 데이터를 분석하거나 조작히는 간단한 비즈니스 로직을 추가할 수는 있다. 하지만 이런 코드는 항상 SQL과 그 결과에 종속되기 때문에 SQL 의 변화가 일어나면 같이 변경돼야 한다.&lt;/p&gt;

&lt;p&gt;겉으로 보기에는 각 계층이 독립적으로 보이지만 그 사이를 이동하는 데이터가 일종의 접착제 역할을 해서 강한 결합을 만들게 된다.&lt;/p&gt;

&lt;p&gt;스프링을 사용하면 이런 데이터 중심의 코드를 만들 수 있을 뿐만 아니라, 실제로 매우 흔하게 발견된다. 데이터와 업무 트랜잭션 중심의 개발에 익숙한 사람들이 많고 이런 아키텍처를 의도적으로 선호히는 개발자도 많기 때문이다. 개발자들끼리 서로 간섭 없이 자신에게 할당된 기능을 독립적으로 만드는 데도 편하다. 최소한의 공통 모둘 정도만 제공되는 것을 사용하고 그 외의 기능은 단위 업무 또는 웹 화면 단위로 만들 어진다.&lt;/p&gt;

&lt;p&gt;하지만 이런 개발 방식은 변화에 매우 취약하다.&lt;/p&gt;

&lt;p&gt;객체지향의 장점이 별로 활용되지 못히는데다 각 계층의 코드가 긴밀하게 연결되어 있기 때문이다.&lt;/p&gt;

&lt;p&gt;중복을 제거하기도 쉽지 않다. 업무 트랜잭션에 따라 필드 하나가 달라도 거의 비슷한 DAO 메소드를 새로 만들기도 한다. 또한 로직을 DB 와 SQL 에 많이 담으면 담을수록 점점 확장성이 떨어진다. DB 는 확장에 한계가 있을 뿐 아니라 확장한다 하더라도 매우 큰 비용이 든다.&lt;/p&gt;

&lt;p&gt;잘 작성된 복잡한 SQL 하나가 수백 라인의 자바 코드가 펼요한 비즈니스 로직을 한번에 처리할수도 있다. 하지만과연 바람직한 것일까? 이런 복잡한 SQL을누구나 쉽게 이해하고필요에 따라유연하게 변경할수 있을까?&lt;/p&gt;

&lt;p&gt;또, 복잡한 SQL을처리하기 위해서 제한된 자원인 DB 에 큰 부담을 주는 게 과연 바람직한 일인지 생각해볼 필요가 있다.&lt;/p&gt;

&lt;p&gt;상대적으로 애플리케이션 서버와 그 안에 담긴 오브젝트는 비용이 적게 든다. 서버를 늘려 쉽게 확장할 수도 있다. 애플라케이션 서버의 비용은 매우 빠르게 하락하고 있다. 또 손쉽게 여러 대의 서버를 클러스터로 묶어서 하나의 서버처럼 동작하게 만들 수있다.&lt;/p&gt;

&lt;p&gt;오브젝트를 만들고 코드를 동작시키는 비용은 DB 에서 비슷한 작업을 할 때에 비해 저렴하다. 따라서 로직을 DB 보다는 애플리케이션으로 가져오는 편이 유리한 점이 많다. 비용도 저렴해질 뿐 아니라 안정성도 높아지고 코드를 검증하기도 매우 편하다.&lt;/p&gt;

&lt;p&gt;게다가. SQL 이나 저장 프로시저에 담긴 로직은 테스트하기 힘들다. 반면에 오브젝트에 담긴 로직은 간단히 검증할 수 있다. 또한 요즘 유행하는 객체지향 분석과 모델링의 결과로 나온 모델을 가져다 쉽게 오브젝트로 만들어낼 수 있다. 따라서 DB 에는 부하를 가능한 한 주지 않는 간단한 작업만 하고 복잡한 로직은 오브젝트에 담아서 애플리케이션 내에서 처리하도록 만드는 편이 낫다. 애플리케이션 서버는 저렴한 비용으로 손쉽게 서버를추가할수 있다.&lt;/p&gt;

&lt;p&gt;어쨌든 정치적이거나 현실적인 문제로 인해 이런 아키텍처와 접근 방법을 어쩔 수없이 선택해야 히는 경우도 있겠지만 단지 익숙하고 편하다는 이유로 스프링 애플리케이션 개발에도 여전히 DB 중심의 아키텍처를 선택한다면 스프링의 장점을 제대로 누릴수 있는 기회를 얻지 못할 것이 분명하다.&lt;/p&gt;

&lt;h3 id=&quot;거대한서비스계층방식&quot;&gt;거대한서비스계층방식&lt;/h3&gt;

&lt;p&gt;DB 에서 가져온 데이터가 애플리케이션에 흘러다니는 정보의 중심이 되는 아키텍처이긴 하지만 DB 에 많은 로직을 두는 개발 방법의 단점을 피하면서 애플리케이션 코드의 비중을 높이는 방법이 있다.&lt;/p&gt;

&lt;p&gt;DB 에는 부하가 걸리지 않도록 저장 프로시저의 사용을 자제하고 복잡한 SQL을 피하면서, 주요 로직은 서비스 계층의 코드에서 처리하도록 만드 는것이다.&lt;/p&gt;

&lt;p&gt;여전히 SQL 의 결과를 그대로 담고 있는 단순한 오브젝트 또는 맵을 이용해 데이터를 주고받는다. 대신 많은 비즈니스 로직을 DB 의 저장 프로시저나 SQL 에서 서비스 계층의 오브젝트로 옮겨왔기 때문에 애플리케이션 코드의 비중이 커진다. 그만큼 구조는 단순해지고 객체지향 개발의 장점을 살릴 기회가 많아진다.&lt;/p&gt;

&lt;p&gt;비즈니스 로직을 DB 나 SQL 에 담는 경우에는 항상 최종 결과만 DAO 에서 서비스 계층으로 전달된다. 반면에 거대 서비스 계층 방식에서는 DAO 에서 좀 더 단순한 결과를 돌려준다.&lt;/p&gt;

&lt;p&gt;DAO 가 돌려준 정보를 분석, 가공하면서 비즈니스 로직을 적용하는 것은 서비스 계층 코드의 책임이 된다. DAO와 SQL은 상대적으로 단순해지고, 그중 일부는 여러 서비스 계층 코드에서 재사용이 가능해진다.&lt;/p&gt;

&lt;p&gt;비즈니스 로직이 복잡해지면 서비스 계층의 코드도 매우 복잡해지고 커진다. 업무 트랜잭션 단위로 서비스 계층의 메소드가 만들어질 가능성이 높은데， 그러다 보면 하나의 메소드가 매우 거대해지기도 한다. 이를 여러 메소드로 분산시킨다면 메소드 크기는 상대적으로 줄겠지만 전체 클래스 코드의 양은 그대로다.&lt;/p&gt;

&lt;p&gt;상대적으로 단순한 DAO 로직을 사용하고, 비즈니스 로직의 대부분을 서비스 계층에 집중하는 이런 접근 방법은 결국 거대한 서비스 계층 ( Fat service layer) 을 만들게 된다. 데이터의 분석， 처리와 함께 비즈니스 로직의 대부분이 서비스 계층 코드에 집중되기 때문이다. 서비스 계층의 코드는 여전히 업무 트랜잭션 단위로 집중돼서 만들어지기 때문에 DAO를 공유할 수 있는 것을 제외하면 코드의 중복도 적지 않게 발생한다.&lt;/p&gt;

&lt;p&gt;그림 9-18은 거대 서비스 계층 방식의 아키텍처를 나타낸 것이다. 데이터 액세스 계층이나 DB 는 비즈니스 로직을 직접 담고 있지 않기 때문에 이전보다 훨씬 가벼워진다.&lt;/p&gt;

&lt;p&gt;대신 DB 가 돌려주는 데이터를 가지고 비즈니스 로직을 구현하는 서비스 계층이 매우 두터워진다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2ff6986e-d223-48e9-b1c2-aa9b31410398/Untitled.png&quot; alt=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2ff6986e-d223-48e9-b1c2-aa9b31410398/Untitled.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;거대 서비스 계층 방식의 장점은 애플리케이션의 코드에 비즈니스 로직이 담겨 있기 때문에 자바 언어의 장점을 활용해 로직을 구현할 수 있고 테스트하기도 수월하다는 점이다.&lt;/p&gt;

&lt;p&gt;또한 DAO가 다루는 SQL 이 복잡하지 않고 프레젠테이션 계층의 뷰와 1:1로 매핑 되지 않아도 되기 때문에 일부 DAO 코드는 여러 비즈니 스 로직에서 공유해서 사용할 수있다.&lt;/p&gt;

&lt;p&gt;하지만 데이터 액세스 계층의 SQL은 서비스 계층의 비즈니스 로직의 필요에 따라 만들어지기 쉽다. 그래서 계층 간의 결합도가 여전히 크다.&lt;/p&gt;

&lt;p&gt;서비스 계층의 메소드는 크기가 큰 업무트랜잭션 단위로 만들어지기 때문에 비슷한 기능의 코드가여러 메소드에서 중복돼서 나타나기 쉽다. 자주 사용되는 세부 로직을 추출해서 공통 기능으로 뽑아 내는 일도 불가능하진 않지만 일반화하기는 힘들다. 그 이유는 DAO가 제공해주는 값의 포맷에 따라 이 를 취급하는 방법이 달라지기 때문이다.&lt;/p&gt;

&lt;p&gt;사용자 정보를 간단히 조작해주는 공통적인 기능이 있다고 하자. 그런데 어떤 비즈니스 로직에서는 DAO로부터 시용자 정보를 다른 정보와 조인해서 함께 맵에 담아 가져오고， 또 어떤 로직에서는 사용자 정보 중 일부만 데이터 저장 오브젝트에 담아서 가져온다고 해보자. 이런 경우 사용자 정보가 담겨 있는 포뱃과 타입이 다르기 때문에 공통적인 사용자 정보 처리 기능을 만들어 사용하기가 힘들다.&lt;/p&gt;

&lt;p&gt;비록 DAO 에 복잡한 조건의 로직을 넣지는 않더라도 서비스 계층에서 필요한 정보를 한 번에 SQL을 통해 가져 오고, 그 값을 저장하는 방식이 일관성 없이 매번 달라질 수 있기 때문에 서비스 계층의 코드나 DAO 에 적지 않은 중복이 발생히는 것이다.&lt;/p&gt;

&lt;p&gt;반면에 각 단위 업무별로 독립적인 개발이 가능하므로 초기 개발 속도가 빠르고, 개발자 사이에 간섭 없이 독립적인 개발이 가능하다는 장점이 있다. 또한 핵심 로직이 자바코드 안에 담겨 있으므로 테스트하기가 상대적으로 수월하다.&lt;/p&gt;

&lt;p&gt;하지만 본격적인 객체 지향적 설계를 적용하기 힘들고, 개발자 개개인의 코딩 습관이나 실력에 따라서 비슷한 로직이더라도 전혀 다른 스타일의 코드가 나오기 십상이다. 개발 능력이 떨어지는 경우 에는 자바 코드로 구현한 비즈니스 로직이 복잡한 SQL보다 더 이해하기 힘들 수도 있다. 또한 계층별로 독립된 설계와 개발이 어렵고, 개발이 진행되면서 구현할 비즈니스 로직이나 설계에 변경이 생기거나 유지보수 중에 수정할 필요가 있을 경우 코드를 손대 기가 쉽지 않을 수 있다. 철저한 테스트를 만들어뒀다면 상대적으로 낫겠지만, 테스트가 불충분하거나 아예 없다면 오히려 SQL이나 저장프로시저보다 더 다루기 힘든 스파게티 코드로 전락할 위험도 있다.&lt;/p&gt;

&lt;p&gt;데이터 중심 아키텍처의 특정은 계층 사이의 결합도가 높은 편이고 응집도는 떨어진 다는 점이다. 화면을 중심으로 히는 업무 트랜잭션 단위로 코드가 모이기 때문에 처음엔 개발하기 편하지만 중복이 많아지기 쉽고 장기적으로 코드를 관리하고 발전시키기 힘들다는단점이있다.&lt;/p&gt;

&lt;h2 id=&quot;933-오브젝트-중심-아키텍처&quot;&gt;9.3.3 오브젝트 중심 아키텍처&lt;/h2&gt;

&lt;p&gt;오브젝트 중심 아키텍처가 데이터 중심 아키텍처와 다른 가장 큰 특징은 도메인 모델을 반영하는 오브젝트 구조를 만들어두고 그것을 각 계층 사이에서 정보를 전송하는 데 사용한다는 것이다.&lt;/p&gt;

&lt;p&gt;그래서 오브젝트 중심 아키텍처는 객체지향 분석과 모델링의 결과로 나오는 도메인 모델을 오브젝트 모델로 활용한다. 대개 도메인 모델은 DB의 엔티티 설계에도 반영되기 때문에 관계형 DB 의 엔티티 구조와도 유사한 형태일 가능성이 높다.&lt;/p&gt;

&lt;p&gt;물론 DB 에는 없지만 비즈니스로직에만 존재히는 모델도 있기 때문에 항상 일치하는 것은아니다. 이렇게 오브젝트를 만들어두고 오브젝트 구조 안에 정보를 담아서 각 계층 사이에 전달하게 만드는 것이 오브젝트 중심 아키텍처다.&lt;/p&gt;

&lt;h3 id=&quot;데이터와-오브젝트&quot;&gt;데이터와 오브젝트&lt;/h3&gt;

&lt;p&gt;간단한 예를 가지고 데이터와 오브젝트 방식을 비교해보자. 어떤 업무를분석해보니 카테고리와 상품이라는두가지 엔티티가 나온다고 해보자. 카테고리 하나에는 여러 개의 상품이 포함된다. 각 상품은 하나의 카테고리에 소속된다. 전형적인 1:N 의 관계다. 이 도메인 모델을 그려보면 그림 9-19와 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a8ab7538-ee99-4ead-ab0c-3801e1ca534e/Untitled.png&quot; alt=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a8ab7538-ee99-4ead-ab0c-3801e1ca534e/Untitled.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이를 DB 테이블로 만들면 두 태이블 사이의 관계를 위해서 Product 쪽에 Category와 관계를 만들어주는 외래키 FK를 하나 둬야 한다. 그래서 표 9-1 과 같은 태이블로 정의됐 다고하자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/075ffa28-4088-41cd-b251-43cc9d080c80/Untitled.png&quot; alt=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/075ffa28-4088-41cd-b251-43cc9d080c80/Untitled.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;조건에 맞는 모든 카테고리와 상품 정보를 가져와서 화면에 출력하는 기능을 만든다고 해보자.&lt;/p&gt;

&lt;p&gt;이때 데이터 중심 아키텍처에서는 SQL과 DB 관점에서 생각한다.&lt;/p&gt;

&lt;p&gt;이 두 개의 정보를 조합해서 가져오는 방법은 JOIN을 이용해 2차원 구조의 정보를 만드는 것이다.&lt;/p&gt;

&lt;p&gt;따라서 DAO 에서 다음과 같은 SQL을 사용하게 만들 것이다.&lt;/p&gt;

&lt;p&gt;SQL 실행 결과는 맵이나 배열에 담는다.&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;categoryid&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;description&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;productid&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;price&lt;/span&gt; 
&lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;product&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;join&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;category&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;c&lt;/span&gt; 
&lt;span class=&quot;k&quot;&gt;on&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;categoryid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;categoryid&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;배열에 담으려면 인덱스별로 필드 이름을 일일이 기억해야 하기 때문에 불편하다. 배열 대신 맵에 필드 이름과 값을 함께 담고 맵의 리스트를 만들어 돌려주는 게 편리하다.&lt;/p&gt;

&lt;p&gt;DAO 에서는 JDBC로 SQL을 실행하고 받은 결과를 리스트 9-8 과 같이 담아서 서비스 계층으로 넘겨줄 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/162fe14d-8ec0-403d-b22e-d0c1f3c4ce5b/Untitled.png&quot; alt=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/162fe14d-8ec0-403d-b22e-d0c1f3c4ce5b/Untitled.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;서비스 계층에 전달되는 것은 List&amp;lt;Map&amp;lt;String , Object» 타입이다. 이 타입만 봐서는 안에 담긴 내용이 어떤 것인지 알 수 없다.&lt;/p&gt;

&lt;p&gt;따라서 이 결과를 사용하는 서비스 계층이나 프레젠테이션 계층의 코드에서는 DAO 메소드에서 두 개의 테이블을 조인해서 다섯 가지 필드의 값을 가져오고 필드 이름을 키로 갖는 맵에 값을 저장했음을 알아야 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;만약 DAO 에서 SQL을 변경하거나 필드 개수나 순서, 이름을 바꾼다면 서비스 계층과 프레젠테이션 계층의 코드도 같이 변경돼야 한다.&lt;/p&gt;

&lt;p&gt;1:N 관계에 있는두 개의 테이블을 조인해서 2차원 구조로 풀어놓은 데이터이기 때문에 이 안에는 원래 Category와 Product가 I:N 의 관계를 맺고 있었고 어떻게 서로 참조할 수 있는지에 대한 정보는 없다.&lt;/p&gt;

&lt;p&gt;SQL을 통해서 가공된 데이터의 구조를 알고, 이를 활용하는 것이 전부다.&lt;/p&gt;

&lt;p&gt;이렇게 가져온 정보를 웹 페이지 내에서 수정해서 DB 에 다시 반영해야 한다면 어떻게 될까? 사용자가 수정한 정보는 다시 맵이나 배열 등에 담겨서 전달될 것이다.&lt;/p&gt;

&lt;p&gt;DB 수정 작업을 담당하는 DAO는 이렇게 전달되는 데이터의 구조를 알고 있어야 할 것이다. 이렇게 데이터 중심의 아키텍처에서는 DAO 가 만드는 SQL 의 결과에 모든 계층의 코드가 의존하게 된다. 도메인 분석을 통해 작성된 모델정보는 DB 에 대한 SQL을 작성할 때 외에는 코드에 반영되는 일이 없다.&lt;/p&gt;

&lt;p&gt;반면에 오브젝트 방식에서는 애플리케이션에서 사용되는 정보가 도메인 모델의 구조를 반영해서 만들어진 오브젝트 안에 담긴다. 도메인 모델은 애플리케이션 전 계층에서 동일한 의미를 갖는다. 따라서 도메인 모델이 반영된 도메인 오브젝트도 전 계층에서 일관된 구조를 유지한 채로 사용될 수 있다. SQL 이나 웹 페이지의 출력 포맷, 입력폼 등에 종속되지 않는 일관된 형식의 애플리케이션의 정보를 다룰 수 있게 된다.&lt;/p&gt;

&lt;p&gt;먼저 도메인 모델의 구조를 따라서 리스트 9-9와 같이 의미 있는 타입과 정보를 가진 클래스를정의한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3a737f7f-64a3-4405-99e0-15b376601d39/Untitled.png&quot; alt=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3a737f7f-64a3-4405-99e0-15b376601d39/Untitled.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 구조는 단순히 특정 SQL에 대응되는 맵과 배열, 매번 달라지는 SQL 결과를 담기 위해 급조해서 만든 오브젝트외는 달리, 애플리케이션 어디에서도 시용될 수 있는 일관된 형식의 도메인 정보를 담고 있다.&lt;/p&gt;

&lt;p&gt;DB에서 SQL 결과로 가져온 값을 그대로 사용하는 경우외는 다르게,  도메인 모댈을 반영하는 오브젝트를 사용하면 자바 언어의 특성을 최대한 활용할 수 있도록 정보를 가공할 수 있다.&lt;/p&gt;

&lt;p&gt;대표적으로 오브젝트 사이의 관계를 나타내는 방법을 들 수 있다. RDB 에서는 테이블 간의 관계를 직접 명시하는 방법은 없다.&lt;/p&gt;

&lt;p&gt;대신 키의 조합을 통해 그때그때 태이블을 조인해서 의미 있는 관계를 만들어 내야 한다. 반면에 자바에는 관계하고 있는 다른 오브젝트와 직접 연결하는 방법이 있다. 레퍼런스 변수를 이용해서 다른 오브젝트를 참조하는 것이다. 하나 이상의 오브젝트와 관계를 가지려면 컬렉션을 이용할수도 있다.&lt;/p&gt;

&lt;p&gt;그래서 Product 클래스에는 Product 테이블처럼 categoryid 라는 외래키가 없다. 대신 Category 오브젝트를 가리키는 레퍼런스 변수를 갖고 있다.&lt;/p&gt;

&lt;p&gt;반대로 하나의 Category는 여러 개의 Product와 관계를 가질 수 있으므로 Set 이라는 컬렉션을 이용해 여러 개의 Product 오브젝트를 참조하게 만들 수 있다.&lt;/p&gt;

&lt;p&gt;DB 의 Category 테이블에는 Product 테이블과 어떻게 연결되는지에 대한 정보가 없다. 하지만 자바에서는 레퍼런스 변수를 통한 상호 참조가 가능하기 때문에 원한다면 Category 오브젝트에서 다음과 같은 코드로 Category 에 속한 Product를 간단히 가져올 수도 있다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Product&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;products&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myCategory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getProducts&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;데이터 중심 방식에서는 Category와 그에 대응되는 Product 를 찾아 SQL을 이용해 조인한 디음 하나의 맵에 뭉뚱그려서 가져왔다.&lt;/p&gt;

&lt;p&gt;반면에 오브젝트 중심 방식에서는 테이블의 정보와 그 관계를 유지한 채로 정확한 개수의 Category 오브젝트와 그에 대응되는 Product 오르젝트로 만들어 사용한다.&lt;/p&gt;

&lt;p&gt;따라서 테이블에 Category가 하나이고 그에 대응되는 Product열이 5개라면 오브젝트도 하나의 Category 오브젝트와 이에 연결된 5개의 Product 가 만들어질 것이다.&lt;/p&gt;

&lt;p&gt;이 두 가지 오브젝트는 레퍼런스 변수를 통해 서로 연결되어 있기 때문에 메소드 파라미터나 리턴 값으로 전달할 때 Category 오브젝트 하나를 전달하더라도 그에 연결된 Product 5개가 함께 전달된다. 반대로 Product 의 컬렉션을 전달해도된다. 어차피 레퍼런스를 따라가면 서로 참조할 수 있기 때문이다. 이렇게 도메인 모델을 따르는 오브젝트 구조를 만들려면 DB 에서 가져온 데이터를 도메인 오브젝트 구조에 맞게 변환해줄 필요가 있다.&lt;/p&gt;

&lt;p&gt;한 번 변환되면 그 이후의 작업은 수월해진다. DAO는 자신이 DB 에서 가져와서 도메인 모델 오브젝트에 담아주는 정보가 어떤 업무 트랜잭션에서 어떻게 사용될지는 신경 쓰지 않아도 된다.&lt;/p&gt;

&lt;p&gt;서비스계층 또한 DAO에서 어떤 SQL을 사용했는지는 몰라도 된다. Category와 Product 정보를 두개의 SQL로 나눠서 가져왔든, 하나의 SQL로 조인해서 가져왔든 상관없다.&lt;/p&gt;

&lt;p&gt;서비스 계층에서 필요한 정보를 조건에 맞게 조회해서 도메인 모델오브젝트 형태로 돌려주는 DAO를 이용하기만 하면 된다.&lt;/p&gt;

&lt;p&gt;그리고 가져온 도메인 오브젝트에 담긴 정보를 활용해서 비즈니스 로직을 처리하면 된다. 프레젠태이션 계층에 전달할 때도 마찬가지다. 어떤 DAO가 사용됐고, 어떤 비즈니스 로직을 거쳤는지에 관해선 프레젠테이션 계층은 알 필요가 없다. 자신에게 전달된 도메인 오브젝트를 활용해서 필요한 정보를 화면에 출력하기만 하면된다.&lt;/p&gt;

&lt;h3 id=&quot;도메인-오브젝트를-사용하는-코드&quot;&gt;도메인 오브젝트를 사용하는 코드&lt;/h3&gt;

&lt;p&gt;오브젝트 중심 방식에서 비즈니스 로직의 구현이 얼마나 간단하고 명확한지 살펴보자. 어떤 카태고리에 포함된 상품의 모든 가격을 계산해야 하는 로직이 필요하다면 서비스 계층의 오브젝트 안에 리스트 9-10과 같은 메소드를 만들어 사용하면 된다.&lt;/p&gt;

&lt;p&gt;어떤 DAO를 이용해서 Category를 가져왔는지는 중요하지 않다. 조건을 가지고 Category를 하나 검색했을 수도 있고, 모든 Category 목록을 가져왔을 수도 있다. 어떻게든 Category 오브젝트를 갖고 있다면 calcTotalOfProductPrice() 메소드를 호출해서 카태고리에 담긴 모든 상품가격의 합을 계산할수있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8465e65d-499e-4e11-90ff-72c457ca0748/Untitled.png&quot; alt=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8465e65d-499e-4e11-90ff-72c457ca0748/Untitled.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;도메인 모델을 알고 있다면 calcTotalOfProductPrice() 메소드가 무슨 작업을 하는지 이해하기 어렵지 않다.&lt;/p&gt;

&lt;p&gt;테스트를 만들어 검증하기도 간단하고, 로직이 변경될 때묘드를 수정하기도 수월하다. Category 자체가 독립된 오브젝트이므로 서비스 계층 어디에서든지 Category 의 상품 가격을 계산해야 할 때는 이 메소드를 사용하면 된다. Category 내의 상품 가격을 계산하는 코드가 여러 개의 업무 트랜잭션에서 필요하다고 해도 코드의 중복이 일어나지 않을 수 있다. 반면에 데이터 중심 방식에서라면 이런식의 재사용 가능한 메소드를 만들어 사용하기가 쉽지않다.&lt;/p&gt;

&lt;p&gt;DAO 에 메소드를 추가해서 select sum(p.price) 로 시작하는 SQL을 실행해 DB 가 계산해주는 결과를 한 번에 가져오는 방법을 사용하려고 할지 모르겠다.&lt;/p&gt;

&lt;p&gt;아니면 주어진 카테고리에 포함된 상품의 가격 값의 목록을 배열 등에 담아서 돌려주는 DAO를 만들고 배열을 이용해서 합계를 계산하는 코드를 만들 수도 있다.&lt;/p&gt;

&lt;p&gt;문제는 하나의 Category 에 대해 상품 가격의 합을 계산하는 로직이라면 이런 방법을 사용하겠지만이미 DAO 에서 여러 개의 Category와 Product를 조인해서 가져옹 경우라면 별도의 합계 계산 코드를 만들어야 한다는 점이다.&lt;/p&gt;

&lt;p&gt;아마도 적지 않은 for 문과 if 문을 시용해서 Category 와 Product 가 함께 들어 있는 맵이나 리스트를 뒤져 카테고리별 합을 계산하는 코드를 만들게 될 것이다.&lt;/p&gt;

&lt;p&gt;Category 내의 Product 가격 합을 계산하는 동일한 로직인데도 SQL을 통해 데이터를 어떻게 가져왔는지에 따라서 이를 처리히는 다른 코드가 만들어지므로, 코드에 중복이 발생한다.&lt;/p&gt;

&lt;p&gt;오브젝트 구조로 정보를 갖고 있으면 어떤 식으로든 활용하기 펀리하다. 자바에서는 ‘.’을 이용해 레퍼런스 변수를 따라가면 관련된 정보를 손쉽게 이용할 수 있다. Product 오브젝트가 하나 주어졌을 때, 해당 Product 의 Category 에는 상품이 모두 몇 개가 있는지 알고 싶다면 다음과 같이 간단한 코드를 사용할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;product&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getCategory&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getProducts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;만약 SQL을 이용해 Product 와 Category 를 조인해서 통째로 가져왔다면, 적지 않은 if 문을 사용해야만 이와 기능이 동일한 코드를 만들 수 있다. 아니면 이런 로직을 JOIN과 count() 펑션을 사용하는 SQL에 담아 새로운 DAO 메소드를 추가해야 한다.&lt;/p&gt;

&lt;p&gt;테스트를 만드는 펀리함 면에서도 큰 차이가 있다.SQL 에 담긴 로직을 테스트하는 건 복잡 하고 불편하다.&lt;/p&gt;

&lt;p&gt;반면에 도메인 오브젝트를 사용하는 코드는 간단히 테스트 값을 담은 도메인 오브젝트를 생성해서 쉽게 검증할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;도메인-오브젝트-사용의-문제점&quot;&gt;도메인 오브젝트 사용의 문제점&lt;/h3&gt;

&lt;p&gt;일관된 의미를 가지고 유연하며 애플리케이션 전반에 공유 가능한 도메인 모델을 따르는 오브젝트로 정보를 다루면 많은 장점이 많다.&lt;/p&gt;

&lt;p&gt;코드는 이해하기 쉽고 로직을 작성하기도 수월하다. 프레젠테이션 영역에서도 이미 정의된 도메인 오브젝트 구조만 알고 있다면 아직 DAO가 작성되지 않았어도뷰를 미리 만들수도 있다. 코드의 재사용성은 높아지고 DAO는 더 작고 효율적으로 만들어질 수 있다.&lt;/p&gt;

&lt;p&gt;하지만 단점도 있다. 최적화된 SQL을 매번 만들어 사용하는 경우에 비해 성능 면에서 조금은 손해를 감수해야 할 수도 있다. DAO는 비즈니스 로직의 사용 방식을 알지 못하므로, 도메인 오브젝트의 모든 필드 값을 다 채워서 전달하는 경우가 대부분이다.&lt;/p&gt;

&lt;p&gt;그런데 하나의 오브젝트에 담긴 필드의 개수가 많아지다 보면 그중에는 드물게 사용되는 필드도 있을 수 있다. 어떤 비즈니스 로직에서 필요한 정보가 몇 개의 펼드뿐이라면 DAO 에서 도메인 오브젝트의 모든 필드 정보를 채워서 전달히는 것은 낭비일 수도 있다. 비즈니스 로직에 따라서 필요한 정보가 달라질 수 있기 때문에 발생하는 문제다.&lt;/p&gt;

&lt;p&gt;오브젝트 관계에도 문제가 있다. 만약 단순히 Product 정보만 필요한 비즈니스 로직이 있다고 해보자. 그런데 DAO가 돌려준 Product 오브젝트에는 관계를 갖고 있는  Category 오브젝트도 함께 담겨 있을 것이다. Category 에 담긴 정보까지 사용될 때도 있겠지만, 어떤 경우에는 Product 에 담긴 정보만 필요할 때도 있다.&lt;/p&gt;

&lt;p&gt;그럼에도 Category 오브젝트까지 다 조회해서 오브젝트로 만들어서 가져오는 것은 상당한 낭비다. 물론 Product 정보를 가져올 때 Category 가 필요한 경우와 그렇지 않은 경우를 구분해서 DAO를 만틀어줄 수 있다. 하지만 문제는 DAO 에서 Product 만 가져오게 하면 Product 의 category 필드에는 null 값이 들어간다는 점이다. 불필요한 오브젝트를 생성하는 일을 피할 수 있어서 좋기는 한데， 자칫 비즈니스 로직 코드를 작성하다가 그런 사실을 깜박하고 product 의 category 필드를 사용할 경우 예상치 못했던 NullPointerException을 만날 수도 있다.&lt;/p&gt;

&lt;p&gt;결국 최적화를 고려해서 DAO를 작성하려면 DAO는 비즈니스 로직에서 각 오브젝트를 어디까지 사용해야 하는지 어느 정도 알고 있어야 한다. 그래서 데이터 중심 접근 방법의 단점이라고 봤던， DAO와 비즈니스 로직코드의 결합도가 높아지는 문제가 발생할 수도 있다.&lt;/p&gt;

&lt;p&gt;프레젠테이션 계층에서도 마찬가지다. Product 오브젝트를 전달받아서 Product 내의 필드값만 사용할 수도 있고 연결된 Category 의 정보까지 출력할 수도 있기 때문이다.&lt;/p&gt;

&lt;p&gt;이런 문제를 해결하는 접근 방법은 여러 가지가 있다. 지연된 로딩 lazy loading 기법을 이용하면 일단 최소한의 오브젝트 정보만 읽어두고 관계하고 있는 오브젝트가 필요한 경우에만 다이내믹하게 DB 에서 다시 읽어올 수 있다.&lt;/p&gt;

&lt;p&gt;물론 도메인 오브젝트를 사용하는 코드는 이런 사실을 전혀 의식하지 않고 처음부터 모든 오브젝트의 정보가 다 제공된다고 생각하고 작성하면 된다.&lt;/p&gt;

&lt;p&gt;필드가 너무 많은 테이블이 있다면 그중에서 자주 시용되는 것을 골라내서 별도의 오브젝트로 정의해두고 필요에 따라 구분해서 사용하게 할 수 있다.&lt;/p&gt;

&lt;p&gt;물론 그에 따라 DAO 메소드가 추가돼야 하고 어느 DAO를 사용할지를 서비스 계층에서 알고 있어야 하기 때문에,  약하긴 하지만 계층 사이의 결합이 발생한다.&lt;/p&gt;

&lt;p&gt;사실 가장 이상적인 방법은 JPA 나 JDO, 하이버네이트， TopLinK와 같은 오브젝트 RDB 매핑 ORM 기술을 사용하는 것이다.&lt;/p&gt;

&lt;p&gt;이런 데이터 액세스 기술은 기본적으로 지연된 로딩 기법 등을 제공해주기 때문에 번거로운 코드를 만들지 않고도 도메인 오브젝트의 생성을 최적화할 수 있다.&lt;/p&gt;

&lt;p&gt;또한 SQL 결과를 가지고 도메인 오브젝트를 만들고 값을 채우는 등의 복잡한 DAO 코드를 만들지 않아도 된다. 내부적으로 최적화된 SQL을 사용 하도록 세밀히 튜닝할 수도 있다. 또 자주 변경되지 않으면서 많은 로직에서 참조하는 레퍼런스 테이블이 있다면 이를 ORM 이 제공하는 오브젝트 캐시에 담아두고 사용할 수도 있다. 코드 테이블처럼 자주 참조되는 것은 오브젝트 캐시로 만들어두면 매번 DB 에서 읽어오지 않고 메모리 캐시에 가져오게 해주기 때문에 DB 의 부하를 줄여줘서 성능 이많이향상된다.&lt;/p&gt;

&lt;p&gt;그래서 도메인 오브젝트를 사용하는 오브젝트 중심 아키텍처에서는 가능하다면 ORM과 같은 오브젝트 중심 데이터 액세스 기술을 사용하는 것을 권장한다. 사용하기 쉽고 직관적이며 코드의 양도 대폭 줄기 때문이다. 다양한 기법을 이용하면 SQL을 직접 만들어 쓰는 경우에 못지않게 성능을 향상시 킬 수 있다.&lt;/p&gt;

&lt;p&gt;ORM 을 사용하지 않고 JDBC를 이용하는 경우라면 지연된 로딩 기법을 제공하는 코드를 추가해주거나, 사용되는 필드의 종류와 사용되는 관련 오브젝트의 범위에 따라서 여러 개의 DAO 메소드를 만들어 사용해야 할 수도 있다. 이 경우 DAO 코드나 도메인 오브젝트 코드의 중복이 일부 발생하고 계층 사이의 결합도도 증가될 수는 있지 만, 데이터 중심 아키텍처에 비하면 미미한 정도다.&lt;/p&gt;

&lt;p&gt;오브젝트 중심의 아키텍처는 도메인 모델을 따르는 오브젝트를 사용해 각 계층 사이에 정보를 전달하고, 이를 이용해 비즈니스 로직이나 프레젠테이션 로직을 작성한다.&lt;/p&gt;

&lt;p&gt;계층 간의 결합도는 낮아지고 일관된 정보 모델을 사용하기 때문에 개발 생산성과 코드의 품질, 테스트 편의성도 향상시킬 수 있다. 그런데 도메인 오브젝트는 자바오브젝트다. 오브젝트는 원래 데이터를 저장하기 위해서만 사용하는 것이 아니다. 내부의 정보를 이용하는 기능도 함께 갖고 있어야 한다. 클래스는 속성(attribute)과 행위(operation) 의 조합이다. 필드와 그에 대한 접근자, 수정자만 갖고 있는 오브젝트는 반쪽짜리다. 물론 도메인 모델을 반영하는 오브젝트 구조에 정보를 담는 것만으로도 많은 장점이 있지만 이 정도에서 도메인 오브젝트의 사용을 제한할 필요는 없다. 가능하다면 이를 더 적극적으로 활용하게 만들어야 한다. 오브젝트 중심 아키텍처는 오브젝트의 활용 방법을 기준으로 다시 구분해볼 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;빈약한-도메인-오브젝트-방식&quot;&gt;빈약한 도메인 오브젝트 방식&lt;/h3&gt;

&lt;p&gt;도메인 오브젝트에 정보만 담겨 있고 정보를 활용하는 아무런 기능도 갖고 있지 않다면 이는 온전한 오브젝트라고 보기 힘들다.&lt;/p&gt;

&lt;p&gt;그래서 이런 오브젝트를 빈약한 오브젝트라고 부른다. 물론 이렇게라도 도메인 모델을 반영한 오므젝트에 정보를 담아 활용하는 편이 도메인 오브젝트를 전혀 사용하지 않는 것보다는 훨씬 낫다.&lt;/p&gt;

&lt;p&gt;계층 사이의 독립성을 확보하기 위해서는 특정 계층에 종속되지 않으면서 애플리케이션 전반에서 사용될 수 있는 정보를 담은 오브젝트가 필요하기 마련이고 그래서 이런 빈약한 도메인 오브젝트 방식도 실제로 많이 시용된다.&lt;/p&gt;

&lt;p&gt;아마도 스프링을 사용하는 개발자가 흔히 시용하는 방식이 이 빈약한 도메인 오브젝트 방식이 아닐까 싶다.&lt;/p&gt;

&lt;p&gt;스프링의 핵심 개발자들이 함께 쓴 스프링 전문 서적인 professioanl Spring-Framework 라는 책이 있다. 이 책과 함께 제공되는 스프링 애플리케이션 예제에서는 바로 이 빈약한 도메인 오브젝트 방식을 사용했다.&lt;/p&gt;

&lt;p&gt;오브젝트 자체는 복잡한 도메인 모델을 따라서 잘 만들어져 있고 이 구조를 그대로 모든 계층이 활용 하도록 하고 있기 때문에 깔끔하고 유연한 코드로 만들어져 있다.&lt;/p&gt;

&lt;p&gt;하지만 도메인 오브젝트는 데이터를 저장해두는 것 외에는 아무런 기능이 없다. 도메인 오브젝트에 넣을 수 있는 기능은 어떤 것일까? 도메인 모델을 반영해서 만들어진 도메인 오브젝트이니 그 기능이라고 하면 도메인의 비즈니스 로직이라고 볼 수 있다. 그렇다면 빈약한 도메인 오브젝트 방식에서는 비즈니스로직이 어디에 존재할까? 바로 서비스 계층이다.&lt;/p&gt;

&lt;p&gt;사실 다루는 정보의 구조가 다를 뿐이지 빈약한 도메인 오브젝트 방식은 데이터 중심 아키텍처의 거대 서비스 계층구조와 비슷하다.&lt;/p&gt;

&lt;p&gt;빈약한 도메인 오브젝트 방식도 거대 서비스 계층 방식의 하나라고 보면 된다. 그림 9-20은 빈약한 도메인 오브젝트 방식의 구조를 보여준다. 도메인 오브젝트는 3 개의 계층에는 독립적으로 존재하면서 일관된 구조의 정보를 담아서 계층 간에 전달하는 데 사용된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/bdfbf984-0adc-4bb4-b16e-4c38ff7eaf2c/Untitled.png&quot; alt=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/bdfbf984-0adc-4bb4-b16e-4c38ff7eaf2c/Untitled.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;빈약한 도메인 오브젝트 방식의 한계는 거대 서비스 계층 방식과 유사하다.&lt;/p&gt;

&lt;p&gt;비록 도메인 오브젝트라는 일관된 오브젝트를 활용하기 때문에 SQL 에 의존적인 데이터 방식보 다는 훨씬 유연하고 간결하지만, 여전히 서비스 계층의 메소드에 대부분의 비즈니스 로직이 들어 있기 때문에 로직의 재사용성이 떨어지고 중복의 문제가 발생하기 쉽다. 하지만 비즈니스 로직이 복잡하지 않다면 가장 만들기 쉽고 3계층 구조의 특정을 잘살려서 개발할 수 있는 유용한 아키텍처다.&lt;/p&gt;

&lt;h3 id=&quot;풍성한-도메인-오브젝트-방식&quot;&gt;풍성한 도메인 오브젝트 방식&lt;/h3&gt;

&lt;p&gt;풍성한 도메인 오브젝트 또는 영리한 도메인 오브젝트 방식은 빈약한 도메인 오브젝트의 단점을 극복하고 도메인 오브젝트의 객체지향적인 특정을 잘 사용할 수 있도록 개선한 것이다.&lt;/p&gt;

&lt;p&gt;어떤 비즈니스 로직은 특정 도메인 오브젝트나 그 관련 오브젝트가 가진 정보와 깊은 관계가 있다. 이런 로직을 서비스 계층의 코드가 아니라 도메인 오브젝트에 넣어주고, 서비스 계층의 비즈니스 로직에서 재사용하게 만드는것이다.&lt;/p&gt;

&lt;p&gt;앞에서 서비스 계층의 코드로 만들었던 calcTotalOfProductPrice() 는 Category라는 오브젝트와 그 관련 Product 의 정보만을 사용하는 간단한 로직이다.&lt;/p&gt;

&lt;p&gt;이것을 굳이 리스트 9-10 처럼 서비스 계층의 메소드에 별도로 만들지 않고 리스트 9-11 과 같이 Category 클래스의 메소드에 넣을 수도 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0192dfc2-cc67-4b66-8541-3eff98f6945f/Untitled.png&quot; alt=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0192dfc2-cc67-4b66-8541-3eff98f6945f/Untitled.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이렇게 도메인 오브젝트 안에 로직을 담아두면 이 로직을 서비스 계층의 메소드에 따로 만드는 경우보다 응집도가 높다.&lt;/p&gt;

&lt;p&gt;데이터와 그것을 사용하는 기능이 한곳에 모여 있기 때문이다. 만약 Category 에 대해 상품 가격을 계산히는 작업이 CategoryService외의 서비스 계층 오브젝트에서 필요하다고 해보자.&lt;/p&gt;

&lt;p&gt;그때마다 Category 오브젝 트를 파라미터로 해서 CategoryService 의 메소드를 호출하는 것은 번거롭다 . CategoryService를 사용하기 위해 Dl도 해줘야 한다. 다른 모률의 비즈니 스 로직을 작성하고 있는 개발자는 CategoryService 안에 그런 기능이 있는지 몰라서 같은 기능을 가진 코드를 스스로 만들어 쓸지 도 모른다. 현재 재고에 대한 비즈니 스 로직을 담고 있는 InventoryService가 있다고 하자.&lt;/p&gt;

&lt;p&gt;여기서 특정 카테고리의 상품에 대한 현재 가격의 합을 계산할 필요가 생겼다. 그리고 혹시 미리 만들어둔 관련 기능이 있는지 CategoryService를 뒤져보고 거기서 calcTotalOfProductPrice(Category c) 메소드를 찾았다고 하자. 그러면 이 기능을 사용하기 위해 InventoryService에 CategoryService를 DI 해줘야 한다. 그렇게 주입받은 CategoryService를 호출해서 그 메소드를 이용해야 한다. 그나마 같은 기능의 코드를 중복하지 않고 최적화해서 이미 만들어진 비즈니 스 로직을 재활용하는 것인데도 제법 번거로울 수 있다. InventoryService 클래스는 리 스트 9-12와 같이 작성된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2be13448-a480-4a42-a720-46a57475fce8/Untitled.png&quot; alt=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2be13448-a480-4a42-a720-46a57475fce8/Untitled.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이런 식으로 여러 개의 도메인 오브젝트에 대한 로직을 사용해야 동}는 복잡한 코드 라면 각 비즈니스 로직을 담고 있는 서비스 오브젝트를 DI 해서 로직을 담은 메소드를 호출해야 한다. 이미 정보를 담고 있는 오브젝트가 있지만 그 정보를 다루는 메소드는 별개의 서비스 오브젝트에 분리되어 있기 때문이다. 그런데 Category 에 대한 계산 로직을 Category 오브젝트 안에 직접 넣어뒀다면 이런 번거로운 작업이 필요 없다. 그냥 Category 오브젝트에게 직접 필요한 계산 작업을 요청하면 되는 것이다.&lt;/p&gt;

&lt;p&gt;CategoryService를 DI 할 필요도 없다. 비슷한 코드가 여기저기 비즈니스 로직에 중복돼서 나타나지도 않는다. 특정 도메인 오브젝트에 종속되는 비즈 니스 로직은 서비스 계층의 오브젝트가 아니라 도메인 오브젝트 안에 넣으면 된다. 이제 InventoryService의 코드는 불필요한 DI 없이 리스트 9-13 과 같이 간결하게 만들수 있다. 리스트 9-12와 리스트 9-13 의 코드를 비교해보고 어떤 코드가 이해하기 쉬운지한번생각해보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0c03a295-e6dd-43c3-bd2c-3826b5d035b0/Untitled.png&quot; alt=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0c03a295-e6dd-43c3-bd2c-3826b5d035b0/Untitled.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;풍성한 도메인 오브젝트 방식은 도메인 오브젝트를 사용한다는 면에서 빈약한 도메인 오브젝트 방식과 비슷하지만, 실제 작성된 코드를 살펴보면 훨씬 간결하고 객체지향적이라는 사실을 알 수 있다. 객체지향 분석과 설계를 통해 만들어진 도메인 모델의 정보를 정적인 구조뿐 아니라동적인 동작방식에도 적극 활용할수 있다.&lt;/p&gt;

&lt;p&gt;물론 도메인 오브젝트에 비즈니스 로직을 넣는다고 해서 비즈니스 로직을 담고 있던 서비스 계층 오브젝트가 필요 없어지는 건 아니다. 여전히 서비스 계층은 필요하며 중요한 역할을 하고 있다.&lt;/p&gt;

&lt;p&gt;도메인 오브젝트 안에 메소드로 들어가는 로직들은 대부분 해당 오브젝트나, 긴밀한 연관관계를 맺고 있는 관련 오브젝트의 정보와 기능만을 활용한다.&lt;/p&gt;

&lt;p&gt;여러 종류의 도메인 오브젝트의 기능을 조합해서 복잡한 비즈니스 로직을 만들었다면 특정 도메인 오브젝트에 넣기는 힘들다. 이런 비즈니스 로직은 서비스 계층의 오브 젝트에 두는 것이 적당하다. 도메인 오브젝트는 직접 데이터 액세스 계층이나 기반 계층 또는 다른 서비스 계층의 오브젝트에 접근할 수 없기 때문에 서비스 계층이 필요하기도 하다. 대개는 비즈니스 로직을 처리하는 중에 DB 에 담긴 정보를 가져와서 활용하거 나 결과를 다시 DB나 외부 시스템에 전송히는 등의 작업이 필요하다.&lt;/p&gt;

&lt;p&gt;그러려면 서비스 계층의 오브젝트와 같이 DAO 오브젝트를 DI 받아서 사용할 수 있어야 한다. 하지만 도메인 오브젝트는 그럴수없다. 왜 도메인 오브젝트는 DAO 오브젝트를 DI 받을 수 없을까? 그것은 도메인 오브젝트는 스프링 컨테이너가 관리히는 오브젝트, 즉 빈이 아니기 때문이다.&lt;/p&gt;

&lt;p&gt;서비스 계층의 오브젝트나 데이터 액세스 계층의 오브젝트는 모두 스프링의 빈으로 등록되기 때문에 필요에 따라 서로 DI 할 수 있다.&lt;/p&gt;

&lt;p&gt;DI를 받으려면 자신도 역시 스프링 컨테이너에서 관리되는 빈이어야 한다. 그런데 도메인 오브젝트는 스프링의 빈이 아니다.&lt;/p&gt;

&lt;p&gt;도메인 오브 젝트는 애플리케이션의 코드 또는 기타 프레임워크나 라이브러리, JDBC 템플릿 등에 의해 필요할 때마다 새롭게 만들어진다.&lt;/p&gt;

&lt;p&gt;따라서 스프링이 생성하거나 관리하는 오브젝트가 아니므로 DJ 를 받을 수 없다. 결국 이런 도메인 오브젝트는 DAO 나 서비스 오브젝트 같은 스프링의 빈의 기능을 사용할 수 없다.&lt;/p&gt;

&lt;p&gt;그래서 수식 계산이나 조건에 따른 데이터의 변경 또는 자신이 가진 정보에 대한 분석 같은 도메인 오브젝트 자신에 국한된 로직은 도메인 오브젝트 안에 추가할 수 있지 만, 그 결과를 DB 에 저장하거나 메일로 발송하거나 DB를 검색해서 원하는 정보를 가져와 활용히는 작업은 도메인 오브젝트에서 불기능하다. 그래서 DAO와 기반계층 오브 젝트를 DJ 받아사용할수 있는 서비스 계층의 코드가 펼요하다. 서비스 계층은 도메인 오브젝트를 DB나 외부 리소스에서 가져오고 변경된 정보나 새로 등록된 정보를 DB 에 반영히는 등의 작업과 함께 도메인 오브젝트가 갖고 있는 기능이 있다면 이를 활용해서 비즈니스 로직을 처리해야 한다.&lt;/p&gt;

&lt;p&gt;그림 9-21 은 풍성한 도메인 오브젝트 방식의 아커텍처를 나타낸다. 스프링의 빈으로 관리되는 3 계층의 오브젝트들은 도메인 오브젝트를 자유롭게 이용할 수 있지만 그 반대는 안 된다는 사실을 주의해야 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/95782490-05e1-491d-91fb-c6f418dbf4c3/Untitled.png&quot; alt=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/95782490-05e1-491d-91fb-c6f418dbf4c3/Untitled.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;풍성한 도메인 오브젝트 방식은 빈약한 도메인 오브젝트 방식보다 서비스 계층의 코드가 간결하다. 비즈니스 로직 코드를 이해하기도 쉽다. 따라서 빈약한 도메인 오브젝트를 피하고 도메인 오브젝트가 스스로 처리 가능한 기능과 도메인 비즈니스 로직을 갖도록 만드는것이 바람직하다.&lt;/p&gt;

&lt;p&gt;물론 빈약한 도메인 오브젝트 방식이 항상 나쁘고 피해야 할 것은 아니다. 도메인 모델링과 기능 분석을 통해 이상적인 도메인 오브젝트 설계를 하고 사전에 내부기능을 충분히 구현해두지 않았다면,&lt;/p&gt;

&lt;p&gt;도메인 오브젝트를 활용해서 비즈니스 로직을 구현해야 하는 개발자는 혼란을느낄 수 있다. 어떤 경우는도메인 오브젝트에 이미 구현된 코드가 있는데도 이를 이용하지 못하고 서비스 계층에 비슷한 기능을 중복해서 만들 수도 있고, 도메인 오브젝트의 코드를 일부 서비스 계층의 개발자가 임의로 변경해서 같은 오브젝트를 사용하는 다른 모률의 작업자가 만든 코드가 제대로 동작하지 못하게 되기 도한다.&lt;/p&gt;

&lt;p&gt;그래서 충실한 도메인 모댈링과 도메인 오브젝트 개발이 선행되고 그 내용이 개발자에게 사전에 충분히 공유되지 않았다면 차라리 데이터 구조만 오브젝트 방식으로 정의 해놓은 빈약한 도메인 오브젝트 방식이 혼란을 피할 수 있고 쉽게 접근할 수 있는 대안이 될 수도 있다.&lt;/p&gt;

&lt;p&gt;하지만 처음은 쉬워도 시간이 지나고 시스템이 복잡해지면 빈약한 도메인 오브젝트 방식의 단점이 드러날 것은 각오해야 한다.&lt;/p&gt;

&lt;h3 id=&quot;도메인계층방식&quot;&gt;도메인계층방식&lt;/h3&gt;

&lt;p&gt;지금까지 살펴본 바로는 도메인 모댈을 따르는 오브젝트를 만들고 이를 활용하는 방법에는 한계가 있다. 도메인 오브젝트에 담을 수 있는 비즈니스 로직은 데이터 액세스 계층에서 가져온 내부 데이터를 분석하거나 조건에 따라 오브젝트 정보를 변경, 생성 하는 정도에 그칠 수 밖에 없다.&lt;/p&gt;

&lt;p&gt;이렇게 변경된 정보가 다시 DB 등에 반영되려면 서비스 계층 오브젝트의 부가적인 작업이 필요하다. 도메인 오브젝트가 스스로 필요한 정보는 DAO를 통해 가져올 수 있고, 생성이나 변경이 일어났을 때 직접 DAO 에게 변경사항을 반영해달라고 요청할 수는 없을까?&lt;/p&gt;

&lt;p&gt;DAO 외에도 다양한 기반계층의 서비스를 이용하도록 할 방법은 없을까? 만약 도메인 오브젝트가 기존 3계층의 오브젝트를 DI 받아서 직접 이용할 수 있게 된다면 어떤 일이 일어날까?&lt;/p&gt;

&lt;p&gt;도메인 계층의 역할과 비중을 극대화하려다 보면 기존의 풍성한 도메인 오브젝트 방식으로는 만족할 수 없다.&lt;/p&gt;

&lt;p&gt;그래서 등장한 것이 바로 도메인 오브젝트가 기존 3계층과 같은 레벨로 격상되어 하나의 계층을 이루게 하는 도메인 계층 방식이다.&lt;/p&gt;

&lt;p&gt;개념은 간단하다. 도메인 오브젝트들이 하나의 독립적인 계층을 이뤄서 서비스 계층과 데이터 액세스 계층의 사이에 존재하게 히는 것이다. 도메인 오브젝트가 독립된 계층을 이뤘기 때문에 기존 방식과는 다른 두 가지 특징을 갖게된다.&lt;/p&gt;

&lt;p&gt;첫째는 도메인에 종속적인 비즈니스 로직의 처리는 서비 스 계층이 아니라 도메인 계층의 오브젝트 안에서 진행된다는 점이다. 서비스 계층에서 사용자가 입력한 정보를 바탕으로 새로운 도메인 오브젝트를 만들었든 데이터 액세스 계층을 통해 도메인 오브젝트를 가져왔든 상관없이 도메인 오브젝트에게 비즈니스 로직의 처리를 요청할 수 있다.&lt;/p&gt;

&lt;p&gt;해당 도메인 오브젝트를 중심으로 만들어진 로직이라면 그 이후의 작업은 도메인 오브 젝트와 그 관련 오브젝트 사이에서 진행된다. 일단 도메인 계층으로 들어가면 서비스 계층의 도움 없이도 비즈니스 로직의 대부분의 작업을 수행할 수 있다는 뜻이다.&lt;/p&gt;

&lt;p&gt;두 번째 특징은 도메인 오브젝트가 기존 데이터 액세스 계층이나 기반 계층의 기능을 직접 활용할 수 있다는 것이다. 그런데 앞에서 도메인 오브젝트는 스프링에 등록돼서 싱글톤으로 관리되는 빈이 아니기 때문에 다른 빈을 DI 받을 수 없다고 했다. 그렇다면 도메인 계층의 도메인 오브젝트들은 어떻게 다른 빈을 이용할수 있을까?&lt;/p&gt;

&lt;p&gt;물론방법은 DI 다. 여전히 도메인 오브젝트는 스프링이 직접 만들고 관리히는 오브젝트 즉 빈이 아니다. 하지만 이런 스프링이 관리하지 않는오브젝트에도 DI를 적용할수 있다. 물론 그에 따른 간단한 설정이 추가돼야 한다.&lt;/p&gt;

&lt;p&gt;스프링이 관리하지 않는 도메인 오브젝트에 DI를 적용하기 위해서는 AOP 가 필요하다. 물론 스프링 AOP는 부가기능을 추가할 수 있는 위치가 메소드 호출 과정으로 한정되고 AOP의 적용 대상도 스프링의 빈 오브젝트뿐이다.&lt;/p&gt;

&lt;p&gt;하지만 스프링 AOP 대신 AspectJ AOP를 사용하면 클래스의 생성자가 호출되면서 오브젝트가 만들어지는 시점을 조인 포인트로 사용할 수 있고 스프링 빈이 아닌 일반 오브젝트에도 AOP 부가기능을 적용할 수 있다.&lt;/p&gt;

&lt;p&gt;이를 이용해서 도메인 오브젝트가 생성되는 시점에 특별한 부가기능을 추가하게 만들어줄 수 있다. 이 부가기능은 오브젝트의 수정자 메소드나 DI용 애노태이션을 참고해서 DI 가능한 대상을 스프링 컨테이너에서 찾아 DI 해주는 기능이다. 스프링이 직접 관리하지 않는 오브젝트에 대한 DI서비스가 일종의 AOP 부가기능 으로 도메인 오브젝트에 적용될 수 있다.&lt;/p&gt;

&lt;p&gt;이 방법을 이용하면 도메인 오브젝트가 만들어질 때 스프링의 빈 오브젝트를 DI 받게 할 수 있다. 결국 도메인 오브젝트가 데이터 액세스 계층이나 기반 계층의 오브젝트를 이용하도록 만들 수 있다. 이 덕분에 도메인 오브젝트 기능의 제약이 사라진다. 물론 도메인 오브젝트에 담긴 기능은 자신과 관련 오브젝트에 대한 작업으로 한정돼야 한다.&lt;/p&gt;

&lt;p&gt;도메인 계층 방식은 이전의 어떤 방식보다 도메인 오브젝트에 많은 비즈니스 로직을 담아낼 수 있다. 그럼에도 서비스 계층의 역할이 완전히 사라지는 건 아니다. 때로는 여러 도메인 오브젝트의 기능을 조합해서 복잡한 작업을 진행해야 하는 경우가 있다. 특정 도메인 오브젝트에 담길 수 없는 이런 작업은 서비스 계층에서 도메인 계층과 협력을 통해 진행히는 것이 바람직하다.&lt;/p&gt;

&lt;p&gt;또는 굳이 도메인 계층을 거치지 않고 바로 데이터 액세스 계층으로부터 정보를 가져와 클라이언트에 제공해야 하는 경우도 있다. 이럴 때도 서비스 계층이 인터페이스 역할을 담당한다.&lt;/p&gt;

&lt;p&gt;또 트랜잭션 경계를 설정하거나 특정 도메인 로직에 포함되지는 않지만 애플리케이션에서 필요로 히는 기반 서비스를 이용 해야 하는 작업을 위해서라도 서비스 계층은 필요하다.&lt;/p&gt;

&lt;p&gt;대신 서비스 계층의 비중과 규모는단순히 도메인 오브젝트를사용하는 방식에 비해 훨씬 작다. 복잡하지 않은 애플리케이션에서는 아예 서비스 계층을 제거하고 모든 비즈니스 로직을 도메인 오브젝트에 담을 수도 있다.&lt;/p&gt;

&lt;p&gt;이때는 트랜잭션 경계가 프레젠태이션 계층에서 최초로 호출되는 도메인 오브젝트의 메소드에 설정돼야 한다. 도메인 오브젝트를 독립적인 계층으로 만들려고 할 때 고려해야 할 중요한 사항이 있다. 도메인 오브젝트가 도메인 계층을 벗어나서도 사용되게 할지 말지 결정해야 한다. 도메인 오브젝트가 계층을 이루기 전에는 모든 계층에 걸쳐 사용되는 일종의 정보 전달 도구 같은 역할을 했다. 하지만 독자적인 계층을 이뤘을 때는 상황이 달라질 수있다. 선택할 수 있는 방법은 두 가지가 있다.&lt;/p&gt;

&lt;p&gt;첫째, 여전히 모든 계층에서 도메인 오브젝트를 사용한다. 도메인 계층은 물론이고 서비스 계층이나 그 앞의 프레젠테이션 계층 화면 출력을 위한 뷰에서도 직접 도메인 오브젝트를 전달받아 사용할 수 있게 하는 것이다. 가장 손쉽고 펀한 방법이다. 도메인 오브젝트를 이용해 도메인 로직을 적용하면 도메인 계층에서 진행되지만, 그 결과를 DB 에 반영할 때나 화면에 출력하거나 페이지 이동을 위한 정보로 활용하기 위해 프레젠테이션 계층에서 참조할 때도 도메인 오브젝트를 사용할 수 있다. 따라서 도메인 모델을 따르는 오브젝트 구조를 활용하는 면에서 오브젝트 중심 아키텍처의 장점을 그대 로누릴수있다. 하지만 주의하지 않으면 심각한 혼란을 초래할 수 있다. 도메인 오브젝트의 메소드는 이제 단순한 값의 조작이나 분석 변환 정도가 아니라 중요한 도메인/비즈니스 로직을 담당하고 있다. 심지어 DB 나 백엔드 시스템에 작업 결과를 반영할 수도 있다. 그런데 이런 막강한 기능을 가진 도메인 오브젝트를 프레젠테이션 계층이나 뷰 등에서 사용하게 해주면 이를 함부로 사용하는 위험이 뒤따를 수 있다. JSP로 뷰를 만드는 개발 자가 도메인 오브젝트가 담은 정보를 가져와 화면을 출력하는 데만 사용하는 것이 아니라, 중요한 비즈니스 로직을 담은 메소드를 함부로 호출한다면 심각한 문제가 일어날 수도 있다. 오브젝트를 넘겨받은 이상 그것을 사용히는 데 제약이 없기 때문에 함부로 조작하거나 기능을 실행해버릴 위험이 있다.&lt;/p&gt;

&lt;p&gt;이런 문제를 피하려면 어떻게 해야 할까? 가장 간단한 방법은 철저한 개발 가이드라인을 만들어두고 이를 강력하게 적용하는 것이다.&lt;/p&gt;

&lt;p&gt;예를 들어 프레젠테이션 계층에서는 도메인 오브젝트를 전달받는 접근자를 사용해서 정보를 가져오는 경우와 폼의 결과를 반영할 새로운 도메인 오브젝트를 만들어 수정자를 호출히는 경우 외에는 다른 메소드를 사용하지 않는다는 개발 정책을 만들어두는 것이다.&lt;/p&gt;

&lt;p&gt;문제는 이런 규정을 어기는 개발자가 있다는 점인데 이런 문제는 코딩 정책의 적용을 분석할 수 있는 툴을 이용해 검증하거나 AspectJ의 정책/표준 제화기능을 사용하면 된다. AspectJ를 이용한 방법은 상당히 편리하다. 간단한 포인트컷 표현식만으로 특정 계층의 오브젝트가 사용할 수 있는 메소드의 범위를 제한 히는 등의 정책 강제화 작업을 간단하게 해낼 수 있다. 이 방법에 대해서는 AspectJ 문서나  AspectJ In ActionJ 책을 참조하자.&lt;/p&gt;

&lt;p&gt;두 번째 방법은 도메인 오브젝트는 도메인 계층을 벗어나지 못하게 하는 것이다. 도메인 계층 밖으로 전달될 때는 별도로 준비된 정보 전달용 오브젝트에 도메인 오브젝트의 내용을 복사해서 넘겨줘야 한다. 이런 오브젝트는 데이터 전달을 위해 사용된다고 해서 DTO(Data Transfer Object) 라고 불린다. DTO는 상태의 변화를 허용하지 않고 읽기전용으로 만들어지기도 한다. 반대로 사용자가 등록한 값이나 외부 시스댐으로부터 전달 받은 정보를 도메인 계층으로 전달히는 경우에도 DTO를 이용할 수 있다.&lt;/p&gt;

&lt;p&gt;DTO는 기능을 갖지 않으므로 사용하기 안전하다. 또 도메인 오브젝트를 외부 계층의 코드로부터 보호해준다. 반면에 도메인 오브젝트와 비슷한 구조를 가진 오브젝트를 따로 만들어야 하고 이를 매번 변환해줘야 하는 번거로움이 있다. 따라서 AOP와 같은 방법을 이용해 변환을 자동으로 해주도록 만들 필요가 있다. 이 두 가지 방법 중 어느 것이 더 낫다고 말하기는 힘들다. 기존에 DTO를 이용한 개발에 익숙해져 있다면 후자의 방법도 괜찮을 것이다. 번거로운 작업은 최소화하고 싶고 대신 표준 개발 정책을 잘 따라서 개발하도록 개발팀을 관리할 수 있다면 전자의 방법이 편리하다. 그림 9-22는 도메인 계층 방식의 구조다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a455d482-b42a-4769-94c7-2a6389a622b7/Untitled.png&quot; alt=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a455d482-b42a-4769-94c7-2a6389a622b7/Untitled.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;도메인 계층은 기존 3 계층과 비슷한 수준에서 독립적인 역할을 담당하고 있긴 하지만그 특성은 확연히 다르다.&lt;/p&gt;

&lt;p&gt;서비스를 제공히는 싱글톤으로 계속 존재하는 다른 계층의 오브젝트와 달리, 도메인 계층의 오브젝트는 매우 짧은 시간 동안만 존재했다가 사라지는 것을 반복한다.&lt;/p&gt;

&lt;p&gt;각 사용자의 요청별로 독립적으로 도메인 계층을 이루는 오브젝트들이 생성됐다가 해당 요청 을 처리하고 나면 버려진다. 때론 하나의 복잡한 작업 흐름을 따라서 오래 존재하는 경우도 있지만 여전히 그 생명주기는 짧다.&lt;/p&gt;

&lt;p&gt;도메인 오브젝트는 사용자별 요청에 대해 독립적인 상태를 유지하고 있어야 하기 때문이다. 상태정보를 담고 있기 때문에 여러 스레드가 공유히는 싱글톤이 될 수가 없다.  또 DAO나 컨트롤러, 또는 스프링 외의 라이브러리를 통해 오브젝트가 만들어지는 경우가 많기 때문에 스프링이 관리하는 빈으로 등록조차 불가능하다.&lt;/p&gt;

&lt;p&gt;그렇기 때문에 특별한 방법으로 DI를 해줘야지만 다른 3계층의 빈들과 협력해서 일을 처리할수있다.&lt;/p&gt;

&lt;p&gt;이런 여러 가지 제약과 불편을 감수하면서라도 이 방식을 택해야 하는 경우는 매우 복잡하고 변경이 잦은 도메인을 가졌을 때다.&lt;/p&gt;

&lt;p&gt;복잡한 도메인의 구조와 로직을 최대한 도메인 계층의 오브젝트에 반영하고, 도메인 모벨과 설계에 변경이 발생했을 때 도메인 계층의 오브젝트도 빠르게 대응해서 변경해주기 위해서다. 도메인 계층은 응집도가 매우 높기 때문에 단위 테스트를 작성하기가 편리하다.&lt;/p&gt;

&lt;p&gt;DAO나 외부서비스 오브젝트와 연동할 때도 도메인 오브젝트 타입을 유지할 수 있기 때문에 목 오브젝트 등을 이용해 단위 테스트로 만들기도 쉽다. 도메인이 가진 복잡함을 객체지향적인 설계의 모든 장점을 동원해서 가장 유연한 방법으로 대응할 수 있다.&lt;/p&gt;

&lt;p&gt;반면에 그만큼 복잡하지 않은 애플리케이션이라면 이런 방식을 선택하는 것 자체가 오히려 과도한 부담을 줄 수도 있다.&lt;/p&gt;

&lt;p&gt;따라서 도메인 계층을 이용히는 방식을 선택할 때는 오브젝트 중심 아키텍처의 기본 두 가지 방법을 충분히 경험해보고 오브젝트 중심의 개발 방식에 익숙해진 뒤에 조심스럽게 접근해야 한다.&lt;/p&gt;

&lt;p&gt;AspectJ AOP를 이용해 도메인 오브젝트에 DI를 적용하는 방법은 Vol. 2 의 5장을 참고하기바란다.&lt;/p&gt;

&lt;h3 id=&quot;dto와-리포트쿼리&quot;&gt;DTO와 리포트쿼리&lt;/h3&gt;

&lt;p&gt;오브젝트 중심 아키텍처는 애플리케이션 내의 모든 정보를 항상 도메인 오브젝트에 담고 다녀야 할까? 꼭 그렇지는 않다. 도메인 계층 방식의 경우 도메인 계층을 벗어난 정보를 DTO 라 불리는 특정 계층에 종속되지 않는 정보 전달의 목적을 가진 단순 오브젝트에 담아 샤용하기도 한다. 그 외의 방법에서도 DTO 의 사용이 꼭 필요할 때가 있다. 대표적인 예는 리포트 쿼리라고 불리는 DB 쿼리의 실행 결과를 담는 경우다. 리포트 쿼리는 리포트를 출력하기 위해 생성하는 쿼리라는 의미인데, 단지 리포트를 위해서라기보다는 보통 종합 분석 리포트처럼 여러 테이블에 걸쳐 존재하는 자료를 분석하고 그에 따른 분석/통계 결괴를 생성하는 쿼리라는 의미다.&lt;/p&gt;

&lt;p&gt;이런 쿼리의 결과는 DB 테이블에 담긴 필드의 내용보다는 그 합계, 평균과 같은 계산 값이거나 아니면 여러 테이블의 필드를 다양한 방식으로 조합해서 만들어진다. 따라서 DB 쿼리의 실행 결과를 담을 만한 적절한 도메인 오브젝트를 찾을 수 없다. 그래서 이런 리포트 쿼리의 결과는 DTO 라고 불리는 단순한 자바빈이나 아니면 키와 값 쌍을 갖는 맵에 담아서 전달 해야한다.&lt;/p&gt;

&lt;p&gt;때론 DB 의 쿼리 하나로 최종 결과를 만들어내기 힘들기 때문에 코드를 통해 데이터를 분석하고 가공히는 작업이 필요하다. 이런 경우에도 최종 결괴는 DTO나 맵， 컬렉션에 담겨서 전달돼야한다. 때론 웹 서비스 등의 시스템과 자료를 주고받을 때 전송 규약에 맞춰서 도메인 오브 젝트에 담긴 정보를 가공해야 할 때가 있다. 이런 경우도 DTO나 맵을 이용해 해당 형식에 맞도록 변경히는 작업이 필요하다.&lt;/p&gt;

&lt;h2 id=&quot;934-스프링-애플리케이션을-위한-아키텍처-설계&quot;&gt;9.3.4 스프링 애플리케이션을 위한 아키텍처 설계&lt;/h2&gt;

&lt;p&gt;지금까지 3단계로 역할을 분리하는 계충형 아키텍처와 정보를 다루는 방법에 따른 아키 텍처의 종류를 알아봤다. 그 외에도 다양한 기술 조합과 업무조건, 시스템 환경에 따른 많은 결정요소와 변수가 있다.&lt;/p&gt;

&lt;p&gt;그중에서 계층구조를 어떻게 나눌 것인가와 애플리케이션 정보를 어떻게 다룰지를 결정하는 것이 기본이 된다.&lt;/p&gt;

&lt;p&gt;그리고 그 위에 각 계층에 사용될 구체적인 기술의 종류와 수직 추상화 계층의 도입 세세한 기술적인 조건을 결정하는 일이 남았다.&lt;/p&gt;

&lt;h3 id=&quot;계층형아키텍처&quot;&gt;계층형아키텍처&lt;/h3&gt;

&lt;p&gt;3계층 구조는 스프링을 사용하는 엔터프라이즈 애플리케이션에서 가장 많이 사용되는 구조다. 스프링의 주요 모듈과 기술을 살펴보면 3계층 구조에 적합하도록 설계되어 있다는 사실만 봐도 알 수 있다.&lt;/p&gt;

&lt;p&gt;단 3계층이라는 것은 논리적이고 개념적인 구분이지 쪽오브젝트 단위로 딱 끊어져서 만들어지는 게 아님을 염두에 둬야 한다. 때로는 하나의 계층이 다시 수평으로 세분화될 수도 있다. 반대로 3 계층에서 두 개의 계층이 통합돼서 하나의 오브젝트에 담기는 일도 얼마든지 가능하다.&lt;/p&gt;

&lt;p&gt;예를들어 서비스 계층을굳이 도입하지 않아도 될 만큼 비즈니스 로직이 단순한 애플리케이션이라면 서비스 계층과 데이터 액세스 계층을 통합할 수도 있다. 스프링의 데이터 액세스 기술을 사용하면 복잡하고 지저분하게 반복되는 코드가 대부분 제거되고 핵심 데이터 액세스 로직만 남은 간략한 코드를 가진 DAO를 만들 수 있다. 정보의 등록， 조회， 수정 삭제에 간단한 조건을 이용한 검색만으로 대부분의 기능을 수행할 수 있는 복잡하지 않은 애플리케이션이라면 서비스 계층을 데이터 액세스 계층에 통합히는 것도 나쁘지 않다.&lt;/p&gt;

&lt;p&gt;이때는 트랜잭션 경계설정 위치를 DAO 메소드로 삼으면 된다. 간략한 로직은 DAO 코드에 넣어도 좋다. 반대로 프레젠태이션 계층에 서비스 계층을 통합히는 방법도 가능하다.DAO는 순수한 DB 인터페이스 역할을 하는 데이터 액세스 기능만 갖게 하고 조건에 따른 간단한 로직의 적용은 프레젠테이션 계층의 컨트롤러에 넣는 것이다. 이 방법이 불기능하진 않지만 스프링에서는 그리 권장되지 않는다. 스프링 AOP를 이용해 트랜잭션의 경계를 설정하기가 애매하기 때문이다.&lt;/p&gt;

&lt;p&gt;DAO 가 트랜잭션 경계가 되는 경우에는 트랜잭션 전파 기법을 이용해 여러 개의 DAO 처리를 하나의 트랜잭션으로 조합해서 간단히 묶을수 있다.&lt;/p&gt;

&lt;p&gt;반면에 프레젠테이션 계층의 오브젝트는 트랙잭션 단위로 삼기에는 너무 크고 트랜잭션 전파를 통해 조합하기가 애매하다.&lt;/p&gt;

&lt;p&gt;그래서 굳이 이런 방식을 써야 한다면 TransactionTemplate을 이용해 코드에 의한 트랜잭션 경계설정을 해야 하는데 이는 너무번거롭다.&lt;/p&gt;

&lt;p&gt;따라서 3계층을 단순화해서 2계층으로 만든다면 서비스 계층과 데이터 액세스 계층을 통합하는 편이 낫다.&lt;/p&gt;

&lt;p&gt;물론 이때도 논리적으로는 서비스 계층과 데이터 액세스 계층의 경계를 분명하게 하는 게 좋다. 같은 오브젝트에 담겨 있다고 할지라도 비즈니스 로직을 적용한다면 각각 독립적으로 메소드를 분리해두는 것이 바람직하다.&lt;/p&gt;

&lt;p&gt;프레젠테이션 계층은 보통 MVC 라는 이름으로 잘 알려진 패턴 또는 아키텍처를 주로 사용한다. 스프링의 대표적인 프레젠태이션 기술도 SpringMVC 라는 이름을 갖고 있고, 이름처럼 MVC 패턴을지원하게 되어 있다.&lt;/p&gt;

&lt;p&gt;SpringMVC를다루는 Vol.2 의 3 장과 4장에서 자세히 살펴보겠지만, 스프링은 이 MVC 중 가장 부담을 많이 지고 있는 컨트롤러(C) 에 해당하는 부분을 또 다시 세분화해서 여러 단계의 오브젝트로 만들 수 있도록 설계되어 있다.&lt;/p&gt;

&lt;p&gt;이런 식으로 계층 내의 역할을 좀 더 세분화히는 경우도 있다. 프레젠태이션 계층은 특히 그 경계를 애플리케이션이 배치된 서버를 떠나서 클라이언트까지 확장하기도 한다.&lt;/p&gt;

&lt;p&gt;SOFEA (Service Oriented Front End Architecture)라고 불리는 아키텍처는 프레젠테이션 계층의 코드가 서버에서 클라이언트로 다운로드돼서 클라이언트 장치안에서 동작하면서 서버에 존재하는 서비스 계층 또는 부분 프레젠태이션 계층과 통신하는 구조로 만들어진다. 브라우저 안에서 동작하는 자바스크립트나 플래시 기반의 애플리케이션을 포함해서 JVM 나 클라이언트 OS 에서 독립적으로 동작하는 기술도 계속 발전하고 있다. 이때는 프레젠테이션 계층이 가졌던 사용자와의 인터페이스， 화면 흐름에 대한 제어, 서비스 계층과의 통신, 상태정보의 유지 등을 클라이언트에 다운로드된 코드에서 대부분 담당하게 된다. 그림 9-2 에 나와 있는 SOFEA는 전통적인 MVC 기반의 모델2 아키텍처의 위치를 위협할 만큼 빠르게 성장하고 있다. 스프링 또한 이런 기술의 변화에 맞춰서 다양한 지원을 늘리고 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5ea4e7cc-2ee6-4ccf-b370-197286e412eb/Untitled.png&quot; alt=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5ea4e7cc-2ee6-4ccf-b370-197286e412eb/Untitled.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;스프링을 처음 학습하고 도입히는 입장이라면 일단은 가장 전통적인 서버 기반의 3계층 구조에 먼저 익숙해지는 것이 좋다. 프레젠테이션 계층은 SpringMVC를 이용하고 서비스 계층은 POJO로 구현하면서 트랜잭션 AOP를 적용하고, 데이터 액세스 계층은 JDBC를 비롯해서 스프링의 데이터 액세스 전략이 적용된 JPA. 하이버네이트. JDO 등을 활용하도록 돕는 것이다. 처음에는 이 3계층 방식의 아키텍처 위에서 스프링의 철학과 가치를 따라서 코드를 만드는 데 익숙해진 디음 차차 다양한 방식으로 계층구조의 통합과 분산을 시도해보자.&lt;/p&gt;

&lt;h3 id=&quot;정보전송-아키텍처&quot;&gt;정보전송 아키텍처&lt;/h3&gt;

&lt;p&gt;스프링의 기본 기술에 가장 잘 들어맞고 쉽게 적용해볼 수 있는 것은 오브젝트 중심 아키텍처의 도메인 오브젝트 방식이다. 일단은 빈약한 도메인 오브젝트 방식으로 시작하는 게 가장 쉽다. 도메인 오브젝트를 계층 간의 정보 전송을 위해 사용하고， 이를 각 계층의 코드에서 활용한다. DAO는 그 기술이 어떤 것이든 상관없이 서비스 계층에서 요청을 받거나 결과를 돌려줄 때 도메인 오브젝트 형태를 유지하게 만든다. 서비스 계층의 비즈니스 로직 또한 도메인 오브젝트를 이용해 작성한다. 가능하다면 도메인 오브젝트에 단순한 기능이라도 추가하도록 노력해보는 것이 좋다.&lt;/p&gt;

&lt;p&gt;프레젠테이션 계층에서도 이 도메인 오브젝트를 직접 활용하도록 만든다. 프레젠테이션 계층의 MVC 아키텍처 에서도 모델은 도메인 오브젝트를 그대로 사용한다. 뷰에 전달하는 정보도 물론 도메인 오브젝트를 사용하는 모델이고, 사용자가 입력하는 폼의 정보도 도메인 오브젝트로 변환해서 사용한다. 이렇게 도메인 오브젝트를 사용해 애플리케이션의 정보를 일관된 형태로 유지하는게 스프링에 가장 잘 들어맞는 방식이다. 스프링에 포함된 예제나, 스프링 개발자들이 저술한 책에 나오는 샘플 애플리케이션 그리고 스프링의 각 기술의 API 사용 방법을 살펴보면 거의 대부분이 방식을사용하고 있다.&lt;/p&gt;

&lt;p&gt;DB와 SQL 에 많은 비즈니스 로직을 담고 있는 레거시 시스템을 스프링으로 전환하는 경우라면, 일단 데이터 중심의 아키텍처를 시용해도 무방하다.&lt;/p&gt;

&lt;p&gt;3계층의 기본 구조로 잘 분리할 수만 있다면 DB 중심의 접근 방법을 사용해서 기존에 만들어 사용해봤던 SQL을 재사용한다.&lt;/p&gt;

&lt;p&gt;그리고 전환 작업을 마치고 검증이 끝난 후에 단계적으로 로직을 DB 에서 애플리케이션으로 가져오고, 오브젝트 중심으로 전환하는 시도를 하면 된다. 레거시 시스템의 기능은 가져오되 구현은 새롭게 처음부터 시작할 수 있다면 스프링의 철학과 개념에 가장 잘 들어맞는 도메인 오브젝트 중심의 아키텍처에 도전해보는 편이 나을것이다.&lt;/p&gt;

&lt;p&gt;객체지향적인 도메인 분석과 모델링에 자신이 있고 도메인 오브젝트 설계와 구현, 독립적인 태 스트를 자유롭게 적용할 수 있다면 과감하게 도메인 계층 방식을 도입할수도 있다. 다만 도메인 계층에 DI 를 적용하기 위해 스프링의 고급 기술을 활용해야 하고 여러 가지 고려할 점이 많으므로 충분한 사전 학습과 검증이 먼저 진행돼야 한다.&lt;/p&gt;

&lt;h3 id=&quot;상태관리와-빈-스코프&quot;&gt;상태관리와 빈 스코프&lt;/h3&gt;

&lt;p&gt;아키텍처 설계에서 한 가지 더 신경 써야 할 사항은 상태 관리다. 크게는 사용자 로그인 세션 관리부터, 작게는 하나의 단위 작업이지만 여러 페이지에 걸쳐 진행되는 위저드 기능까지 애플리케이션은 하나의 HTTP 요청의 범위를 넘어서 유지해야 하는 상태정보 가있다. 엔터프라이즈 애플리케이션은 특정 사용자가 독점해서 배타적으로 사용되지 않는 다. 하나의 애플리케이션이 동시에 수많은 사용자의 요청을 처리하게 하기 위해 매번 간단한 요청을 받아서 그 결과를 돌려주는 방식으로 동작한다. 따라서 서버의 자원이 특정 사용자에게 일정하게 할당되지 않는다. 그래서 서버 기반의 애플리케이션은 원래 지속적으로 유지되는 상태를 갖지 않는다는 특정이 있다. 클라이언트로부터의 요청을 처리히는 매우 짧은 시간 동안만 도메인 오브젝트와 같은 정보저장소에 현재 상태정보가 보관되지만, 이는 요청 결과를 클라이언트에 돌려주고 나면 바로 폐기된다.&lt;/p&gt;

&lt;p&gt;그 덕분에 수많은 동시 사용자의 요청을 제한된 서버리소스를 가지고 처리할 수 있다. 하지만 어떤 식으로든 애플리케이션의 상태와 장시간 진행되는 작업정보는 유지돼야 한다. 이를 위해서 웹 클라이언트에 URL, 파리미터, 폼 히든 필드, 쿠키 등을 이용해 상태정보 또는 서버에 저장된 상태정보에 키 값 등을 전달해야 한다.&lt;/p&gt;

&lt;p&gt;클라이언트와 서버 사이에서 많은 양의 정보를 계속해서 주고받을 수는 없으므로 중요한 상태정보는 파일 시스템, 데이터그리드 DB 등에 저장되기도 한다.&lt;/p&gt;

&lt;p&gt;또는 제약이 있기는 하지만 HTTP 세션과 같은 서블릿 컨테이너가 제공하는 저장공간을 활용하기도 한다. 이렇게 상태를 저장， 유지하는 데 어떤 방식을 시용할지 결정히는 일은 매우 중요하다.&lt;/p&gt;

&lt;p&gt;스프링은 기본적으로 상태가 유지되지 않는 빈과 오브젝트를 사용하는 것을 권장한다. 웹의 생리에 가장 잘 들어맞고 개발하기 쉽기 때문이다. 또, 서버를 여러 대로확장 하기가 매우 쉽다.&lt;/p&gt;

&lt;p&gt;반면에 웹 클라이언트에 폼 정보를 출력하고 이를 수정하는 등의 작업을 위해서는 HTTP 세션을 적극 활용하기도 한다.&lt;/p&gt;

&lt;p&gt;대부분의 폼 등록, 수정 작업은 한 페이지짜리 폼이라도 여러 번의 HTTP 요청에 걸쳐 일어나기 때문에 작업 중인 폼의 내용을 짧은 동안에라도 서버에 저장해둘 필요가 있다. 상태는 클라이언트, 백엔드에 저장해두거나 서블릿의 HTTP 세션 정도에 일시적으로 저장해두는 것이 대부분이지만 경우에 따라서는 장기간 유지되며 중첩될 수 있는 상태를 다루는 고급 상태 관리 기법을 이용할 수도 있다.&lt;/p&gt;

&lt;p&gt;애플리케이션의 특정에 따라서 스프링을 이용해서 상태유지 stateful 스타일의 애플리케이션을 얼마든지 만들 수 있다.&lt;/p&gt;

&lt;p&gt;스프링에서는 싱글톤 외에도 다른 스코프를 갖는 빈을 간단히 만들 수 있다. 빈의 스코프를 잘 활용하면 스프링이 관리하는 빈이면서 사용자별로 또는 단위 작업별로 독립 적으로 생성되고 유지되는 오브젝트를 만들어 상태를 저장하고 이를 DI를 통해 서비스 빈에서 사용하게 만들 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;서드파티-프레임워크-라이브러리-적용&quot;&gt;서드파티 프레임워크， 라이브러리 적용&lt;/h3&gt;

&lt;p&gt;스프링은 거의 대부분의 자바 표준 기술과 함께 사용될 수 있다.&lt;/p&gt;

&lt;p&gt;기본적으로는 J2EE 1.4와 JavaEE 5.0을 지원한다. 따라서 스프링으로 만든 애플리케이션은 lSP, lSF , EJB , JNDI , JTA , lCA , lAX-WS , lMS , lavaMail , lPA와 같은 JavaEE 의 세부 기술과 함께 사용될 수 있다.&lt;/p&gt;

&lt;p&gt;스프링 애플리케이션은 기본적으로 서블릿을 기반으로 하는 독립 웹 모듈로 만들어진다. 스프링이 제공하는 많은 APl 는 이러한 표준 javaEE 의 인터페이스를 사용할 수 있도록 설계되어 있다. 최근에 등장한 JavaEE 6 의 표준 일부도 지원하고있다.&lt;/p&gt;

&lt;p&gt;표준 기술 외에도 많이 사용되는 오픈소스 프레임워크 라이브러리나 상용 제품도 스프링과 함께 시용할 수 있다. 이런 기술을 스프링과 함께 사용할 때는 먼저 스프링이 공식적으로 지원하는 기술인지 확인해본다.&lt;/p&gt;

&lt;p&gt;스프링이 직접 지원하는 오픈소스 ORM 의대표 제품으로는 하이버네이트와 iBatis 그리고 EclipseLi 뼈, OpenJPA와 같은 오픈소스 JPA 가 있고, 웹 프레임워크로는 스트렷츠 1/2, WebWork, Tapestry , Tiles 등을 꼽을수 있다. 그 외에도 다양한 ORM 라이브러리를 지원하고,  메시징 서버와 웹 서비스 기술 등을 지원한다. 스프링의 의존 라이브러리로 등록된 100 여 개의 각종 라이브러리를 살펴보면 스프링이 직접 API 나 추상화 서비스 등을 통해 지원하는 표준 또는 오픈소스, 상용 기술에는 어떤 것이 있는지 알수 있다. 그렇다면 스프링이 지원하는 기술이란 무슨 의미일까?&lt;/p&gt;

&lt;h3 id=&quot;첫째-해당-기술을-스프링의-di때턴을-따라-사용할-수-있다&quot;&gt;첫째， 해당 기술을 스프링의 DI때턴을 따라 사용할 수 있다&lt;/h3&gt;

&lt;p&gt;프레임워크나 라이브러리의 핵심 클래스를 빈으로 등록할 수 있게 지원해주는 것이 라고 생각해도 좋다. 코드를 이용해 초기화해야만 사용할 수 있는 기능을 빈을 등록 히는 것만으로 바로 사용할 수 있다. 프레임워크의 핵심 오브젝트를 빈의 형태로 등록해둘 수 있다변 프로퍼티를 이용해 세부 설정을 조정할 수도 있고， DI를 통해 다른 오브젝트에서 손쉽게 활용할 수도 있다. 또 스프링이 제공하는 추상화 서비스를 통해 다른 리소스에 투명하게 접근할 수도 있다.&lt;/p&gt;

&lt;p&gt;예를 들어 하이버네이트의 기능을 사용하려면 SessionFactory 오브젝트가 먼저 만들어져야 한다. SessionFactory 가 만들어지려면 설정파일에 대한 정보, 설정 값을 담은 프로퍼티와 DB 연결에 대한 정보가 필요하다. SessionFactory를 만들기 위해서는 먼저 설정을 담은 Configuration 오브젝트를 만들고 이를 이용해 다시 SessionFactory를 만드는 등의 작업이 펼요하다.&lt;/p&gt;

&lt;p&gt;스프링에서는 하이버네이트의 SessionFactory를 스프링이 제공하는 빈을 등록하는 것만으로 간단히 생성할 수 있게 해주는 LocalSessionFactoryBean 이라는 클래스를 제공한다. LocalSessionFactoryBean 클래스를 빈으로 등록하고 적절한 프로퍼티 설정을 해주면 간단히 SessionFactory 오브젝트가 만들어져 빈으로 등록된다.&lt;/p&gt;

&lt;p&gt;이름에서 알 수 있듯이 LocalSessionFactoryBean은 빈 오브젝트를 생성하고 초기화하는 기능을 가진 팩토리 빈이다. 이 클래스를 빈으로 등록하면 싱글톤 빈으로 존재하는 하이버네이트 SessionFactory 가 만들어지고 하이버네이트의 SessionFactory 가필요한 모든 빈에서 간단히 DI를 통해 가져다 사용할 수 있다. 또， DataSource와 같이 SessionFactory 가 펼요로 하는 리소스는 스프링의 빈으로 등록된 DataSource를 DI받아 사용하도록 만들어주기도 한다.&lt;/p&gt;

&lt;p&gt;리스트 9-14는 LocalSessionFactoryBean 을 이용해 SessionFactory 빈을 정의한 예다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6b37b4a3-33f0-4916-b52d-5dc6cbe49d0e/Untitled.png&quot; alt=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6b37b4a3-33f0-4916-b52d-5dc6cbe49d0e/Untitled.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/884374e7-3e06-461d-a7e4-34193cce0c06/Untitled.png&quot; alt=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/884374e7-3e06-461d-a7e4-34193cce0c06/Untitled.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이처럼 스프링 외의 기술을 접목할 때는 가장 먼저 스프링의 빈으로 등록해서 DI방식을 통해 사용 가능한지 살펴봐야 한다. 만약 빈으로 등록해서 바로 사용할 수 있는 구조로 핵심 API 나 클래스가 만들어져 있지 않은 경우라면, 위의 예처럼 스프링 빈으로 등록돼서 사용하기에 적합하도록 만들어주는 팩토리 빈을 도입해야 한다.&lt;/p&gt;

&lt;p&gt;스프링이 지원하는 프레임워크나 라이브러리는 대부분 이와 같이 스프링 빈의 설정만 으로 등록하고 사용 가능하도록 팩토리 빈 클래스가 제공된다. myDataSource 빈에 사용한 DBCP 의 BasicDataSource 같은 경우는 그 자체로 바로빈으로등록하고프로퍼티 설정해서 사용할수있는구조로되어 있다. 따라서 별도의 스프링 지원 없이도 손쉽게 스프링 애플리케이션에서 사용이 가능하다.&lt;/p&gt;

&lt;h3 id=&quot;둘째-스프링의-서비스-추상화가-적용됐다&quot;&gt;둘째， 스프링의 서비스 추상화가 적용됐다&lt;/h3&gt;

&lt;p&gt;이미 트랜잭션이나 OXM(Object-XML Mapping) 등의 예에서 다양한 오픈소스 프레임워크 또는 표준 기술에 대한스프링의 서비스추상화 기술을 살펴봤다. 첫 번째 방법은사용할 기술을 스프링의 빈으로 등록하고 설정 가능하도록 지원해췄을 뿐이고, 사용기술의 API는 애플리케이션에 그대로 노출한다.&lt;/p&gt;

&lt;p&gt;서비스 추상화를 적용하는 경우는 이보다 한 발 더나아가서 비슷한 기능을 제공하는 기술에 대한 일관된 접근 방법을 정의해준다.&lt;/p&gt;

&lt;p&gt;이를 통해 서드파티 프레임워크를 적용할 수 있을 뿐만 아니라 필요에 따라 호환 가능한 기술로 손쉽게 교체해서 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;자바의 표준 기술이란 JCP를 통해 제정된 표준 스펙일 뿐이다. 다양한 벤더와 프로젝트 그룹이 이 스펙을 따라서 실제 구현을 만든다. 표준 스펙에 정의된 API를 이용해 개발하기만 하면 실제 기술의 구현 제품은 교환해서 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;이와 비슷한 원리를 다양한 비표준 기술과 영역에 확장해서 적용한 것이 바로 스프링의 서비스 추상화라고 볼 수 있다. 상세한 스펙을 따라서 엄밀하게 적용되는 표준과는 다르지만, 개발자에게는 표준 기술을 사용하듯이 일관된 방법으로 코드를 작성하게 해준다는 것은 중요한 의미가 있다. 스프링이 제공하는 서비스 추상화가 표준 기술 스펙과 다른 것은 서비스 추상화는 이미 존재히는 다양한 기술의 공통점을 분석해서 추상화를 했다는 점이다.&lt;/p&gt;

&lt;p&gt;따라서 추상 서비스 인터페이스를 구현해서 각기술과 연동하게 해주는 어댑터 클래스가 필요하다. 서비스 추상화 인터페이스를 구현한 클래스들은 모두 스프링의 빈으로 등록되도록 만들어졌고，&lt;/p&gt;

&lt;p&gt;세부 기술의 특성에 맞는 설정이 손쉽게 가능하도록 다양한 프로퍼티를 제공하고 있다.&lt;/p&gt;

&lt;h3 id=&quot;셋째-스프링이-지지하는-프로그래밍-모델을-적용했다&quot;&gt;셋째， 스프링이 지지하는 프로그래밍 모델을 적용했다&lt;/h3&gt;

&lt;p&gt;스프링이 지지히는 프로그래밍 모델이 적용된 대표적인 예는 스프링의 데이터 액세스 기술에 대한 일관된 예외 적용이다.&lt;/p&gt;

&lt;p&gt;스프링의 데이터 액세스 지원 기능을 사용하면 데이터 액세스 기술의 종류에 상관없이 일관된 예외 계층구조를 따라서 예외가 던져진다. 여기에는 기술에 독립적인 DAO를 만들 수 있도록 데이터 액세스 예외를 추상화하고, 불필요하게 예외를 처리히는 코드를 피하도록 런타임 위주의 예외를 사용한다는 스프링의 개발철학이 적용된 것이다. 이를 통해, 서비스 계층의 비즈니스 로직을 담은 코드가 데이터 액세스 계층의 기술에 종속되지 않도록 만들어준다.&lt;/p&gt;

&lt;h3 id=&quot;넷째-템폴릿콜백이-지원된다&quot;&gt;넷째， 템폴릿/콜백이 지원된다&lt;/h3&gt;

&lt;p&gt;스프링은 JDBC , JMS, JCA를 비롯한 20여 가지 기술을 지원히는 템플릿/콜백을 제공한다. 이런 기술은 그대로 사용하면 반복적으로 등장하는는 판에 박힌 코드 때문에 전체 코드가 지저분해지고 이해하기 힘틀고 추상화하기도 어려운 구조가 돼 버린다. 스프링은 이런 기술을 간편하게 사용할 수 있도록 템플릿/콜백 기능을 제공한다. 대부분의 템플릿 클래스는 빈으로 등록해서 필요한 빈에서 DI 받아 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;스프링이 어떤 기술을 지원한다는 건 결국 스프링이 지지히는 개발철학과 프로그래밍 모델을 따르면서 해당 기술을 사용할 수 있다는 의미다.&lt;/p&gt;

&lt;p&gt;물론 이런 방법을 따르지 않고도 스프링에서 여타 프레임워크를 사용하거나 라이브러리를 이용할 수는 있다. 그 대신 스프링의 장점을 포기해야 하고 일관된 구조의 유연하고 확장 가능한 코드를 만들기가 힘들수있다.&lt;/p&gt;

&lt;p&gt;물론 스프링이 세상에 나와 있는 모든 기술과 프레임워크를 지원하진 않는다. 지원할 수도 없다. 스프링이 직접 지원히는 수십여 가지의 표준, 오픈소스, 상용 기술은 엔터프라이즈 애플리케이션 개발에 보편적으로 사용되는 유명한 것들로 제한된다.&lt;/p&gt;

&lt;p&gt;대신 스프링의 기술 지원 방법은 스프링의 핵심 기술과 프로그래밍 모델만 잘 이용하면 어떤 기술에든지 손쉽게 적용이 가능하다. 따라서 스프링이 직접 지원하는 기술이 아니라도 앞에서 소개한 네 가지 방법을 따라서 사용하도록 만들 수 있다.&lt;/p&gt;

&lt;p&gt;스프링 익스텐션 (http ://www . springsource. org/extensions)은 스프링이 직접 지원하지 않지만 나름 유용한 기술에 대해 스프링 스타일의 지원 기능을 만들어둔 대표적인 프로젝트다.&lt;/p&gt;

&lt;p&gt;스프링 개발팀 이 나 스프링 커뮤니티에서 지원기능을 제공하지 않더라도 서드파티 기술이나 프레임워크가 자체적으로 스프링 에 서 손쉽게 사용될 수 있도록 관련 기능을 제공하는 경우도 적지 않다. 오라클의 TopLink 같은 상용 ORM 솔루션부터 아파치의 Strut5 2 같은 최신 웹 프레임워크， JB055 의 Seam 같은 애플리케이션 프레입워크에 이르기까지 다양한 제품이 스프링 내에서 손쉽게 사용할 수 있는 스프링 지원 기능을 직접제공해주고있다.&lt;/p&gt;

&lt;p&gt;개발팀이나 기업에서 자체적으로 만든 사내 기술이나 스프링 지원 기능이 제공되지 않는 새로운 서드파티 기술을 사용해야 한다면 어떻게 해야 할까? 가장 쉽지만 가장 나쁜 방법은 해당 기술을 사용히는 코드는 전혀 스프링답지 않게 만드는 것이다.&lt;/p&gt;

&lt;p&gt;빈으로 등록되도록 만들지도 않고 펼요할 때마다 여기저기서 오브젝트를 직접 만들고 초기화 하는 코드를 넣어서 사용한다거나 다른 기술로 대체될 가능성이 충분히 있음에도 추상회를 적용하지 않고 특정 기술에 종속되는 코드에서 직접 사용한다거나， try / catch/ finally 블록으로 범벅된 코드를 마구 중복해가며 사용하는 것이다. 당장 기능은 돌아 가겠지만 기껏 스프링을 사용하면서 깔끔하고 유연하게 만들었던 코드가 금새 지저분 해지고 코드의 일관성도 없어지며 유연성도 떨어질 것이 분명하다. 제법 스프링을 잘안다고 자신하고 스프링을 적용한 개발 경험이 많다는 개발자도 이런 식으로 접근하는 경우가적지않다. 적어도 스프링을 사용해 애플리케이션을 개발하겠다고 마음먹었다면 사용하려는 모든 기술에 스프링다운 방식으로 접근해야 하지 않을까? 스프링에 새로운 기술을 연동하려면 이 책에서 설명했던 스프링의 프로그래밍 모댈과 지지하는 개발철학을 따르면서 앞에서 설명한 네 가지 방법을 이용하면 된다.&lt;/p&gt;

&lt;p&gt;가장 기초는 스프링의 빈으로 해당 기술의 핵심 오브젝트가 등록되도록 만드는 것이다. 필요에 따라 팩토리 빈을 사용해서 오브젝트 생성과 초기화 작업 프로퍼티 노출 등을 해줘야 한다. 애플리케이션 내의 빈들이 새로운 기술에 대해 빈을 DI 히는 방법으로 접근할수 있게 하는 것이다. 반대로 기존 빈 오브젝트를 새로 추가할 기술에서 사용할 수 있게 해줄 필요도 있다. 어떤 경우든 코드에 의한 초기화 작업이 필요하므로 팩토리 빈을 만들어 사용하면 편리하다. 때로는 서비스 추상화를 시도할 경우도 있다. 어떤 경우는 스프링이 이미 제공히는 추상 인터페이스의 새로운 구현으로 만들어질 수 있고 아예 새로운 추상화 인터페이스를 정의해서 적용할 수도 있다. 특히 JavaMail처럼 태스트가 매우 까다롭게 설계된 기술이고 DI 해서 사용하기 불편하다면 유연한 설정과 더불어 테스트를 위해서라도 새로운 인터 페이스를 추가할 필요가 있다.&lt;/p&gt;

&lt;p&gt;네트워크 접근이나 파일 IO 처럼 실패할 가능성이 있는 시도를 하는 기술이라면 템플릿/콜백 방식의 적용도 적극 고려해보자. 기술을 사용할 때마다 반복적으로 try/catch/ finally 블록이 필요한 기술이라면 템플릿/콜백이 제격이다.&lt;/p&gt;

&lt;p&gt;때로는 AOP 나 예외 전환을 적용할 수도 있다. 보통 외부에서 가져와서 사용히는 기술은 내부 구현 방식에 손을 대기 쉽지 않다. 소스코드가 공개되고 수정이 가능한 오픈 소스라고 할지라도 코드를 한번 손대기 시작하면 이후 버전과 호환성이 떨어지기 때문에 함부로 수정해서 사용하기는 힘들다.&lt;/p&gt;

&lt;p&gt;따라서 가능하면 외부 기술의 코드에는 손을 대지 않고 사용방법을 개선하는 작업이 필요하다. 예외 변환은 종종 AOP를통해 많이 이뤄진다. 특정 예외가 던져졌을 때에 대한 포인트컷을 만들어두고 어드바이스에서 예외를 추상화된 런타임 예외로 바꿔서 다시 던져주면 된다. 그러면 해당 API 를 샤용하는 코드를 전혀 손대지 않고도 손쉽게 예외 변환이 가능하다&lt;/p&gt;

&lt;p&gt;2권의 2장에서 소개히는 스프링의 하이버네이트나 jPA 지원 기능 중에서 예외 전환을 위해 AOP를 이용하는 예를 참고해보면 도움이 될 것이다.&lt;/p&gt;

&lt;p&gt;스프링이 직접 지원 기능을 제공해주지 않으면 무엇인가 시도해볼 생각도 없이 스프링 이전의 방식대로 코드를 만들어서 외부 기술을 사용하는 건 부끄러운 일이다. 스프링을 사용하려면 스프링의 프로그래밍 모댈과 그에 담긴 개발 철학을 따르는 일관된 코드를 만드는 데 많은 관심을 기울여야 한다.&lt;/p&gt;</content><author><name>seongtaekkim</name></author><category term="spring" /><summary type="html">– 토비의스프링 1권 정리 토비의스프링1권 9장</summary></entry><entry><title type="html">토비의스프링1권 9장</title><link href="https://seongtaekkim.github.io/spring-toby1_9-summary" rel="alternate" type="text/html" title="토비의스프링1권 9장" /><published>2021-08-18T01:36:01+09:00</published><updated>2021-08-18T01:36:01+09:00</updated><id>https://seongtaekkim.github.io/spring-toby1_9-summary</id><content type="html" xml:base="https://seongtaekkim.github.io/spring-toby1_9-summary">&lt;p&gt;&lt;span class=&quot;table-of-contents-list&quot;&gt;– 토비의스프링 1권 정리&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;table-of-contents-list&quot;&gt;
    &lt;li&gt;&lt;a href=&quot;./spring-toby1_9&quot;&gt;토비의스프링1권 9장&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;test&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;alert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;가나다라마바사&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;syntaxHighlight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;code&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;Hello World&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;bar&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>seongtaekkim</name></author><category term="spring" /><summary type="html">– 토비의스프링 1권 정리 토비의스프링1권 9장</summary></entry><entry><title type="html">java 강좌(1) - Python 기본</title><link href="https://seongtaekkim.github.io/java-basic" rel="alternate" type="text/html" title="java 강좌(1) - Python 기본" /><published>2018-09-28T01:40:00+09:00</published><updated>2018-09-28T01:40:00+09:00</updated><id>https://seongtaekkim.github.io/java-basic</id><content type="html" xml:base="https://seongtaekkim.github.io/java-basic">&lt;p&gt;&lt;span class=&quot;table-of-contents-list&quot;&gt;Python 강좌는 여러 절로 구성되어 있습니다. &lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;table-of-contents-list&quot;&gt;
    &lt;li&gt;&lt;a href=&quot;./java-basic&quot;&gt;java 강좌(1) - java 기본&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./java-advanced&quot;&gt;java 강좌(2) java  제어문&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;test&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;alert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;가나다라마바사&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;syntaxHighlight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;code&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;Hello World&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;bar&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>seongtaekkim</name></author><category term="java" /><summary type="html">Python 강좌는 여러 절로 구성되어 있습니다. java 강좌(1) - java 기본 java 강좌(2) java 제어문</summary></entry><entry><title type="html">java 강좌(1) - Python 두번째 강의</title><link href="https://seongtaekkim.github.io/java-advanced" rel="alternate" type="text/html" title="java 강좌(1) - Python 두번째 강의" /><published>2018-09-28T01:40:00+09:00</published><updated>2018-09-28T01:40:00+09:00</updated><id>https://seongtaekkim.github.io/java-advanced</id><content type="html" xml:base="https://seongtaekkim.github.io/java-advanced">&lt;p&gt;&lt;span class=&quot;table-of-contents-list&quot;&gt;Python 강좌는 여러 절로 구성되어 있습니다. &lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;table-of-contents-list&quot;&gt;
    &lt;li&gt;&lt;a href=&quot;./java-basic&quot;&gt;java 강좌(1) - java 기본&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./java-advanced&quot;&gt;java 강좌(2) java  제어문&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;noscript&gt;&lt;pre&gt;---
layout: null
---

&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;urlset xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot;
        xsi:schemaLocation=&amp;quot;http://www.sitemaps.org/schemas/sitemap/0.9 http://www.sitemaps.org/schemas/sitemap/0.9/sitemap.xsd&amp;quot;
        xmlns=&amp;quot;http://www.sitemaps.org/schemas/sitemap/0.9&amp;quot;&amp;gt;
    {% for post in site.posts %}
    &amp;lt;url&amp;gt;
        &amp;lt;loc&amp;gt;{{ site.url }}{{ post.url }}.html&amp;lt;/loc&amp;gt;
        {% if post.lastmod == null %}
        &amp;lt;lastmod&amp;gt;{{ post.date | date_to_xmlschema }}&amp;lt;/lastmod&amp;gt;
        {% else %}
        &amp;lt;lastmod&amp;gt;{{ post.lastmod | date_to_xmlschema }}&amp;lt;/lastmod&amp;gt;
        {% endif %}

        {% if post.sitemap.changefreq == null %}
        &amp;lt;changefreq&amp;gt;weekly&amp;lt;/changefreq&amp;gt;
        {% else %}
        &amp;lt;changefreq&amp;gt;{{ post.sitemap.changefreq }}&amp;lt;/changefreq&amp;gt;
        {% endif %}

        {% if post.sitemap.priority == null %}
        &amp;lt;priority&amp;gt;0.5&amp;lt;/priority&amp;gt;
        {% else %}
        &amp;lt;priority&amp;gt;{{ post.sitemap.priority }}&amp;lt;/priority&amp;gt;
        {% endif %}

    &amp;lt;/url&amp;gt;
    {% endfor %}
&amp;lt;/urlset&amp;gt;&lt;/pre&gt;&lt;/noscript&gt;
&lt;script src=&quot;https://gist.github.com/seongtaekkim/930b19a8b15c9384b3ec66a3c3f57a7a.js&quot;&gt; &lt;/script&gt;

&lt;p&gt;waeawg
두번째 강의&lt;/p&gt;</content><author><name>seongtaekkim</name></author><category term="java" /><summary type="html">Python 강좌는 여러 절로 구성되어 있습니다. java 강좌(1) - java 기본 java 강좌(2) java 제어문</summary></entry></feed>