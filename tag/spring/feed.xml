<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator>
  <link href="https://seongtaekkim.github.io/tag/spring/feed.xml" rel="self" type="application/atom+xml" />
  <link href="https://seongtaekkim.github.io/" rel="alternate" type="text/html" />
  <updated>2021-09-11T19:25:22+09:00</updated>
  <id>https://seongtaekkim.github.io/tag/spring/feed.xml</id>

  
  
  

  
    <title type="html">웹개발자 | </title>
  

  
    <subtitle>IT</subtitle>
  

  

  
    
      
    
  

  
  

  
    <entry>
      <title type="html">스프링 따라하기</title>
      <link href="https://seongtaekkim.github.io/springframework-remake" rel="alternate" type="text/html" title="스프링 따라하기" />
      <published>2021-09-11T15:36:01+09:00</published>
      <updated>2021-09-11T15:36:01+09:00</updated>
      <id>https://seongtaekkim.github.io/springframework-remake</id>
      <content type="html" xml:base="https://seongtaekkim.github.io/springframework-remake">&lt;p&gt;&lt;span class=&quot;table-of-contents-list&quot;&gt;– 스프링 따라하기 –&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;table-of-contents-list&quot;&gt;
    &lt;li&gt;&lt;a href=&quot;./springframework-remake&quot;&gt;springframework - 따라하기&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./springframework-architecture&quot;&gt;springframework - 아키텍처&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;springframework-따라하기&quot;&gt;SpringFramework 따라하기&lt;/h2&gt;

&lt;p&gt;1.개요&lt;/p&gt;

&lt;p&gt;springFramework 동작방식을 이해하고, 간단한 toy-framework를 만들어보자.&lt;/p&gt;

&lt;p&gt;2.목표&lt;/p&gt;

&lt;p&gt;toy-framework를 활용한 웹사이트 로그인&lt;/p&gt;

&lt;p&gt;3.구현방식&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;spring container 구현&lt;/li&gt;
  &lt;li&gt;aop 구현&lt;/li&gt;
  &lt;li&gt;dataAccess 구현&lt;/li&gt;
  &lt;li&gt;context 구현&lt;/li&gt;
  &lt;li&gt;web mvc 구현&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;4.기한&lt;/p&gt;

&lt;p&gt;21.09.11 ~ 12.31&lt;/p&gt;

&lt;p&gt;5.개발환경&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;tomcat&lt;/li&gt;
  &lt;li&gt;jdk11&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;6.참조 레퍼런스&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;springframework 4.3x&lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      <author>
          <name>seongtaekkim</name>
        
        
      </author>

      

      
        <category term="spring" />
      

      
        <summary type="html">– 스프링 따라하기 – springframework - 따라하기 springframework - 아키텍처 SpringFramework 따라하기</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">스프링 따라하기</title>
      <link href="https://seongtaekkim.github.io/springframework-architecture" rel="alternate" type="text/html" title="스프링 따라하기" />
      <published>2021-09-11T15:36:01+09:00</published>
      <updated>2021-09-11T15:36:01+09:00</updated>
      <id>https://seongtaekkim.github.io/springframework-architecture</id>
      <content type="html" xml:base="https://seongtaekkim.github.io/springframework-architecture">&lt;p&gt;&lt;span class=&quot;table-of-contents-list&quot;&gt;– 스프링 따라하기 –&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;table-of-contents-list&quot;&gt;
    &lt;li&gt;&lt;a href=&quot;./springframework-remake&quot;&gt;springframework - 따라하기&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./springframework-architecture&quot;&gt;springframework - 아키텍처&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;springframework-architecture&quot;&gt;SpringFramework architecture&lt;/h1&gt;

&lt;h2 id=&quot;아키텍처&quot;&gt;아키텍처&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://blog.kakaocdn.net/dn/dXQ6s0/btqCXvb5fVY/AzjKoJZiB8jfWvkN1Njbhk/img.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;실제-구동순서&quot;&gt;실제 구동순서&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Web Application&lt;/strong&gt; = &lt;strong&gt;Web Server&lt;/strong&gt; + &lt;strong&gt;Web Container&lt;/strong&gt;(= Servlet Container)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Web Container&lt;/strong&gt; 는 유저의 요청에 따라 &lt;strong&gt;Servlet 자원에 대한 생명주기를 관리&lt;/strong&gt;합니다.&lt;/li&gt;
  &lt;li&gt;webContainer : servlet 단위 처리&lt;/li&gt;
  &lt;li&gt;springContainer : bean 단위처리&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;​&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://aaronryu.github.io/2021/02/14/a-tutorial-for-spring-mvc-and-security/spring-web-application-description-3-filter-and-interceptor.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;웹 애플리케이션이 실행되면 Tomcat(WAS)에 의해 web.xml이 로딩된다.&lt;/p&gt;

    &lt;p&gt;(load-on-startup으로 톰캣 시작시 servlet생성 가능하도록 설정 가능)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;web.xml에 등록되어 있는 ContextLoaderListener(Java class)가 생성된다. ContextLoaderListener 클래스는 ServletContextListener 인터페이스를 구현하고 있으며, ApplicationContext를 생성하는 역할을 수행한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;생성된 ContextLoaderListener는 applicationContext.xml을 로딩한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;applicationContext.xml에 등록되어 있는 설정에 따라 Spring Container가 구동된다. 이때 개발자가 작성한 비즈니스 로징에 대한 부분과 DAO, VO 객체들이 생성된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;클라이언트로부터 웹애플리케이션 요청이 온다. (FrontController 패턴에 의해 수행된다.)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;DispatcherServlet(Servlet)이 생성된다. DispatcherServlet은 FrontController의 역할을 수행한다. 클라이언트로부터 요청 온 메시지를 분석하여 알맞은 PageController에게 전달하고 응답을 받아 요청에 따른 응답을 어떻게 할지 결정만 한다. 실질적인 작업은 PageControlle에서 이뤄지기 때문이다. 이러한 클래스들을 HandlerMapping, ViewResolver클래스라고 한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;DispatcherServlet은 servlet-context.xml(spring-mvc.xml)을 로딩한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;두 번째 Spring Container가 구동되면 응답에 맞는 PageController들이 동작한다. 이때 첫 번째 Spring Container가 구동되면서 생성된 DAO, VO, ServiceImpl 클래스들과 협업하여 알맞은 작업을 처리하게 된다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;모듈-의존관계&quot;&gt;모듈 의존관계&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;(모듈 == .jar)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://media.vlpt.us/images/wldus9503/post/b172f1a8-1463-4ee8-89c0-0fe8786b4fe8/spring%EB%AA%A8%EB%93%88%20%EC%9D%98%EC%A1%B4%EA%B4%80%E3%84%B1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;모듈별-역할&quot;&gt;모듈별 역할&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;ArtifactId&lt;/th&gt;
      &lt;th&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;spring-aop&lt;/td&gt;
      &lt;td&gt;프록시 기반 AOP를 만들 때 필요한 어드바이스, 포인트컷, 프록시 팩토리빈, 자동 프록시 생성기 등을 제공&lt;br /&gt; - 필수 라이브러리 - Beans&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;spring-aspects&lt;/td&gt;
      &lt;td&gt;스프링이 제공하는 AspectJ AOP를 사용할 때 필요한 모듈&lt;br /&gt; - JPA 지원 기능 사용시 ORM, 트랜잭션 기능 지원시 Transaction 필요&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;spring-beans&lt;/td&gt;
      &lt;td&gt;스프링 DI 기능의 핵심인 빈 팩토리와 DI 기능을 제공하는 모듈&lt;br /&gt; - 빈 메타 정보, 빈 리더, 빈 팩토리의 구현과 프로퍼티 에디터가 포함&lt;br /&gt; - 필수 라이브러리 - ASM, Core&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;spring-context&lt;/td&gt;
      &lt;td&gt;어플리케이션 컨텍스트 기능을 제공&lt;br /&gt;- 어플리케이션 컨텍스트를 만드는 데 필요한 대부분의 기능과 빈 스캐너, 자바코드 설정 기능, EJB 지원, 포메터, 로드타임 위빙, 표현식,&lt;br /&gt;- 단순한 빈팩토리가 아닌 엔터프라이즈 어플리케이션 프레임워크로 사용하기 위해 반드시 필요합니다.&lt;br /&gt;- 필수 라이브러리 - AOP, Expression&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;spring-context-support&lt;/td&gt;
      &lt;td&gt;JMX JNDI, 리모팅, 스케줄링, 스크립트 언어 지원, 검증기 등의 컨테이너로서의 주요한 기능을 담고 있습니다.어플리케이션 컨텍스트에서 필요로 하는 부가기능을 지원&lt;br /&gt; - EhCache, 메일 추상화 서비스, CommonJ와 Quartz 스케줄링, FreeMarker, JasperReports, Velocity 팩토리 기능을 제공&lt;br /&gt;- 위의 기능을 사용하지 않으면 해당모듈은 필요업지만, 스프링 MVC가 Context.Support에 의존하므로 스프링 MVC를 사용한다면 필수로 추가해야 한다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;spring-core&lt;/td&gt;
      &lt;td&gt;스프링 모듈에서 필요로 하는 공통 기능을 갖는 핵심 모듈&lt;br /&gt; - 스프링에서 사용하는 주요 어노테이션, 컨버터, 상수, 유틸리티 클래스 등을 제공&lt;br /&gt; - 선택적 의존 - ASM&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;spring-expression&lt;/td&gt;
      &lt;td&gt;스프링 표현식 언어(SpEL) 기능을 지원&lt;br /&gt; - 필수 라이브러리 - Core&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;spring-instrument&lt;/td&gt;
      &lt;td&gt;스프링의 로드타임위버(LTW) 기능을 적용할 때 필요함.&lt;br /&gt;JVM의 -javaagent 옵션을 자용해 자바에이전트로도 사용됨.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;spring-instrument-tomcat&lt;/td&gt;
      &lt;td&gt;애플리케이션이 아닌 톰캣 서버의 클래스 로더로 사용하는 모듈&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;spring-jdbc&lt;/td&gt;
      &lt;td&gt;JDBC 템플릿을 포함한 JDBC 지원 기능을 제공&lt;br /&gt;- JdbcTemplate 등의 JDBC 지원 오브젝트 외에도 스프링이 직접 제공하는 DataSource 구현 클래스들이 제공&lt;br /&gt;- 필수 라이브러리 - 트랜잭션&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;spring-jms&lt;/td&gt;
      &lt;td&gt;스프링의 JMS 지원 기능을 사용할 때 필요한 모듈&lt;br /&gt; - 필수 라이브러리 - Transaction&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;spring-messaging&lt;/td&gt;
      &lt;td&gt;스프링 메세징 기능을 제공한다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;spring-orm&lt;/td&gt;
      &lt;td&gt;하이버네이트, JPA, JDO, iBatis와 같은 ORM에 대한 스프링의 지원 기능&lt;br /&gt; - 내부적으로 JDBC를 사용한다.&lt;br /&gt; - 필수 라이브러리 : JDBC&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;spring-oxm&lt;/td&gt;
      &lt;td&gt;Object/XML Mapping&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;spring-test&lt;/td&gt;
      &lt;td&gt;Test는 스프링의 테스트 지원기능을 가진 모듈&lt;br /&gt;(테스트 컨텍스트 프레임워크나 목 오브젝트 등을 이용)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;spring-tx&lt;/td&gt;
      &lt;td&gt;스프링의 데이터 액세스 추상화의 공통 기능을 담고 있습니다.&lt;br /&gt; - DataAcssessException 예외 계층구조와 트랜잭션 추상화 기능, 트랜잭션 동기화 저장소 그리고 JCA 기능을 포함&lt;br /&gt;- 필수 라이브러리 - Context&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;spring-web&lt;/td&gt;
      &lt;td&gt;스프링 웹 기술의 공통적인 기능을 정의한 모듈&lt;br /&gt;- 바인딩, 컨텍스트 로더, 필터, 멀티파트, 메세지 컨버터 기능을 제공&lt;br /&gt;- 스프링 MVC 외에도 스프링이 지원하는 스트럿츠, JSF 등을 적용할 때 필요&lt;br /&gt;- Caucho, HttpInvoker, JAX-RPC, JAX-WS 등의 리모팅 기능도 포함&lt;br /&gt;- 필수 라이브러리 - Context&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;spring-webmvc&lt;/td&gt;
      &lt;td&gt;스프링 MVC 기능을 제공하는 모듈&lt;br /&gt; - 필수 라이브러리 - Web, Context.Support&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;portlet&lt;/td&gt;
      &lt;td&gt;Portlet 개발에 사용하는 스프링 모듈&lt;br /&gt; - 필수 라이브러리 - Web.Servlet&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;spring-websocket&lt;/td&gt;
      &lt;td&gt;WebSocket and SockJS infrastructure, including STOMP messaging support&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;spring -asm&lt;/td&gt;
      &lt;td&gt;ASM 모듈은 클래스 바이트코드 조작 및 분석 프레임워크인 ASM을 재 패키징한 모듈입니다.&lt;br /&gt; - ASM 프레임워크는 스프링 뿐 아니라 여러 프레임워크에서 및 라이브러리에서 사용되는데 이때 스프링 프레임워크와&lt;br /&gt;ASM을 사용하는 다른 프레임워크와의 충돌을 방지하기 위해 org.springframework.asm 패키지로 재패키징해 독립적인 모듈로 제공합니다.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;출처&quot;&gt;출처&lt;/h4&gt;

&lt;p&gt;1.스프링 모듈 의존관계 설명&lt;/p&gt;

&lt;p&gt;https://dololak.tistory.com/2&lt;/p&gt;

&lt;p&gt;2.ApplicationContext 와 WebApplicationContext  차이&lt;/p&gt;

&lt;p&gt;https://dololak.tistory.com/21?category=636502&lt;/p&gt;

&lt;p&gt;3.스프링 동작순서&lt;/p&gt;

&lt;p&gt;https://aaronryu.github.io/2021/02/14/a-tutorial-for-spring-mvc-and-security/&lt;/p&gt;

&lt;p&gt;※ 저작권 문제 시 삭제하겠습니다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>seongtaekkim</name>
        
        
      </author>

      

      
        <category term="spring" />
      

      
        <summary type="html">– 스프링 따라하기 – springframework - 따라하기 springframework - 아키텍처 SpringFramework architecture</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">토비의스프링2권 2장</title>
      <link href="https://seongtaekkim.github.io/spring-toby2_2" rel="alternate" type="text/html" title="토비의스프링2권 2장" />
      <published>2021-08-19T19:36:01+09:00</published>
      <updated>2021-08-19T19:36:01+09:00</updated>
      <id>https://seongtaekkim.github.io/spring-toby2_2</id>
      <content type="html" xml:base="https://seongtaekkim.github.io/spring-toby2_2">&lt;p&gt;&lt;span class=&quot;table-of-contents-list&quot;&gt;– 토비의스프링 2권 정리 –&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;table-of-contents-list&quot;&gt;
    &lt;li&gt;&lt;a href=&quot;./spring-toby2_2&quot;&gt;토비의스프링2권 2장&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;트랜잭션&quot;&gt;트랜잭션&lt;/h1&gt;

&lt;p&gt;스프링이 처음 등장했을 때의 모토는 “객체지향 원칙에 충실한 POJO 에 엔터프라이즈 서비스를 제공한다”였다. 엔터프라이즈 서비스가 제공되는 컴포넌트를 지향하던 당시의 EJB는 특정 클래스의 상속과 인터페이스 구현을 강제하고 툴의 지원 없이는 작성이 거의 불가할 정도로 복잡한 XML 설정파일과 고가의 서버와 컨테이너 등을 필요로 했다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;EJB 가 제공했던 엔터프라이즈 서비스에서 가장 매력적인 것은 바로 선언적 트랜잭션이다.&lt;/strong&gt; &lt;strong&gt;선언적 트랜잭션 경계설정 기능을 이용하면 코드 내에서 직접 트랜잭션을 관리 하고 트랜잭션 정보를 파라미터로 넘겨서 사용하지 않아도 된다. 선언적 트랜잭션의 가장 큰 장점은 트랜잭션 스크립트 방식의 코드를 탈피할 수 있다는 것이다.&lt;/strong&gt;
트랜잭션 스크립트란 하나의 트랜잭션 안에서 동작해야 하는 코드를 한 군데 모아서 만드는 방식이다. 보통 트랜잭션마다 하나의 메소드로 구성된다. 메소드의 앞부분에서 DB를 연결하고 트랜잭션을 시작히는 코드가 나오고， 이렇게 만들어진 트랜잭션 안에서 DB를 액세스히는 코드와 그 결과를 가지고 비즈니스 로직을 적용하는 코드가 뒤엉켜서 등장한다. 물론 트랜잭션 내의 일부 작업은 메소드를 분리해서 만들 수는 있지만， 그래도 같은 트랜잭션 안에서 동작함을 보장하려면 Connection과 같은 트랜잭션 정보가 담긴 파라미터를 계속 물고 다녀야 한다. 트랜잭션 스크립트 방식의 코드에는 중복이 자주 발생한다. 지주 사용되는 DB 액세스 로직이 여러 트랜잭션 스크립트 안에 중복돼서 등장하기 쉽기 때문이다. &lt;strong&gt;비즈니스 로직과 데이터 액세스 로직이 한데 코드에 섞여 있는 문제는 말할 것도 없다.&lt;/strong&gt;
트랜잭션 스크립트 코드에 DAO 패턴을 적용해서 데이터 액세스 로직을 분리하는 시도를 해볼 수 있겠지만， 트랜잭션을 명시적으로 시작하고 종료하는 경계 설정코드가 비즈니스 로직 코드에 함께 등장하는 것과 매번 트랜잭션 정보를 메소드 따라미터로 넘기는 불편은 여전히 남아 있다.
&lt;strong&gt;하지만 선언적 트랜잭션 경계설정을 사용하면 이런 문제를 모두 해결할 수 있다. 트랜잭션이 시작되고 종료되는 지점은 별도의 설정을 통해 결정된다.&lt;/strong&gt; 또 작은 단위로 분리되어 있는 데이터 액세스 로직과 비즈니 스 로직 컴포넌트와 메소드를 조합해서 하나의 트랜잭션에서 동작하게 만드는 것도 간단하다. 선언적 트랜잭션이 제공히는 트랜 잭션 전파 기능 덕분이다. 의미 있는 작은 단위로 만들어진 오브젝트와 메소드를 적절한 순서대로 조합해서 호출하기만 하면 코드의 중복 없이 다양한 트랜잭션 안에서 동작 하는 코드를 만들 수 있다. A, B, C 라는 세 개의 오브젝트 또는 메소드가 있다고 하자.&lt;/p&gt;

&lt;p&gt;A나 B 나 C 가 그 자체로 독립적인 트랜잭션으로 동작하게 하려면 A, B, C를 각각 트랜 잭션 경계로 지정해주면 된다 A가 시작될 때 트랜잭션이 시작되고 A의 메소드를 종료할 때 트랜잭션이 함께 종료된다. 그런데 A-B, A-C, B-C ， A-B-C와 같은 구성으로 트랜잭션을 만들고 싶을 수도 있다. 이때도 A-B 의 코드를 하나로 묶어서 새로운 트랜잭션 스크립트를 만들 필요는 없다.&lt;strong&gt;A 에서 B 의 코드를 호출하게 하고 각각의 트랜잭션 전파 속성을 ‘트랜잭션 필요(REQUIRED)’로 해주면 된다&lt;/strong&gt;. 이렇게 해두면 A 에서 시작된 트랜잭션에 B 의 코드가 자동으로 참여하게 된다. 어떤 조합으로 만들어도 상관없다.&lt;/p&gt;

&lt;p&gt;선언적 트랜잭션 경계설정을 사용하면， 결국 코드의 중복을 제거하고 작은 단위의 컴포넌트로 쪼개서 개발한 후에 이를 조합해서 쓸 수 있다. 다 다양한 로직이 복잡하게 결합돼서 하나의 업무를 처리하는 엔터프라이즈 시스뱀의 요구조건을 가장 잘 충족시켜줄 기술이다.
EJB 의 이런 선언적 트랜잭션 기능을 복잡한 환경이나 구현조건 없이 평범한 POJO로 만든 코드에 적용하게 해주는 것이 바로 스프링이다. 스프링은 EJB 등에서나 제공 되던 엔터프라이즈 서비스를 POJO 의 장점을 유지한 채로 사용할 수 있게 만들어준다.
DI 로 대표되는， 스프링의 객체지향 설계 원칙에 충실한 핵심 기술이 이를 가능하게 만들어준다.
&lt;strong&gt;스프링의 선언적 트랜잭션은 매우 매력적인 기능이다. JavaEE 서버에서 동작히는 엔티티빈이나 JPA로 만든 컴포넌트에 JTA를 이용한 글로벌 트랜잭션을 적용해야만 가능했던 고급 기능을 간단한 톰켓 서버에서 동작히는 가벼운 애플리케이션에도 적용해 주기 때문이다.&lt;/strong&gt; &lt;strong&gt;또한 JDBC. JPA 하이버네이트 iBatis. JDO 등 스프링이 지원하는 대부분의 데이터 액세스 기술과 JMS 메시징 서비스， CCI 처럼 트랜잭션 개념을 지원한 서비스에도 적용할 수 있다. 원한다면 언제든지 WAS 가 제공하는 JTA와 연결해서 글로벌 트랜잭션 서비스의 혜택을 받을 수도 있다.&lt;/strong&gt;
스프링을 처음 사용히는 개발자가 가장 매력을 느끼는 기능이 이 선언적 트랙잭션 기능이라고 한다. 스프링의 그 밖의 장점은 잘 모르더라도 선언적 트랜잭션 기능이 절실히 펼요해서 스프링을 계속 사용하겠다는 개발자도 적지 않다. 그만큼 효과적인 엔터 프라이즈 개발애 목 필요한 중요한 기능이다.
이 절에서는 스프링이 제공동}는 선언적 트랜잭션 경계설정의 방법과 종류를 자세히 알아보겠다. 트랜잭션 예제 코드는 springbook.learningtest.spring.tx 패키지에서 찾을수있다.&lt;/p&gt;

&lt;h2 id=&quot;261-트랜잭션-추상화와-동기화&quot;&gt;2.6.1 트랜잭션 추상화와 동기화&lt;/h2&gt;

&lt;p&gt;스프링이 제공히는 트랜잭션 서비스는 트랜잭션 추상화와 트랜잭션 동기화 두 가지로 생각해볼수있다.
트랜잭션 서비스의 종류는 데이터 액세스 기술보다 더 다양하다. &lt;strong&gt;트랜잭션 서비스는 데이터 액세스 기술은 변하지 않더라도 환경에 따라 바뀔 수 있기 때 문이다.&lt;/strong&gt; 또， 스프링 없이 선언적 트랜잭션을 이용하려면 특정 기술과 서버 플랫폼， 특정 트랜잭션 서비스에 종속될 수밖에 없다. 스프링은 데이터 액세스 기술과 트랜잭션 서비스 사이의 종속성을 제거하고 스프링이 제공하는 트랜잭션 추상 계층을 이용해서 트랜잭션 기능을 활용하 도록 만들어준다. 이를 통해 트랜잭션 서비스의 종류나 환경이 바뀌더라도 트랜잭션을 사용하는 코드는 그대로 유지할 수 있는 유연성을 얻을 수 있다.
스프링의 트랜잭션 동기화는 트랜잭션을 일정 범위 안에서 유지해주고， 어디서든 자유롭게 접근할 수 있게 만들어준다. 트랜잭션 동기화는 트랜잭션 추상화， 데이터 액세스 기술을 위한 랩플릿과 더불어 선언적 트랜잭션을 가능하게 해주는 핵심기능이다.
스프링의 서비스추상화와동기회에 관한동작원리와특정은 Vol.l 에서 자세히 다뤘 으므로， 여&lt;strong&gt;기서는 데이터 액세스 기술에 따라 사용할 수 있는 트랜잭션 추상화 클래스의 종류와 사용 방법을 알아보겠다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;platformtransactionmanager&quot;&gt;PlatformTransactionManager&lt;/h3&gt;

&lt;p&gt;스프링 트랜잭션 추상화의 핵심 인터페이스는 PlatformTransactionManager 다. 모든 스프링의 트랜잭션 기능과 코드는 이 인터페이스를 통해서 로우레벨의 트랜잭션 서비스를 이용할 수 있다. PlatformTransactionManager 인터페이스는 리스트 2-42와 같이세 개의 메소드를 갖고 있다.&lt;/p&gt;

&lt;p&gt;​&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;PlatformTransactionManager&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; 
    &lt;span class=&quot;nc&quot;&gt;TransactionStatus&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getTransaction&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;TransactionDefinition&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;definition&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TransactionException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;commit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;TransactionStatus&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;status&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TransactionException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;rollback&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;TransactionStatus&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;status&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TransactionException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;리스트 2-42 PlatformTransactionManager 인터페이스&lt;/p&gt;

&lt;p&gt;PlatformTransactionManager는 트랜잭션 경계를 지정히는 데 사용한다. 트랜잭션이 어디서 시작하고 종료하는지 종료할 때 정상 종료(커밋) 인지 비정상 종료(롤백) 인지를 결정히는 것이다. 스프링에서는 시작과 종료를 트랜잭션 전파 기법을 이용해 자유롭게 조합하고 확장할 수 있다. 그래서 트랜잭션을 시작한다는 의미의 begin() 과 같은 메소드 대신 적절한 트랜잭션을 가져온다는 의미의 getTransaction( ) 메소드를 사용한다.
&lt;strong&gt;getTransaction() 은 트랜잭션 속성에 따라서 새로 시작하거나 진행 중인 트랜잭션에 참여하거나， 진행 중인 트랜잭션을 무시하고 새로운 트랜잭션을 만드는 식으로 상황에 따라다르게동작한다.&lt;/strong&gt;
TransactionDefinition 은 트랜잭션의 네 가지 속성을 나타내는 인터페이스다.
&lt;strong&gt;TransactionStatus 는 현재 참여하고 있는 트랜잭션의 ID와 구분정보를 담고 있다. 커빗 또는 롤백 시에 이 TransactionStatus 를 사용한다.&lt;/strong&gt;
&lt;strong&gt;선언적 트랜잭션 방식을 시용할 것이라면 사실 PlatformTransactionManager 인터 페이스의 시용 방법은 몰라도 상관없다&lt;/strong&gt;. 다만 이 추상화된 인터페이스를 구현한 트랜 잭션 서비스 클래스의 종류를 알고 적절한 것을 선택해서 빈으로 둥록하는 방법만 알고 있으면 된다. 가끔 태스트에서 트랜잭션을 제어해가면서 태스트 코드를 만들어야 할 경우가 있는데， 그때는 PlatformTransactionManager를 직접 이용해야 할 수도 있다.&lt;/p&gt;

&lt;h3 id=&quot;트랜잭션매니저의종류&quot;&gt;트랜잭션매니저의종류&lt;/h3&gt;

&lt;p&gt;스프링이 제공하는 PlatformTransactionManager 구현 클래스를 살펴보자.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;DataSourceTransactionManager&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;Connection 의 트랜잭션 API를 이용해서 트랜잭션을 관리해주는 트랜잭션 매니저다.&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;이 트랜잭션 매니저를 사용하려면 트랜잭션을 적용할 DataSource 가 스프링의 빈으로 등록돼야 한다.&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;JDBC API를 이용해서 트랜잭션을 관리하는 데이터 액세스 기술인 JDBC와 iBatis SqlMap으로 만든 DAO 에 적용할 수 있다.
&lt;strong&gt;DataSourceTransactionManager를 빈으로 등록할 때는 리스트 2-43 과 같이 트랜잭션을 적용할 DAO 가 사용하는 것과 통일한 DataSource를 빈으로 제공해줘야 한다.&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;리스트 2-43 DataSourceTransactionManager 빈 등록&lt;/p&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;bean&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;memberDao&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot; . .. MemberJdbcDao&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;dataSource&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;ref=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'dataSource'&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;bean&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;dataSource&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;org . .. SimpleDriverDataSource&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;bean&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;transactionManager&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;dataSource&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;ref=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;dataSource&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/property&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;DataSourceTransactionManager 가 사용할 DataSource는 getConnection() 이 호출될 때마다 매번 새로운 Connection을 돌려줘야 한다. ThreadLocal 등을 이용해 트랜잭션을 저장해두고 돌려주는 특별한 기능을 가진 DataSource를 사용하면 안 된다.&lt;/p&gt;

&lt;p&gt;애플리케이션 코드에서 트랜잭션 매니저가 관리하는 Connection 을 가져오려면 DataSource의 getConnection() 대신 스프링 &lt;strong&gt;DataSourceUtils 클래스의 스태틱 메소드인 getConnection(DataSource) 를 사용해야 한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;JdbcTemplate의 내부 에서 트랜잭션 매니저로부터 현재 진행 중인 트랜잭션을 가져올 때 바로 이 메소 드를 사용한다. 대개는 JdbcTemplate을 이용해서 DAO를 작성하면 되기 때문에 DataSourceUtils.getConnection() 으로 Connection을 직접 가져와 사용할 일은 많지 않다.&lt;/p&gt;

&lt;p&gt;JdbcTemplate을 사용할 수 없는 코드이거나 DAO 밖에서 현재 Connection을 가져와 참조해야 할 때만 주의해서 사용하자.
JdbcTemplate을 사용하지 않는 레거시 DAO 코드를 스프링의 트랜잭션 매니저와 연동해서 동작하게 하려면 어떻게 해야 할까?&lt;/p&gt;

&lt;p&gt;두 가지 방법이 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;첫 번째 방법은 레거시 DAO 코드의 Connection을 가져오는 코드를 모두 DataSourceUtils.getConnection() 으로 변경하는 것이다.
두 번째 방법은 레거시 코드가 DataSource 의 getConnection() 을 직접 호출해서 Connection을 가져오는 경우에 적용할 수 있다.&lt;/p&gt;

    &lt;p&gt;리스트 2-44와 같이 DAO와 DataSource 사이에 TransactionAwareDataSourceProxy를 넣어서 레거시 DAO 코드에서 getConnection() 을 호출해도 매번 새로운 Connection 이 생성되지 않게 할수 있다.&lt;/p&gt;

    &lt;p&gt;대신 현재 트랜잭션 매니저가 관리하고 있는, 진행 중인 트랜잭션이 담긴 Connection 을 돌려주게 만들 수 있다.&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;DAO 에서는 마치 매번 새로운 Connection을 DataSource 에서 가져오는 것 같지만 실제로는 트랜잭션이 진행 중인 동안에는 매번 같은 Connection을 받게 된다.&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;자세한 내용은 TransactionAwareDataSourceProxy 의API 문서를 참고하자.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;리스트 2-44 레거시 DAO를 위한  빈&lt;/p&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;bean&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;dataSource&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;org.springframework.jdbc.datasource.TransactionAwareDataSourceProxy&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;(property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;targetDataSource&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;ref=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;targetDataSource&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt; 
&lt;span class=&quot;nt&quot;&gt;&amp;lt;bean&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;targetDataSource&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;org&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;SimpleDriverDataSource&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이렇게 DataSourceTransactionManager를 시용하는 여러 가지 방법이 있지만， JdbcTemplate 이나 SqlMapClientTemplate 처럼 내부에서 Connection과 트랜잭션 작업을 알아서 처리해주는 댐플릿을 시용하는 방법이 제일 좋다.
서버가 제공하는 DataSource와 트랜잭션 서비스를 JNDI로 접근해 사용해야 한다면 DataSourceTransactionManager는 사용할 수 없다. 그때는 JTA를 지원하는 스프 링의 트랜잭션 매니저를 사용해야 한다. 하나 이상의 DB 에 대한 작업을 트랜잭션으로 묶어야 동f는 경우에도 DataSourceTransactionManager를 시용하는 대신 JTA를 써야한다 .&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;JpaTransactionManager&lt;/p&gt;

    &lt;p&gt;jPA를 이용하는 DAO 에는 JpaTransactionManager를 사용한다. 물론 JTA로 트랜 잭션 서비스를 이용하는 경우에는 JpaTransactionManager 가 필요 없다.
리스트 2 -45 에서 볼 수 있듯이 JpaTransactionManager 에는 LocalContainerEntityManagerFactoryBean 타입의 빈을 프로퍼티로 등록해줘야 한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;리스트 2-45 JpaTransactionManager 설정&lt;/p&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;bean&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;dataSource1&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;..&lt;span class=&quot;nt&quot;&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;bean&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;dataSource2&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;..&lt;span class=&quot;nt&quot;&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;bean&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;memberDao1&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;...MemberDao&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;dataSource&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;ref=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;dataSource1&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/property&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;bean&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;memberDao2&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;...MemberDao&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;dataSource&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;ref=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;dataSource2&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/property&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;&amp;lt;bean&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;transactionManager1&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;...DataSourceTransactionManager&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;dataSource&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;ref=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;dataSource1&quot;&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;&amp;lt;/bean&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;bean&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;transactionManager2&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;...DataSourceTransactionManager&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;dataSource&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;ref=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;dataSource2&quot;&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;&amp;lt;/bean&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;JpaTransactionManager 를 사용할 때는 JPA 의 persistence. xml 파일의&lt;persistence-unit&gt; 태그 내의 transaction-type을 JTA로 설정해두지 않도록 한다.&lt;/persistence-unit&gt;&lt;/p&gt;

&lt;p&gt;스프링이 제공하는 JpaTransactionManager를 사용할 것이므로 transactiontype 애트리뷰트는 생략한다.
JpaTransactionManager 는 DataSourceTransactionManager 가 제공 하는 DataSource 레벨의 트랜잭션 관리 기능을 동시에 제공한다. 따라서 JpaTransactionManager를 사용하면서 동시에 트랜잭션이 적용된 JDBC DAO를 사용할수도있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;HibernateTransactionManager&lt;/p&gt;

    &lt;p&gt;하이버네이트 DAO 에는 HibernateTransactionManager 를 사용한다. 리스트 2-46 과 같이 SessionFactory 타입의 빈을 프로퍼티로 넣어주면 된다.
JpaTransactionManager와 마찬가지로 DataSource 레벨의 트랜잭션 기능도 동시에 제공한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;리스트 2-46 하이버네이트 트랜잭션 매니저&lt;/p&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;bean&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;sessionFactory&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;org.springframework.orm.hibernate3.annotation.AnnotationSessionFactoryBean&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;bean&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'transactionManager'&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'org .springframework.orm.hibernate3.HibernateTransactionManager'&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;sessionFactory.&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;ref=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'sessionFactory'&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt; 
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;JmsTransactionManager, CciTransactionManager&lt;/p&gt;

    &lt;p&gt;스프링은 DB뿐 아니라 트랜잭션이 지원되는 JMS 와 CCI를 위해서도 트랜잭션 매니저를 제공한다. JMS와 CCI 에 대해서는 이 책에서 다루지 않는다. 관심이 있다면 스프링 레퍼런스 문서와 API 문서를 참고해보기 바란다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;JtaTransactionManager&lt;/p&gt;

    &lt;p&gt;하나 이상의 DB 또는 트랜잭션 리소스가 참여하는 글로벌 트랜잭션을 적용하려면 JTA를 이용해야 한다. JTA는 여러 개의 트랜잭션 리소스(DB. JMS 등)에 대한 작업을 하나의 트랜잭션으로 묶을 수 있고， 여러 대의 서버에 분산되어 진행되는 작업을 트랜잭션으로 연결해주기도 한다.&lt;/p&gt;

    &lt;p&gt;JTA 트랜잭션을 이용하려면 트랜잭션 서비스를 제공하는 WAS를 이용하거나 독립 JTA 서비스를 제공해주는 프레임워크를 사용해야 한다.
서버가 제공하는 JTA 트랜잭션 매니저를 스프링에서 이용히는 방법은 간단하다.
디음과 같이 JtaTransactionManager를 등록해주기만 하면 된다.&lt;/p&gt;

    &lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;bean&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;transactionManager&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;org.springframework.transaction.jta.JtaTransactionManager&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;프로퍼티 설정 없이 JtaTransactionManager를 등록하면 디폴트로 등록된 JNDI 이름을 통해 서버의 TransactionManager와 UserTransaction을 찾는다.
디폴트로 사용하는 UserTransaction 의 JNDI 이름은 java:comp/UserTransaction 이고 
TransactionManager는 java :comp/TransactionManager,java :appserver / TransactionManager, java: pm / TransactionManager, java: / TransactionManager 네 가지다.
만약 디폴트 이름과 다르게 서버에 설정되어 있다면 transactionManagerName과 userTransactionName 프로퍼티 를 통해 이름을 지정해주면 된다.
JtaTransactionManager 를 사용할 때는 DataSource 도 서버에 등록된 XA DataSource를 사용해야 한다.&lt;/p&gt;

&lt;p&gt;JNDI를 이용해 서버의 XA DataSource를 다음과 같이 빈으로 등록하고 DAO 나 EntityManagerFactory, SessionFactory 등에서 사용 하게해야한다.&lt;/p&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;jee:jndi-lookup&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;dataSource&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;jndi-name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;jdbc/myXADataSource&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;DB 가 하나라면 트랜잭션 매니저 또한 하나만 등록돼야 한다. DB 가 여러 개라도 JTA를 이용해 글로벌 트랜잭션을 적용할 것이라면 JtaTransactionManager 하나만 등록돼야 한다. 
단， 두 개 이상의 DB를 완전히 독립적으로 사용히는 경우라면 두 개 이상의 트랜잭션 매니저를 등록할 수는 있다. 
DB 가 두 개라면 DataSource도 두 개가 등록 돼야 한다. 또한 DataSource를 사용히는 DAO도 두 개가 등록돼야 한다.
DAO는 어떤 식으로든 DataSource 빈과 연결되기 때문이다. 만약 테이블 구조가 같은 두 개의 DB를 중복해서 사용하는 경우라면 DAO 코드가 달라지지 않을 것이다. 
이때는 DAO 클래스는 하나만 만들고 DAO 빈 두 개를 등록하면 된다.&lt;/p&gt;

&lt;p&gt;리스트 2-47은 두 개의 DB 에 대해 같은 기능을 가진 DAO를 독립적으로 등록한 설정의 예다 .DAO는 하나의 클래스를 가지고 두 개의 다른 빈으로 등록해서 사용할수 있지만 DataSource와 PlatformTransactionManager는 DB 별로 하나씩 등록해줘야 한다.&lt;/p&gt;

&lt;p&gt;리스트 2-47 두 개의 DB에 모두 사용되는 DAO 등록 방법&lt;/p&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;bean&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;dataSource1&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;..&lt;span class=&quot;nt&quot;&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;bean&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;dataSource2&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;..&lt;span class=&quot;nt&quot;&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;bean&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;memberDao1&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;...MemberDao&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;dataSource&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;ref=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;dataSource1&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/property&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;bean&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;memberDao2&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;...MemberDao&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;dataSource&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;ref=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;dataSource2&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/property&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;&amp;lt;bean&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;transactionManager1&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;...DataSourceTransactionManager&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;dataSource&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;ref=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;dataSource1&quot;&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;&amp;lt;/bean&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;bean&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;transactionManager2&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;...DataSourceTransactionManager&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;property&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;dataSource&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;ref=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;dataSource2&quot;&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;&amp;lt;/bean&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;262-트랜잭션-경계설정-전략&quot;&gt;2.6.2 트랜잭션 경계설정 전략&lt;/h2&gt;

&lt;p&gt;트랜잭션 매니저를 빈으로 등록하고 JdbcTemplate 이나 스프링 트랜잭션과 연동되는 EntityManager 또는 Session을 사용하도록 DAO 코드를 작성했다면 다음은 트랜잭션의 경계를 설정하는 작업을 할 차례다.
트랜잭션의 시작과 종료가 되는 경계는 보통 서비스 계층 오브젝트의 메소드다. 
비즈니스 로직이 거의 없어서 서비스 계층과 데이터 액세스 계층을 통합했다면, 통합된 계층의 메소드가 트랜잭션 경계가 될 것이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;트랜잭션 경계를 설정하는 방법은 코드에 의한 프로그램적인 방법과， AOP를 이용한 선언적인 방법으로 구분할 수 있다.&lt;/strong&gt; 
&lt;strong&gt;전자는 트랜잭션을 다루는 코드를 직접 만들고， 후자는 AOP를 이용해 기존 코드에 트랜잭션 경계설정 기능을 부여해준다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;코드에-의한-트랜잭션-경계설정&quot;&gt;코드에 의한 트랜잭션 경계설정&lt;/h3&gt;

&lt;p&gt;스프링의 트랜잭션 매니저는 모두 PlatformTransactionManager를 구현하고 있다. 따라서 이 인터페이스로 현재 등록되어 있는 트랜잭션 매니저 빈을 가져올 수 있다면 트랜잭션 매니저의 종류에 상관없이 동일한 방식으로 트랜잭션을 제어하는 코드를 만들수 있다.&lt;/p&gt;

&lt;p&gt;트랜잭션을 처리하기 위해 PlatformTransactionManager 의 메소드를 직접 사용해도 되지만 try/catch 블록을 써야 히는 번거로움이 발생한다.&lt;/p&gt;

&lt;p&gt;트랜잭션 안에서 작업 중에 예외가 발생한 경우에는 트랜잭션을 롤백해주도록 만들어야 하기 때문이다. 
그래서 PlatformTransactionManager 의 메소드를 직접 시용하는 대신 댐플릿/콜백 방식의 TransactionTemplate을 이용하면 편리하다.&lt;/p&gt;

&lt;p&gt;리스트 2-48 은 코드에 의해 관리되는 트랜잭션 을 적용한 예다.&lt;/p&gt;

&lt;p&gt;MemberDao 는JDBC , iBatis , lPA , 하이버네이트 중 어떤 것을 이용해도 된다. 또， 트랜잭션 매니저 빈도 DAO 에서 사용한 기술과 호환만 된다면 DataSourceTransactionManager, JpaTransactionManager, HibernateTransactionManager, JtaTransactionManager 중어떤 것을 사용해도 된다. 
&lt;strong&gt;스프링 의 트랜잭션 서비스 추상화와 동기화 기법 덕분에 기술에서 독립적인 트랜잭션 코드를 만들 수 있다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;리스트 2-48 코드를 이용한 트랜잭션 경계설정 방법&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MemberService&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@Autowired&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MemberDao&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memberDao&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TransactionTemplate&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;transactionTemplate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;nd&quot;&gt;@Autowired&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;init&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;PlatformTransactionManager&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;transac&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tionManager&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;transactionTemplate&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TransactionTemplate&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;transactionManager&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;addMembers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Member&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;members&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; 
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;transactionTemplate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TransactionCallback&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; 
            &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;dolnTransaction&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;TransactionStatus&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;status&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	            &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Member&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;members&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	                 &lt;span class=&quot;n&quot;&gt;memberDao&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addMember&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
				&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;)};&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;트랜잭션의 기본 속성을 변경하려면 TransactionTemplate 을 만들 때
TransactionDefinition 오브젝트를 만들어서 파라미터로 제공해주면 된다. 기본 속성을 사용한다면 위의 코드처럼 한 번 만들어두고 재사용할 수도 있다.
코드에 의한 트랜잭션 경계설정은 실제로는 많이 사용되지 않는다.&lt;/p&gt;

&lt;p&gt;대개는 선언적 트랜잭션 방식으로 충분하기 때문이다. 
반면에 테스트 코드에서 의도적으로 트랜잭션을 만들고 종료시키거나 여러 번 트랜잭션을 거치는 상황을 만들어야 하는 경우에는 유용하다.
&lt;strong&gt;코드에 의한 트랜잭션 경계설정 방식을 애플리케이션 코드에 사용하지 않더라도 PlatformTransactionManager를 통한 트랜잭션 추상화에 대해서는 잘 이해하고 있어야 한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;선언적 트랜잭션은 트랜잭션이 시작되고 적용되는 코드가 눈에 보이지 않기 때문에 자칫 실수하면 트랜잭션 적용과 관련된 찾기 힘든 버그를 만날 수 있다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;이때 트랜 잭션을 직접 코드에서 가져와 확인해보고 제어 해가면서 트랜잭션 적용 상태를 분석해 보면 어렵지 않게 문제의 원인을 찾을 수 있다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;어디서든 PlatformTransactionManager 를 DI 받아서 getTransaction() 해보면 현재 진행 중인 트랜잭션을 확인할 수 있다.&lt;/strong&gt;
&lt;strong&gt;getTransaction() 이 돌려주는 TransactionStatus 오브젝트를 이용하면 현재 트랜잭션이 새로 시작된 것인지 기존 트랜잭션에 참여한 것인지 또는 트랜잭션이 종료된 것인지 확인할 수 있다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;두 개의 DAO 또는 서비스 계층 코드가 같은 트랜잭션 안에서 동작 하고 있는지도 확인해볼 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;선언적-트랜잭션-경계설정&quot;&gt;선언적 트랜잭션 경계설정&lt;/h3&gt;

&lt;p&gt;선언적 트랜잭션을 이용하면 코드에는 전혀 영향을 주지 않으면서 특정 메소드 실행 전후에 트랜잭션이 시작되고 종료되거나 기존 트랜잭션에 참여하도록 만들 수 있다. 
&lt;strong&gt;이를 위해서는 Vol.1 에서 살펴본 것처럼 데코레이터 패턴을 적용한 트랜잭션 프록시 빈을 사용해야 한다. 선언적 트랜잭션 경계설정은 트랜잭션 프록시 빈 덕분에 가능한 것이다.&lt;/strong&gt;
&lt;strong&gt;트랜잭션은 대부분 성격이 비슷하기 때문에 적용 대상마다 일일이 선언해주기보다는 일괄적으로 선언히는 것이 펀리하다. 그래서 간단한 설정으로 특정 부가기능을 임의의 타깃 오브젝트에 부여해줄 수 있는 프록시 AOP를 주로 활용한다.&lt;/strong&gt;
스프링에서 AOP를 적용하는 방법은 매우 다양하다. 굳이 선언적 트랜잭션의 동작 원리와 AOP를 자세히 알고 싶은 게 아니라면， 트랜잭션에 사용되는 AOP는 AOP 라기 보다는고유한트랜잭션설정 기능으로기억하고사용하는것이 편하다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;AOP를 이용해 트랜잭션 기능을 부여하는 방법은 다양하지만 보통 다음의 두 가지 방법이 가장 많이 사용된다.&lt;/strong&gt; 
&lt;strong&gt;이 두 가지 중 하나를 선택해서 사용하면 된다.&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;aop와 tx네임스페이스&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;스프링은 AOP 기능과 트랜잭션 설정을 위해 편리하게 사용할 수 있는 전용 태그를 제공한다. aop 스키마의 태그와 tx 스키마의 태그를 사용할 수 있다.&lt;/strong&gt;
트랜잭션 경계설정이라는 부가기능을 AOP를 이용해 빈에게 적용하려면 두 가지 정보가 필요하다. AOP는 부가기능을 빈 오브젝트에게 적용하는 방법이다. &lt;strong&gt;따라서 어떤 부가기능을 사용할지 결정해야 한다. AOP 용어로 하자면 어드바이스가 있어야 한다.&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;트랜잭션 경계설정 부가기능이므로 트랜잭션 어드바이스가 필요하다. 그리고 어떤 대상에게 이 부가기능을 부여할지를 선정해야 한다. 
선정 대상을 결정하는 기준이 필요하다. &lt;strong&gt;어드바이스가 적용될 대상을 선정하는 것을 AOP 용어로 포인트컷이라고 한다.&lt;/strong&gt; 따라서 트랜잭션 어드바이스와 포인트컷을 결합해서 하나의 AOP 모듈을 정의한다. 
&lt;strong&gt;하나의 AOP 모듈을 스프링에서는 어드바이저라고 부른다.&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;리스트 2-49 의 설정은 tx 스키마의 advice 태그를 이용해서 트랜잭션 부가기 능을 담은 트랜잭션 어드바이스를 정의한 것이다. 트랜잭션 속성은 원한다면 메소드 단위로 다르게 지정할 수 있다. 
여기서는 모든 메소드에 대해 기본 트랜잭션 속성을 지정하게 했다. 트랜잭션을 적용하려면 트랜잭션 매니저가 필요하다. 따라서
transaction-manager 애트리뷰트에 사용할 트랜잭션 매니저 빈의 아이디를 넣어줘야 한다. 
이 애트리뷰트의 디폴트 값은 transactionManager 이므로 트랜잭션 매니저 빈의 이름을 transactionManager로 선언했다면 생략할 수 있다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;리스트 2-49 트랜잭션 어드바이스&lt;/p&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;tx:advice&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;txAdvice&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;transaction-manager=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;transactionManager&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt; 
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;tx:attributes&amp;gt;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;&amp;lt;tx:method&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;*&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;&amp;lt;/tx:attributes&amp;gt;&lt;/span&gt; 
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/tx:advice&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;어드바이스가 준비됐으니 다음은 포인트컷을 정의할 차례다. 포인트컷은 AspectJ 표현식을 이용하는 것이 가장 간편하다.
aop 스키마의 pointcut 태그를 사용하면 다음과 같이 트랜잭션을 적용할 대상을 선정하는 포인트컷을 정의할 수 있다. 
이 포인트컷 표현식은 어떤 패키지에 있든 상관없이 이름이 MemberDao 인 인터페이스의 모든 메소드를 선정해준다. 
AOP 의 어드바이스가 적용되는 위치인 조인 포인트는 메소드 임을 기억하자. 
&lt;strong&gt;포인트컷은 원한다면 메소드 단위까지 상세하게 지정할 수 있다.&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;aop:pointcut&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;txPointcut&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;expression=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;execution(&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;MemberDao&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;*(&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;..&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;))&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;또 포인트컷은 기본적으로 인터페이스에 적용된다는 사실도 기억해두자.&lt;/strong&gt; 
&lt;strong&gt;스프링 AOP 의 동작원리인 JDK 다이내믹 프록시는 인터페이스를 이용해 프록시를 만들기 때문이다. 그런데 인터페이스 없이 클래스만으로 프록시를 만들 수도 있다.&lt;/strong&gt; 
인터페이스 없이 등록된 빈에도 AOP를 적용할 수 있다. 하지만 트랜잭션 AOP 의 타깃은 가능한 한 인터페이스를 사용할 것을 권장한다.
리스트 2-50은 MemberDao 인터페이스의 예다. DAO를 사용하는 클라이언트가 이용할 수 있는 메소드만 정의되어 있다. 당연히 모든 메소드에 트랜잭션이 적용돼 야한다.&lt;/p&gt;

&lt;p&gt;리스트 2-50 MemberDao 인터페이스&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MemberDao&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Member&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Member&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;members&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;deleteAll&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;	
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;반면에 리스트 2-51 의 MemberDaolmpl 클래스를살펴보자.&lt;/p&gt;

&lt;p&gt;리스트 2-51 MemberDao 구현 클래스&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MemberDaolmpl&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MemberDao&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;SimpleJdbclnsert&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;nc&quot;&gt;SimpleJdbcTemplate&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;jdbcTemplate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;setDataSource&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;DataSource&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dataSource&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt; 
        &lt;span class=&quot;n&quot;&gt;jdbcTemplate&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SimpleJdbcTemplate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dataSource&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;insert&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SimpleJdbclnsert&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dataSource&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;withTableName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;member&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;	
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Member&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Member&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;members&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;..&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; 
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;deleteAll&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;특별한 방법을 써서 인터페이스 없이 이 클래스에 직접 트랜잭션 AOP 를 적용했다고 해보자.&lt;/strong&gt; 
포인트컷에서는 *를 이용해 모든 메소드를 선정하게 했다. 문제는 add() , deleteAll() , count() 와 같은 트랜잭션이 필요한 메소드뿐 아니라 setDataSource() 처럼 트랜잭션과 전혀 상관없는 메소드도 포인트컷의 선정 대상에 들어간다는 점이다.&lt;/p&gt;

&lt;p&gt;포인트컷 표현식은 이름 패턴을 이용해 대상을 선정하기 때문에 add() , deleteAll() , count() 는 포함시키고 setDataSource() 는 제외시키도록 표현 식을 만들 수 없다. 
&lt;strong&gt;따라서 트랜잭션이 필요한 DAO 의 공개된 메소드뿐 아니라 불필요한 수정자나 기타 DAO 내부에서 사용할 메소드까지 모두 트랜잭션이 적용되는 문제가 발생한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;물론 setDataSource() 가 호출되는 동안 트랜잭션이 시작됐다가 아무 일 없이 종료해도 기능에는 별문제 없을 것이다. 하지만 쓸데없는 트랜잭션 경계설정 작업을 수행하느라 그만큼 시간과 리소스를 소모하게 된다. 따라서 트랜잭션 AOP를 적용할 때는 가능한 한 인터페이스를 사용하자.&lt;/p&gt;

&lt;p&gt;앞에서 예로 든 포인트컷은 DAO를 직접 트랜잭션 경계로 만들었는데， 사실 이방식은 비즈니스 로직이 특별히 없어서 서비스 계층을 생략하거나 DAO 에 통합해서 만드는 단순한 애플리케이션에서나 쓸 수 있는 방법이다. 일반적으로는 데이터 액세스 계층보다는 서비스 계층의 메소드가 트랜잭션 경계가 되는 것이 자연스럽다. 하나의 단위 비즈니스 로직은 하나의 트랜잭션 안에서 동작해야 하기 때문이다.&lt;/p&gt;

&lt;p&gt;포인트컷까지 정의했다면 다음은 어드바이저를 정의할 차례다. 
어드바이저는 포인트컷과 어드바이스를 조합해서 하나의 AOP 모ebf을 정의해주는 것이다. 
어드바이저는 &lt;aop:advisor&gt;를 사용한다. 단  &lt;aop:advisor&gt; 나 &lt;aop:pointcut&gt;은 모두&lt;/aop:pointcut&gt;&lt;/aop:advisor&gt;&lt;/aop:advisor&gt;&lt;/p&gt;
&lt;aop:config&gt; 의 내부에 정의해야 한다는 점에 주의하자. 따라서 포인트컷과 어드바 이저는 리스트 2-52와같이 &lt;aop:config&gt; 안에 넣어줘야한다.



리스트 2-52 어드바이저 정의

~~~xml
&lt;aop:config&gt;
    &amp;lt;aop :pointcut id=&quot;txPointcut&quot; expression=&quot;execution( * * . . MemberDao . *(. . ))&quot; /&amp;gt;
    &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;txPointcut&quot; /&gt;
&amp;lt;/aop:config)
~~~

어드바이저는 다른 빈이나 설정에서 참조할 일이 없으므로 id를 넣지 않는다.
&amp;lt;tx:advice.로 정의한 어드바이스의 아이디와 &lt;aop:pointcut&gt;으로 정의한 포인트컷 아이디를 참조 애트리뷰트에 넣어줘야 한다.
**포인트컷이나 어드바이스가 아이디가 있다는 건 어드바이저를 여러 개 만들어서 다양한조합을할수도 있다뜻이다.** 동일한포인트컷 대상에 여러 종류의 어드바 이스를 적용한다거나 같은 어드바이스를 여러 포인트컷을 이용해서 다양한 대상에 적용할수가있다.

포인트컷이 하나의 어드바이저에만 쓰 인다면，리스트 2-53 과 같이 포인트컷 표현식을 아예 (aop:advisor&amp;gt; 에 넣고 포인트컷 정의를 생략할 수 있다. 이때는 pointcut- ref 대신 pointcut을 시용한다.



리스트 2-53 포인트컷을 내장한 어드바이저

~~~xml
&amp;lt;aop: config&amp;gt;
    &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut=&quot;execution( * * .. MemberDao. *(. . )) &quot; /&gt; 
 &amp;lt;/aop: config&amp;gt;
~~~

AOP 설정 방법에 대한 자세한 내용은 5 장을 참고하자 .







- @Transactional

  트랜잭션 AOP를 적용하는 두 번째 방법은 @Transactional 애노태이션을 이용하는 것이다. 이 접근 방법에선 설정파일 에 명시적으로 포인트컷과 어드바이스를 정의하지 않는다. 
  
  **대신 트랜잭션이 적용될 타깃 인터페이스나 클래스，메소드 등에**
  **@Transactional 애노태이션을 부여해서 트랜잭션 대상으로 지정하고 트랜잭션의 속성을제공한다.**
  @Transactional 을 사용할 때 필요한 설정은 다음 한 줄뿐이다. &amp;lt;tx: annotationdriven&amp;gt; 태그는 등록된 빈 중에서 @Transactional 이 붙은 클래스나 인터페이스 또는 메소드를 찾아 트랜잭션 어드바이스를 적용해준다.
  
  리스트 2-54는 @Transactional 이 적용된 MemberDao 인터페이스의 예다.



리스트 2-54 @Transactional이 적용된 인터페이스

~~~java
@Transactional public interface MemberDao { 
    public void add(Member m);
	public void add(List&lt;Member&gt; members);
	public void deleteAll ();
	@Transactional(readOnly=true) public long count();
}
~~~

MemberDao 인터페이스를 구현한 클래스로 선언된 빈은 인터페이스 메소드에 한해서 트랜잭션이 적용된다. 
인터페이스에 붙은 @Transactional 선언은 인터페이스 내의 모든 메소드에 적용된다. 동시에 메소드 레벨에도 @Transactional 을 지정할 수있다. 
**이때는 메소드의 선언이 인터페이스의 선언에 우선한다.**
또는 리스트 2-55 와 같이 빈의 클래스에 직접 @Transactional 을 적용할 수도 있다.





리스트 2-55 @Transactional이 적용된 클래스

~~~java
@Transactional public class MemberDaolmpl extends JdbcDaoSupport implements MemberDao (
	public void add(Member m) { ... } 
    public void add(List&amp;lt;Member) members) { ... }
	public void deleteAll() { .. . } @Transactional(readOnly=true) 
	public long count() { ... }
}
~~~

**메소드에 @Transactional 이 있으면 클래스 레벨의 @Transactional 선언보다 우선해서 적용된다.**

 클래스에 @Transactional 을 부여했을 때 트랜잭션이 적용되는 메소드는 프록시 방식과 인터페이스의 여부에 따라서 조금 달라진다.
 클래스의 @Transactional 은 인터페이스의 @Transactional 선언보다 우선한다. 
**따라서 @Transactional 을 적용하는 우선순위는 클래스의 메소드， 클래스， 인터페이스의 메소드， 인터페이스순이다.**
MemberDao 의 메소드별 트랜잭션 속성을 생각해보자. 인터페이스 레벨에 부여된 @Transactional 은 디폴트 트랜잭션 속성을 갖는다. 따라서 읽기전용 속성은 false다. 이 속성은 모든 인터페이스의 메소드에 적용된다. 하지만 count() 메소드는 메소드 레벨의 @Transactional 애노테이션을 가졌고 읽기전용 속성이 true로 되어 었으 므로， 인터페이스 레벨의 선언보다 우선해서 적용된다. 따라서 count() 메소드만 읽기전용이고， 그 밖의 메소드는 트랜잭션이 적용되기는 하나 읽기와 쓰기가 모두 가능한 트랜잭션으로 설정된다.

**@Transaction 적용 대상은 미리 결정하고 애플리케이션 안에서 통일하는 게 좋다.**

**타입 레벨과 메소드 레벨에 동시에 @Transactional 이 적용되는 경우는 종종 있다.**
**반면에 인터페이스와 클래스 양쪽에 불규칙하게 @Transactional 이 혼용되는 건 바람직하지못하다.**



**트랜잭션 경계설정 방법 두 가지는 각기 장단점이 있다. aop와 tx 스키마의 태그를 이용하는 방식은 선언이 조금 복잡해 보이지만 코드에는 전혀 영향을 주지 않고 일괄적 으로 트랜잭션을 적용하거나 변경할 수 었다는 장점이 있다. @Transactional 을 일일이 대상 인터페이스나 클래스 메소드에 부여하는 건 상대적으로 번거로운 작업이다. 반면에 @Transactional 은 aop와 tx 스키마의 태그를 사용하는 경우보다 훨씬 세밀한 설정 이가능하다.**
리스트 2-56은 get으로 시작하는 메소드에만 읽기전용 속성을 부여하고 나머지는 모두 디폴트 트랜잭션 속성을 사용하게 하는 트랜잭션 어드바이스 선언이다.



리스트 2-56 tx 스키마의 태그를 이용한 트랜잭션 속성 정의

~~~xml
&lt;tx:advice id=&quot;txAdvice&quot;&gt; 
    &lt;tx:attributes&gt; &lt;tx:method name=&quot;get*&quot; read-only=&quot;true&quot; /&gt;
        &lt;tx:method name=&quot;*&quot; /&gt; 
    &lt;/tx:attributes&gt; 
&lt;/tx:advice&gt;
~~~

이 방법의 장점은 트랜잭션을 적용할 대상이 아무리 늘어나도 매번 번거롭게 트랜잭션 관련 설정을 변경해주거나 추가할 필요가 없다는 것이다. 추가할 클래스와 메소드가 포인트컷에 선정 대상이 되게만 하면 된다.
@Transactional 을 사용해서 위의 &lt;tx:attributes&gt;와 동일한 트랜잭션 선언을 하려면 리스트 2-57과 같이 많은 애노테이션이 필요하다. **@Transactional 으로는 간단히 get 으로 시작하는 메소드를 모두 읽기전용으로 만들 수 있는 방법이 없다.** 
get 으로 시작 히는 모든 메소드에 일일이 @Transactional 을 부여하고 속성을 넣어서 인터페이스 레벨에 부여된 @Transactional 속성보다 우선되게 해야 한다. 그러다 보니 애노테이션이 지저분하게 반복돼서 나오는 경우가 많아진다. 
물론 모든 트랜잭션 속성을 동일하게 디폴트로 가져가면 클래스나 인터페이스에 @Transactional 하나만 붙여주변 되니 간단해 진다.
하지만 본격적인 엔터프라이즈 시스템이라면 적어도 조회전용 메소드에 읽기전용 트랜잭션 속성을 부여해서 성능을 최적화하는것이     기본이다. 그렇다면 리스트 2-57과 같이 @Transactional 이 잔뜩 붙은 인터페이스나 클래스를 피할 수 없을 것이다.	



리스트 2-'51 @Transactional을 이용한 트랜잭션 속성 정의

~~~java
@Transactional public interface IssueDao {
    public void add(Issue i);
	public void add(List&amp;lt;Issue) members);
	public void deleteAll();
	@Transactional(readOnly=true) public Issue get(int id);
	@Transactional(readOnly=true) public Issue getAll();
	@Transactional(readOnly=true) public Issue findIssuesByName(String name);
}
~~~



**이런 불편함에도 불구하고 @Transactional 은 매우 세밀하게 트랜잭션 속성을 부여 해야 할 경우라면 포인트컷과 트랜잭션 어드바이스로 한 번에 속성을 일괄 적용하는 것보다 유리하다.** 
특정 메소드만 격리수준을 변경한다거나 제한시간을 두는 등의 필요가 생겼을 때 aop와 tx 의 태그를 이용하려면 매우 복잡해진다. 단 하나의 메소드에 다른 트랜잭션 속성을 부여하기 위해 새로운 포인트컷 어드바이스 어드바이저를 지정하고 해당 메소드를 다른 포인트컷에서는 제외시켜야 하는 등의 복잡한 방법을 시용해야 한다.
**반면에 @Transactional 을 사용하면 간단히 해당 메소드의 @Transactional 애노테이션에 원하는속성을추가해주기만하면된다.**
**이 두 가지 방법은 각기 장단점이 있으므로 개발하려는 시스템의 트랜잭션 적용 전략과 필요에 잘 맞는 방법을 적절히 선택해서 사용하자.**







### 프록시 모드: 인터페이스와 클래스

스프링의 AOP는 기본적으로 다이내믹 프록시 기법을 이용해 동작한다. 다이내믹 프록시를 적용하려변 인터페이스가 있어야 한다. 인터페이스의 사용은 DI 에서도 가장 기본 원칙인 만큼문제 될 것은 없다. 
**하지만 특별한경우에 인터페이스 를구현하지 않은 클래스에 트랜잭션을 적용해야 할 수 있다.** 
인터페이스가 없는 레거시 클래스 코드를 그대로 가져다가 사용히는데 수정은 불가능하고 대신 스프링의 트랜잭션의 경계설정 대상 으로 만들고 싶다면 어떻게 해야 할까?

**이때는 스프링이 지원히는 클래스 프록시 모드를 사용하면 된다.** 
**스프링에서는 JDK 다이내믹 프록시 외에도 CGLib 라이브러리가 제공해주는 클래스 레벨의 프록시도 사용할수있다.**
**클래스 프록시는 aop/tx 스키마를 사용히는 경우와 @Transactional 을 사용하는 경우 모두 이용할수있**다.

- aop/tx 스키마 태그의 클래스 프록시 설정

  &amp;lt;aop: c on fig&amp;gt; 에는 디폴트로 false 값을 가진 proxy-target-class 애트리뷰트가 있다. 인터페이스 없이 클래스에 직접 프록시를 적용하려면 이 애트리뷰트를 true로 바꿔주변 된다. 리스트 2-58은 클래스 프록시를 이용한 트랜잭션 AOP 설정의 예다.
  
  

리스트 2• 58  스키마 태그에 설정한 클래스 프록시

~~~xml
&lt;aop:config proxy-target-class=&quot;true&quot;&gt;
       &amp;lt;aop:pointcut id=&quot;txPointcut&quot; expression=execution( * * . . MemberDaolmpl. *(. . ))&quot; /&amp;gt;
	&lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;txPointcut&quot; /&gt;
  &amp;lt;/aop:config/&amp;gt;
~~~

이때 포인트컷의 선정 대상도 클래스여야 한다. 이렇게 해주면 인터페이스 없이도 클래스에 직접 적용된다.



- @Transactional의 클래스 프록시 설정

  @Transactional 을 사용하는 경우에도 다음과 같이 proxy-target-class 애트리뷰트를 true로 바꿔주변 된다.

  &lt;tx:annotation-driven proxy-target-class=&quot;true&quot; /&gt;

  

- @Transactional은 클래스에 부여해야 한다.

  클래스 프록시는 일반적으로 인터페이스를 구현하지 않는 클래스에 주로 사용된다.
  하지만 원한다면 인터페이스가 있는 클래스에 클래스 프록시를 강제로 적용할 수도

  있다. 이때는 반드시 클래스에 @Transactional 을 부여해줘야 한다. 인터페이스에 붙인 @Transactional 애노태이션은 구현 클래스로 그 정보가 전달되지 않는다. 따라서 인터페이스에만 @Transactional 을 부여하고 클래스 프록시 모드로 바꾸면 트랜잭션이적용되지않는다.

  @Transactional 을 클래스에 부여하다고 해서 클래스 프록시가 적용되는 것은 아니다. **@Transactional 이 클래스에 있어도 타깃에 인터페이스가 있고 proxy-target-class 를 디폴트 값으로 그대로 뒀다면 인터페이스에 다이내믹 프록시가 적용되니 흔동하지 않도록 주의하자.**

  

- 클래스 프록시의 제약사항을 알아야 한다

  **클래스 프록시는 final 클래스에는 적용할 수 없다.** 클래스 프록시는 타깃 클래스를 상속해서 프록시를 만드는 방법을 시용하기 때문에 상속이 불기능한 final 클래스에 는적용되지않는다.
  **클래스 프록시를 적용하면 클래스의 생성자가 두 번 호출된다**. 상속을 통해 프록 시를 만들기 때문에 발생하는 현상인데 이 때문에 생성자에서 리소스를 할당하는것 같은 중요한 작업은 피하도록 해야 한다.

  

- 불필요한 메소드에 트랜잭션이 적용할 수 있다

  클래스 프록시 방식을 사용하면 클래스의 모든 public 메소드에 트랜잭션이 적용된다. 
  인터페이스를 이용히는 경우에는 인터페이스에 정의된 메소드로 트랜잭션 적용이 제한되지만 클래스에는그런 구분을 둘수 없다.
  
  **따라서 수정자 같은， 클라이언트가 사용하지는 않지만 public 으로 정의히는 메소드에도 트랜잭션이 적용되는 문제가 발생한다.** 
  물론 아무런 DB 작업이 없으므로 그냥 빈 트랜잭션이 시작됐다가 종료 되겠지만， 그만람 시간과 리소스에 낭비가 발생한다.
  
  

**클래스 프록시는 코드를 함부로 손댈 수 없는 레거시 코드나， 여타 제한 때문에 인터 페이스를 사용하지 못했을 경우에만 사용해야 한다.**
 **인터페이스를 만들기가 귀찮다고 클래스 프록시를 시용하는 것은 스프링의 개발철학에 맞지 않는다**. 
인터페이스를 사용 히는 이유는 단지 트랜잭션 AOP를 적용히는 것이 전부가 아니다.
 비록 스프링이 런타임 바이트코드 생성 기법을 지원히는 라이브러리를 이용해서 클래스에도 프록시를 적용하도록 해주고는 있지만 이 방법을 남용히는 건 바람직하지 않다.







### AOP 방식: 프록시와 AspectJ

스프링의 AOP는 기본적으로 프록시 방식이다. 
인터페이스를 이용핸 JDK 다이내믹 프록시든 클래스에 바로 프록시를 만드는 CGLib 이든, 모두 프록시 오브젝트를 타깃 오브젝트 앞에 두고 호출 과정을 가로채서 트랜잭션과 같은 부가적인 작업을 진행해준다.

스프링의 프록시 AOP 대신 AOP 전용 프레임워크인 AspectJ의 AOP를 시용할 수있다. 
AspectJ AOP는 스프링과 달리 프록시를 타깃 오브젝트 앞에 두지 않는다. 대신 타깃 오브젝트 자체를 조작해서 부가기능을 직접 넣는 방식이다. 마치 처음부터 타깃 오브젝트의 클래스에 부가기능을 가진 소스코드가 있었던 것처럼 만들어준다. 

AspectJ AOP는 그래서 매우 강력하다. 메소드 실행 지점만 조인 포인트로 사용할 수 있는 프록시 방식의 스프링 AOP 에서는 불가능한 다양한 조인 포인트와 고급 기능을 이용할 수있다. 
대신 별도의 빌드 과정이나 바이트코드 조작을 위한 로드타임 위버 설정과 같은 부가적인작업이 필요하다.

트랜잭션 AOP를 적용하기 위해 굳이 번거롭게 AspectJ를 사용할 필요는 없다.
AspectJ AOP를 스프링과 함께 애플리케이션 전반에 걸쳐서 사용하고 있는 경우라면 물론 고려해볼 수는 있다. 
또는 다음과 같은 프록시 AOP 의 제약사항을 극복하기 위해 서라면 도입을 검토해볼 필요가 있다.

Vo l. l 에서 자세히 살펴본 것처럼 프록시는 기능을 사용하려는 오브젝트인 클라이언트와 서비스를 제공하는 오브젝트인 타깃 오브젝트 사이에 데코레이터 패턴을 써서 투명하게 추가된다. 투명하다는 건 프록시가 추가되더라도 클라이언트와 타깃 오브젝트의 코드를 수정할 필요도 없고 기본 기능에도 영향을 주지 않는다는 뜻이다. 

그림 2-2 는 프록시가 적용되기 전과 후를 보여주고 있다. 프록시는 스프링 DI 의 도움을 받아서 클라이언트와 타깃 오브젝트 사이에 추가되고， 어드바이스가 제공해주는 부가적인 기능을 타깃 오브젝트의 메소드 호출 전후에 실행해준다.



''

![image-20210820231539343](C:\Users\ST\AppData\Roaming\Typora\typora-user-images\image-20210820231539343.png)

프록시가 적용되면 클라이언트는 프록시를 타깃 오브젝트라고 생각하고 프록시의 메소드를 호출한다. 프록시는 클라이언트로부터 요청을 받으면 타깃 오브젝트의 메소드로 위임해준다. 타깃 오브젝트에 위임히는 과정에서 부가작업을 추가할 수 있다. 
트랜잭션 AOP 에 의해 추가된 프록시라면 타깃 오브젝트 메소드 호출 전에 트랜잭션을 시작하고 호출 후에 트랜잭션을 커밋하거나 롤백해줄 것이다.

여기서 프록시는 클라이언트가 타깃 오브젝를 를 호출하는 과정에서만 동작한다는 점을 주목하자. 
**타깃 오브젝트의 메소드가 자기 자신의 다른 메 소드를 호출할 때 는 어떻게 될까? 이때 도 프록시가 동작할까? 그렇지 않다.**
이미 프록시를 거쳐서 타깃 오브 젝트까지 작업 이 진행됐으므로 타깃 오브젝트에 서 자신의 메 소드를 호출할 때 는 프록 시를 거치지 않는다. 
그림 2 -3 의 @은 클라이언트에서 프록시를 통해 들어온 호출이 다. 이때는 당연히 프록시의 기능이 동작한다. 하지만 @의 경우는 타깃 오브젝트 안에 서의 호출이 므로 프록시를 통하지 않고 직접 타깃 오브젝트의 메 소드로 호출이 일어 난다.

![2](C:\Users\ST\Downloads\2.PNG)

리스트 2-5 9는 트랜잭션 AOP가 적용된 서 비 스 계층 클래스의 코드다. add () 메 소드는 트랜잭션 전파 속성이 항상 새로운 트랜잭션을 만들어 시작하도록 REQUIRES_NEW로 되어 있다. 

따라서 다른 서비스 계층 오브젝트에서 트랜잭션이 시작된 후에 MemberService의 add () 메 소드가 호출되면 기존 트랜잭션은 잠시 중단되고 새로운 트랜잭션을 시작한다. MemberService 외의 오브젝트에 서 MemberS ervi ce 의 메 소드를 호출할 때는 항상 트랜잭션 프록시를 거쳐서 들어오기 때문에 메 소드에 설정해둔 트랜책션 속성이 정확히 적용된다.



리스트 2• 59 자신을 호출하는 타깃 오브젝트

~~~JAVA
@Transact ional public class MemberService {
    @Transactional(propagation=Propagation.REQUIRES_NEW) 
    public void add(Member m) { ... }
    
	public void complexWork() (
		this.add(new Member( .. . )) ;
	}
~~~

이번엔 클라이언트로부터 complexWork () 메 소드가 호출된 경우를 생각해 보자.

complexWork() 은 클래스 레벨 @Transactional 의 적용을 받으므로 complexWork() 이 호출되기 전에 프록시에서 트랜잭션을 시작할 것이다. 

**문제는 complexWork() 에서 add( )메소드를 호출할 때다.**

- 이때는 프록시를 지나서 이미 MemberService 빈의 오브젝트로 들어왔으므로 트랜잭션 프록시를 다시 거치지 않고 add () 메소드가 바로 실행된다.
- 그래서 이때는 add( ) 메소드의 트랜잭션 속성이 반영되지 못한다. add() 를 호출했음에도 새로운 트랜잭션이 생성되는 대신 complexWork() 에서 시작된 트랜잭션에 그냥 참여하게 될 뿐이다. 

결국 add( ) 메 소드에 별도의 트랜잭션 속성을 정의해놓아도 어떤 경로를 거쳐서 이 메소드가 호출되느냐에 따라서 해당 속성이 적용될 수도 있고 안 될 수도 있다.
 만약 complexWork() 이 트랜잭션이 아예 시작되지 않도록 설정된 메소드라면 add()가 호출되어도 트랜잭션이 시작되지 않은 채로 진행될 수밖에 없다.



타깃 오브젝트의 자기 호출에는 AOP 가 적용되지 않는다는 점이 프록시 AOP 의 한계다.
**이 문제를 해결해서 complexWork() 에서 같은 오브젝트의 add() 를 호출할 때도 트랜 잭션 프록시를 거치게 하고 싶다면 두 가지 방법을 고려해볼 수 있다.**

- AopContext.currentProxy()

  프록시 설정에서 현재 진행 중인 프록시를 노출하도록 설정해두면 스프링 API를 이용해서 현재 진행 중인 프록시를 가져올 수 있다. 이 기능을 이용하면 complexWork() **메소드에서 add() 를 바로 호출하는 대신 프록시를 통해 add() 메소드를 호출할 수있다. 사용 방법도 단순하고 효과적이지만 시용을 권장할 수는 없다.** 
  **스프링 A PI 가비즈니스 로직을 가진 POJO 클래스 코드에 등장한다는 문제와 더불어， 프록시를 통하지 않고는 아예 동작하지 않는 한심한 코드가 되기 때문이다.** 이 방법을 자세히 알고 싶다면 AopContext 클래스의 currentProxy() 메소드 API 문서를 참고하라.

- AspectJ AOP

  프록시 AOP 대신 AspectJ AOP를 사용하는 방법도 있다. 
  **AspectJ는 프록시 대신 클래스 바이트코드를 직접 변경해서 부가기능을 추가하기 때문에 타깃 오브젝트의 자기 호출 중에도 트랜잭션 부가기능이 잘 적용된다**. 
  굳이 자신의 메소드를 호출하는 경우에도 트랜잭션 속성이 정확히 적용되기를 원한다면 Aspec tJ를 사용하는 편이 좋다. 스프링에서 Aspec tJ를 사용하는 데 필요한 자세한 설정 방법은 5 장을 참고 하자.

@Transactional을 시용하는 경우에는 XML 설정에 다음 코드를 넣어주면 프록시 대신 AspectJ를 시용해 트랜잭션을 적용하게 할 수 있다. &lt;tx:annotation-driven&gt; 의 mode 애트리뷰트는 디폴트 값으로 proxy를 갖고 있다. 이 값을 apsectJ 로 변경해주면 된다.

&amp;lt;tx :annotation-driven mode=‘ aspectj'/)

Aspec tJ를 시용해 트랜잭션을 적용할 때는 앞에서 설명한 것처 럼 @Transctional 을클래스 레벨과 클래스 메소드 레벨에 부여해야 한다는 점을 주의하자. AspectJ코드를 사‘용하면서 인터페이스에만 @Transactional 을 부여하면 트랜잭션이 적용되지 않는 다.

 그래서 트랜잭션 코드가 변경될 수 있다는 점을 고려한다면 @Transactional 은 안전하게 클래스에만 붙여두는 게 좋다고 볼 수도 있다. 물론 이때도 인터페이스를 정의 하고 클라이언트는 인터페이스를 통해서만 접근하도록 만들어야 한다는 원칙은 지켜 야한다.





## 2.6.3 트랜잭션속성

모든 트랜잭션이 같은 방식으로 동작히는 건 아니다. 
전체가 같이 실패하거나 성공히는 하나의 작업으로 묶인다면 점에서는 다를 바 없겠지만， 세밀히 따져보면 몇 가지 차이점이 있다. 
스프링은 트랜잭션의 경계를 설정할 때 네 가지 트랜잭션 속성을 지정할 수있다. 또, 선언적 트랜잭션에서는 롤백과 커밋의 기준을 변경하기 위해 두 가지 추가 속성을 지정할 수 있다. 선언적 트랜잭션 기준으로 보자면 모든 트랜잭션 경계는 여섯 가지 속성을갖고 있는셈이다.
트랜잭션 속성의 지정은 tx/aop 스키마의 태그를 이용히눈 경우에는 리스트 2-60과 같이 &lt;tx:method&gt; 태그의 애트리뷰트로 지정할수 있다. &amp;lt;tx: method&amp;gt; 의 애트리뷰트는 메소드 이름 패턴을 담은 name 애트리뷰트를 제외하면 모두 디폴트 값이 정의되어 있으 므로생략가능하다.



리스트 2-30 &amp;lt;tx:method〉를 이용한 트랜잭션 속성 지정

~~~xml
&lt;tx:attributes&gt;
&lt;tx:method name=&quot;&quot;&gt;
&amp;lt;read-only=&quot;&quot;&amp;gt;&amp;lt;/read-only&amp;gt;
&amp;lt;isolation=&quot;&quot; &amp;gt;&amp;lt;/read-only&amp;gt;
&amp;lt;propagation= &quot;&quot;&amp;gt;&amp;lt;/propagation&amp;gt; 
&amp;lt;timeout= &quot;&quot;&amp;gt;
&amp;lt;rollback-for=&quot;&quot;&amp;gt;&amp;lt;/rollback-for&amp;gt;
&amp;lt;no-rollback-for=&quot;&quot;/&amp;gt;
                  
&amp;lt;/tx:attributes&amp;gt;
~~~

@Transactional을 이용했을 때는 리스트 2-61 과 같이 애노테이션의 엘리먼트로 트랜잭션 속성을 지정할 수 있다.

리스트 2--61 @Transactional율 이용한 트랜잭션 속성 지정

~~~java
@Transactional(readOnly=.
isolation= .. . ,
propagat lOn= .
tlmeout= ... ,
rollbackFor= . .. , rollbackForClassName= . .. ,
noRollbackFor= ... , noRollbackForClassName= ... )
~~~

모든 엘리먼트는 디폴트 값이 정의되어 있으므로 생략 기능하다. 이제 트랜잭션 속성에 대해 자세히 알아보자.





### 트랜잭션 전파: propagation

이제 트랜잭션을 시작하거나 기존 트랜잭션에 참여히는 방법을 결정하는 속성이다. 선언적 트랜잭션 경계설정 방식의 장점은 여러 트랜잭션 적용 범위를 묶어서 커다란 트랜잭션 경계를 만들 수 있다는 점이다. 
트랜잭션 경계의 시작 지점에서 트랜잭션 전파 속성을 참조해서 해당 범위의 트랜잭션을 어떤 식으로 진행시킬지 결정할 수 있다.
스프링이 지원히는 트랜잭션 전파 속성은 다음 여섯 가지가 있다. 모든 속성이 모든 종류의 트랜잭션 매니저와 데이터 액세스 기술에서 다 지원되진 않음을 주의해야 한다.
각 트랜잭션 매니저의 API 문서에는 사용 가능한 트랜잭션 전파 속성이 설명되어 있으니 사용하기 전에 쪽 참고해봐야 한다.
&lt;tx:method&gt; 에서는 propagation 애트리뷰트 값으로 @Transactional 에서는 propagationn 엘리먼트로 지정한다. propagation 엘리먼트의 이늄 값은 org.springframework.transaction.annotation.Propgation 에 정의된 것을 시용한다.

- REQUIRED

  디폴트 속성이다. 모든 트랜잭션 매니저가 지원하며 대개 이 속성이면 충분하다.
  미리 시작된 트랜잭션이 있으면 참여하고 없으면 새로 시작한다. 자연스럽고 간단한 트랜잭션 전파 방식이지만 사용해보면 매우 강력하고 유용하다는 사실을 알 수 있다. 하나의 트랜잭션이 시작된 후에 다른 트랜잭션 경계가 설정된 메소드를 호출하면 자연스럽게 같은 트랜잭션으로 묶인다.

  

- SUPPORTS

  이미 시작된 트랜잭션이 있으면 참여하고 그렇지 않으면 트랜잭션 없이 진행하게 만든다. 트랜잭션이 없긴 하지만 해당 경계 안에서 Connection 이나 하이버네이트 Session 등을공유할수 있다.

  

- MANDATORY

  REQUIRED와 비슷하게 이미 시작된 트랜잭션이 있으면 참여한다. 반면에 트랜잭션이 시작된 것이 없으면 새로 시작하는 대신 예외를 발생시킨다. 혼자서는 독립적으로 트랜잭션을 진행하면 안 되는 경우에 사용한다.

  

- REQUIRES NEW

  항상 새로운 트랜잭션을 시작한다. 이미 진행 중인 트랜잭션이 있으면 트랜잭션을 잠시 보류시킨다. JTA 트랜잭션 매니저를 사용한다면 서버의 트랜잭션 매니저에 트랜잭션 보류가 가능하도록 설정되어 있어야한다

  

- NOT SUPPORTED

  트랜잭션을 사용하지 않게 한다. 이미 진행 중인 트랜잭션이 있으면 보류시킨다.

  

- NEVER

  트랜잭션을 사용하지 않도록 강제한다. 이미 진행 중인 트랜잭션도 존재하면 안 된다. 있다면 예외를 발생시킨다.



- NESTED

  이미 진행 중인 트랜잭션이 있으면 중첩 트랜잭션을 시작한다. 중첩 트랜잭션은 트랜잭션 안에 다시 트랜잭션을 만드는 것이다. 
  
  하지만 독립적인 트랜잭션을 만드는 REQUIRES_NEW와는 다르다.
  **중첩된 트랜잭션은 먼저 시작된 부모 트랜잭션의 커밋과 롤백에는 영향을 받지만 자신의 커밋과 롤백은 부모트랜잭션에게 영향을주지 않는다.** 
  예를들어 어떤중요한 작업을 진행히는 중에 작업 로그를 DB 에 저장해야 한다고 해보자. 그런데 로그를 저장하는 작업이 실패하더라도 메인 작업의 트랜잭션까지 롤백해서는 안 되는 경우가 있다. 힘들게 처리한 시급한 작업을 단지 로그를 남기는 작업에 문제가 있다고 모두 실패로 만들 수는 없기 때문이다. 
  반면에 로그를 남긴 후에 핵심 작업에서 예외가 발생한다면 이때는 저장한 로그도 제거해야 한다. 
  바로 이럴 때 로그 작업을 메인 트랜잭션에서 분리해서 중첩 트랜잭션으로 만들어두면 된다. 
  **메인 트랜잭션이 롤백되면 중첩된 로그 트랜잭션도 같이 롤백되지만， 반대로 중첩된 로그 트랜잭션이 롤백 돼도 메인 작업에 이상이 없다면 메인 트랜잭션은 정상적으로 커빗된다.**
  중첩 트랜잭션은 JDBC 3.0 스펙의 저장포인트savepoint를 지원핸 드라이버와 DataSourceTransactionManager를 이용할 경우에 적용 가능하다. 
  **또는 중첩 트랜잭션을 지원하는 일부 WAS 의 JTA 트랜잭션 매니 저를 이용할 때도 적용할 수 있다. 유용한 트랜잭션 전파 방식이지만 모든 트랜잭션 매니저에 다 적용 가능한 건 아니므로，적용하려면 사용할 트랜잭션 매니저와 드라이버. WAS 의 문서를 참조해보고 미리 학습 테스트를 만들어서 검증해봐야한다.**





### 트랜잭션 격리수준: isolation

트랜잭션 격리수준은 동시에 여러 트랜잭션이 진행될 때에 트랜잭션의 작업 결과를 여타 트랜잭션에게 어떻게 노출할 것인지를 결정히는 기준이다. 
스프링은 다음 다섯 가지 격리수준속성을지원한다. 격리수준은 (tx:method) 의 isolation 애트리뷰트와 @Transactional 의 isolation
엘리먼트로지정할수있다 .

- DEFAULT

  사용하는데이터 액세스기술또는 DB 드라이버의 디폴트설정을따른다. 보통 드라이버의 격리수준은 DB 의 격리수준을 따르는 게 일반적이다. 
  대부분의 DB는 READ_COMMITTED를 기본 격리수준으로 갖는다. 하지만 일부 DB는 디폴트 값이 다른 경우도 있으므로 DEFAULT를 사용할 경우에는 드라이버와 DB 의 문서를 참고해서 디폴트 격리수준을확인해야한다 .

  

- READ UNCOMMITTED

  가장 낮은 격리수준이다. 하나의 트랜잭션이 커밋되기 전에 그 변화가 다른 트랜잭션에 그대로 노출되는 문제가 있다. 하지만 가장 빠르기 때문에 데이터의 일관성이 조금 떨어지더라도 성능을 극대화할 때 의도적으로 사용하기도 한다.

  

- READ COMMITTED

  실제로 가장 많이 사용되는 격리수준이다. 물론 스프링에서는 DEFAULT로 설정해둬도 DB 의 기본 격리수준을 따라서 READ_COMMITTED로 동작히는 경우가 대부분이므로 명시적으로 설정하지 않기도 한다. **READ_UNCOMMITTED와 달리 다른 트랜잭션이 커밋하지 않은 정보는 읽을 수 없다.** **대신 하나의 트랜잭션이 읽은 로우를 다른 트랜잭션이 수정할 수 있다.** **이 때문에 처음 트랜잭션이 같은 로우를 다시 읽을 경우 다른 내용이 발견될수있다 .**

  

- REPEA TABLE READ

  **하나의 트랜잭션이 읽은 로우를 다른 트랜잭션이 수정하는 것을 막아준다.** **하지만 새로운 로우를 추가하는 것은 제한하지 않는다.** 따라서 SELECT로 조건에 맞는 로우를 전부 가져오는 경우 트랜잭션이 끝나기 전에 추가된 로우가 발견될 수 있다.

  

- SERIALlZABLE

  가장 강력한 트랜잭션 격리수준이다. **이름 그대로 트랜잭션을 순차적으로 진행시켜 주기 때문에 여러 트랜잭션이 동시에 같은 테이블의 정보를 액세스하지 못한다.** 가장 안전한 격리수준이지만 가장 성능이 떨어지기 때문에 극단적으로 안전한 작업이 펼요한 경우가 아니라면 자주 사용되지 않는다.



### 트랜잭션 제한시간: timeout

이 속성을 이용하면 트랜잭션에 제한시간을 지정할 수 있다. 값은 초 단위로 지정한다.
디폴트는 트랜잭션 시스템의 제한시간을 따르는 것이다. 트랜잭션 제한시간을 직접 지정하는 경우 이 기능을 지원하지 못하는 일부 트랜잭션 매니저는 예외를 발생시킬 수있다.
XML에서는 &amp;lt;tx:method) 의 timeout 애트리뷰트를 이용하고 @Transactional 애노 테이션에서는 timeout 엘리먼트로 지정할 수 있다.



### 읽기전용 트랜잭션: read-only. readOnly

트랜잭션을 읽기전용으로 설정할 수 있다. 성능을 최적화하기 위해 사용할 수도 있고 특정 트랜잭션 작업 안에서 쓰기 작업이 일어나는 것을 의도적으로 방지하기 위해 사용할 수도 있다. 트랜잭션을 준비하면서 읽기전용 속성이 트랜잭션 매니저에게 전달된다.
그에 따라 트랜잭션 매니저가 적절한 작업을 수행한다. 그런데 일부 트랜잭션 매니저의 경우 읽기전용 속성을 무시하고 쓰기 작업을 허용할 수도 있기 때문에 주의해야 한다.

일반적으로는 읽기전용 트랜잭션이 시작된 이후 INSERT, UPDATE , DELETE 같은 쓰기 작업이 진행되면 예외가 발생한다.
aop/tx 스키마로 트랜잭션 선언을 할 때는 이름 패턴을 이용해 읽기전용 속성으로 만드는 경우가 많다. 보통 get 이나 find 같은 이름의 메소드를 모두 읽기전용으로 만들어 시용하면 편리하다. @Transactional 의 경우는 각 메소드에 일일이 읽기전용 지정을 해줘야한다.
read-only 애트리뷰트 또는 readOnly 엘리먼트로 지정한다.



### 트랜잭션 롤백 예외: rollback-for, rollbackFor, rollbackForClassName

**선언적 트랜잭션에서는 런타임 예외가 발생하면 롤백한다.** 
**반면에 예외가 전혀 발생하지 않거나 체크 예외가 발생하면 커밋한다.**
체크 예외를 커밋 대상으로 삼은 이유는 체크 예외가 예외적인 상황에서 사용되기보다는 리턴 값을 대신해서 비즈니스적인 의미를 담은 결과를 돌려주는 용도로 많이 사용되기 때문이다. 
스프링에서는 데이터 액세스 기술의 예외는 런타임 예외로 전환돼서 던져지므로 런타임 예외만 롤백 대상으로 삼은 것이다.
하지만 원한다면 기본 동작방식을 바꿀 수 있다. 
**체크 예외지만 롤백 대상으로 삼아야 히는 것이 있다면 XML의 rollback-for 애트리뷰트나 애노태이션의 rollbackFor 또는 rollbackForClassName 엘리먼트를 이용해서 예외를 지정하면 된다.**

rollback-for 나 rollbackForClassName은 예외 이름을 넣으면 되고, rollbackFor는 예외 클래스를 직접 넣는다.
&lt;tx:method&gt; 라연 다음과 같이 지정하면 된다.
&amp;lt;tx:method name=&quot;get*“ read-only=&quot;true&quot; rollback-for=&quot;NoSuchllemberException&quot;/&amp;gt;
@Transactional 에서는 다음과 같이 클래스 이름 대신 클래스를 직접 사용해도 된다.
@Transactional(readOnly=true , rollbackFor쾌oSuchllemberException.class)



### 트랜잭션 커밋 예외: no-rollback-for, noRollbackFor, noRollbackForClassName

rollback-for 속성과는 반대로 기본적으로는 롤백 대상인 런타임 예외를 트랜잭션 커밋 대상으로 지정해준다.
사용 방법은 rollback-for와 동일하다.







**이 여섯 가지 트랜잭션 속성은 모든 트랜잭션 경계설정 속성에 사용할 수 있다. 하지만 모든 트랜잭션마다 일일이 트랜잭션 속성을 지정하는 건 매우 번거롭고 불편한 일이다.** 
세밀하게 튜닝해야 하는 시스템이 아니라면 메소드 이름 패턴을 이용해서 트랜잭션 속성을 한 번에 지정하는 aop/tx 스키마 태그 방식이 편리하다. 보통은 read-only 속성 정도만 사용하고 나머지는 디폴트로 지정하는 경우가 많다. 세밀한 속성은 DB나 WAS 의 트랜잭션 매니저의 설정을 이용해도 되기 때문이다.
**세밀한 트랜잭션 속성 지정이 필요한 경우에는 @Transactional 을 사용히는 편이 좋다. 대신 트랜잭션 속성이 전체적으로 어떻게 지정되어 있는지 한눈에 보기 힘들다는 단점이 있고， 개발자가 코드를 만들 때 트랜잭션 속성을 실수로 잘못 지정히는 등의 위험이 있기 때문에 사전에 트랜잭션 속성 지정에 관한 정책이나 가이드라인을 잘 만들어 둬야한다.**













## 2.6.4 데이터 액세스 기술 트랜잭션의 통합

스프링은 자바의 다양한 데이터 액세스 기술을 위한 트랜잭션 매니저를 제공해준다. 트랜잭션 매니저를 빈으로 등록하고 선언적인 방식의 트랜잭션 관리 기능에서 사용하게 한다. 
트랜잭션 매니저 빈의 이름은 관례적으로 transactionManager를 사용한다. 트랜잭션 매니저 를 참조하는 전용 태그에서는 참조 애트리뷰트에  이름이 디폴트로 선언 되어 있기 때문에 생략할수도 있다. 
여러 개의 DB를 독립적으로사용하지 않는한 트랜잭션 매니저는 한 개만 사용할수 있다.
**그런데 DB는 하나이지만 두 가지 이상의 데이터 액세스 기술을 동시에 사용하는 경우는 어떨까?** 
예를 들면 각각 JDBC와 iBatis로 만든 DAO를 동시에 사용한다거나, jPA와 JDBC 또는 하이버네이트와 iBatis를 함께 사용하는 경우는 어떨까? 
여기서 함께 시용한다는 건， 두 개 이상의 기술을 사용해서 만든 DAO를 하나의 트랜잭션 안에서 사용한다는 뜻이다. 
예를 들면 jPA DAO로 일부 엔티티-테이블을 업데이트히는 것과 JDBC DAO로는 복잡한 DB 전용 쿼리를 사용해 데이터를 가져오는 것을 하나의 트랜 잭션 안에서 진행시키고 싶을 수 있다.

**물론 가능하면 애플리케이션의 데이터 액세스 기술과 방식은 한 가지로 통일하는 게좋다. 하지만 때로는 두 가지 이상의 데이터 액세스 기술을 혼합해서 사용해야 할 경우도 없지 않다.** 
현재 사용히는 데이터 액세스 기술과는 다른 기술을 시용하는 다른 시스 탱에서 개발된 DAO를 가져와 시용하고 싶을 수도 있고 jPA 나 하이버네이트를 기본 적으로 사용하지만 DB 전용 네이티브 SQL을 시용하고 싶은 경우도 있다. 

물론 jPA나 하이버네이트에서도 일반 SQL을 사용해 쿼리를 작성할 수 있다. 하지만 SQL을 본격 적으로 사용하려고 하면 iBatis 나 스프링 JDBC를 사용하는 것이 편리하다.
스프링은 두 개 이상의 데이터 액세스 기술로 만든 DAO를 하나의 트랜잭션으로 묶어서 사용하는 방법을 제공한다. 물론 이때도 DB 당 트랜잭션 매니 저는 하나만 사용한 다는 원칙은 바뀌지 않는다. 대신 하나의 트랜잭션 매니저가 여러 개의 데이터 액세스 기술의 트랜잭션 기능을 지원해주도록 만드는 것이다.









### 트랜잭션 매니저별 조합 가능 기술

트랜잭션 통합이 가능한 데이터 액세스 기술의 조합을 살펴보자. 
트랜잭션 매니저는 하나만 사용되므로 각 트랜잭션 매니저별로 사용 가능한 기술을 알고 있으면 적절한 기술과 트랜잭션 매니저의 선택이 가능할 것이다.

- DataSourceTransactionManager

  DataSourceTransactionManager를 트랜잭션 매니저로 등록하면 JDBC와 iBatis 두가지 기술을 함께 사용할 수 있다. 
  트랜잭션을 통합하려면 항상 동일한 DataSource를 사용해야 한다는 점을 잊지 말자.
  그림 2-4는 두 가지 기술이 적용된 빈과 DataSource 트랜잭션 매니저의 의존관계다. JDBC DAO와 iBatis DAO 가 같은 DataSource를 사용하도록 만들어주기만 하면 된다. **DataSourceTransactionManager는 DataSource로부터 Connection 정보를 가져와 같은 DataSource를 사용하는 JDBC DAO와 iBatis DAO 작업에 트랜잭션 동기화 기능을 제공한다.**

![3](C:\Users\ST\Downloads\3.PNG)







- JpaTransactionManager

  JPA 의 트랜잭션은 JPA API를 이용해 처리된다. 따라서 기본적으로는 JPA 단독으로 트랜잭션을 관리하게 된다. 그런데 스프링에서는 JPA 의 EntityManagerFactory가 스프링의 빈으로 등록된 DataSource를 사용할 수 있다. 
  그리고 이 DataSource를 JDBC DAO 나 iBatis DAO 에서도 시용할 수 있다. 
  **이렇게 같은 DataSource를 공유하게 해 주변 JPA 의 트랜잭션을 담당하는 JpaTransactionManager 에 의해 세 가지 기술을 이용하는 DAO 작업을 하나의 트랜잭션으로 관리해줄 수 있다.**
  JpaTransactionManager를 통해 JPA 가 사용하는 트랜잭션을 같은 DataSource를 의존하고 있는 JDBC DAO와 iBatis DAO 에 동기화해주는 것이다.
  그림 2-5 는 JpaTransactionManager를 사용할 때 세 가지 기술의 DAO 가 하나의 트랜잭션으로 통기화되는 구조를 나타낸다. **JpaTransactionManager 는 직접 DataSource 를 의존하고 있지는 않지만 EntityManagerFactory 가 사용하는 DataSource를 이용해 트랜잭션 동기화를 해준다. 이 덕분에 같은 DataSource를 사용하는 JDBC , iBatis DAO와도 트랜잭션을 통합할 수 있는 것이다.**

![4](C:\Users\ST\Downloads\4.PNG)

- HibernateTransactionManager

  하이버네이트 DAO를 사용한다면 HibernateTransactionManager를 트랜잭션 매니저로 등록해야 한다. HibernateTransactionManager도 JpaTransactionManager
  와 통일한 방식을 이용해서 SessionFactory와 같은 DataSource를 공유하는 JDBC , iBatis DAO와 트랜잭션을 공유하게 해준다. 따라서 하이버네이트 JDBC, iBatis 세 가지 기술의 DAO를 통합해서 사용할 수 있다.
  그림 2-5 에서 EntityManagerFactory 대신 SessionFactory 를，
  JpaTranasctionManager 대신 HibernateTransactionManager를 대입하면 그 구조와 의존관계를 파악할 수 있을 것이다



- JtaTransactionManager

  서버가 제공히는트랜잭션 서비스를 JTA를통해 이용하면 모든종류의 데이터 액세스 기술의 DAO 가 같은 트랜잭션 안에서 동작하게 만들 수 있다. 
  JTA는 같은 DB 에대해 다른 기술을 시용할 때뿐 아니라 다른 DB를 사용하는 DAO도 하나의 트랜잭 션으로 묶어줄 수 있다. 
  가장 강력하고 펀리한 기능이지만 JTA 서버환경을 구성해야 하고 서버의 트랜잭션 매니저와 XA를 지원하는 특별한 DataSource를 구성하는 등의 부가적인 준비 작업이 필요하다.
  단지 하나의 DB 를 사용하는 여러 가지 기술의 트랜잭션을 통합하려고 한다면 JTA를 사용해야 할 이유는 없다. 반면에 하나 이상의 DB 또는 JMS와 같은 트랜잭션이 지원되는 서비스를 통합해서 하나의 트랜잭션으로 관리하려고 할 때는 JTA 가반드시필요하다.





### ORM과 비 ORM DAO를 함께 사용할 때의 주의사항

JPA나 하이버네이트 같은 엔티티 기반의 ORM 기술과 JDBC , iBatis 같은 SQL 기반의 비 ORM 기술을 함께 시용하고 하나의 트랜잭션으로 묶어서 시용하는 것은 기술적 으로 볼 때 아무런 문제가 없다. 
하지만 각 기술의 특정을 잘 이해하지 않으면 예상치 못한 오류를 만날 수 있다.
JPA와 JDBC를 사용해서 만든 리스트 2-62 와 리스트 2-63 같은 두 개의 DAO 가있다고해보자.

리스트 2-62 JPA DAO

~~~JAVA
public class MemberJpaDao (
 @PersistenceContext EntityManager entityManager;
public void add(Member m) {
    entityManager.persist(m);
}
}
~~~

리스트 2-63 JDBC DAO

~~~JAVA
public class MemberJdbcDao extends JdbcDaoSupport {
    
SimpleJdbclnsert insert;
protected void initTemplateConfig() {
    insert = new SimpleJdbclnsert(getDataSource()).withTableName( &quot;TEST&quot; );
public void add(Member m) {
	insert.execute(new BeanPropertySqlParameterSource(m));
}
public long count() {
    return getJdbcTemplate().queryForObject(&quot;select count(*) from member&quot; , Long.class).longValue();}
}
~~~



각기 다른 기술을 사용하는 이 두 개의 DAO가 하나의 트랜잭션 안에서 동작하도록 설정해준다. 
그리고 리스트 2-64와 같은 코드를 트랜잭션 안에서 실행하면 어떤 결과가 나올지예측해보자.

리스트 2-34 두 개의 DAO를 사용하는 코드

~~~java
jdbcDao.add(new Member(l , &quot;Spring&quot; , 1.2));
jpaDao.add(new Member(2, &quot;Jpa&quot; , 1.2));
int count = jdbcDao .count();
~~~

먼저 JDBC DAO를 시용해서 Member 하나를 추가하고 다음은 JPA DAO를 이용해서 또 다른 Member를 추가했다. 그러고 나서 Member 태이블의 로우의 개수를 가져오는 쿼리를 이용해서 등록된 Member 의 개수를 가져왔다. Member를 두 번 추가했으니 처음에 테이블이 비어 있었다면 당연히 count 는 2 가 돼야 한다. 

**하지만 이 코드를 실행해보면 count 에 1이 들어 있음을 알게 된다.** 
같은 트랜잭션 안에서 동작하게 했고 각각 INSERT 문장을 실행히는 메소드를 호출했는데 왜 두 번 추가한 Member 의 개수가 1 이라고 나오는것일까?
그 이유는 JPA와 같은 ORM과 JDBC API를 직접 사용하는 비 ORM 의 특성이 다르기 때문이다.
JPA 나 하이버네이트는 단순히 JDBC API 를 간접적으로 실행해주는 방식이 아니다.
물론 jPA 나 하이버네이트에서 새로 만든 오브젝트에 영속성을 부여해주변 결국 INSERT 문이 생성돼서 DB로 전달되기는 할 것이다. 
하지만 영속성을 부여하는 persist() 나 save( ) 같은 메소드를 호출한다고 바로 DB 에 INSERT SQL이 전달되는 것이 아니다.
JPA 나 하이버네이트는 새로 등록된 오브젝트를 일단 엔티티 매니저나 세션에만 저장해 둔다. 

**엔티티 매니저나 세션을 1 차 캐시라고도 부르기 때문에 이렇게 저장해두는 것을 캐싱caching한다고 말하기도 한다. 캐싱을 한다는 의미는 DB 에 INSERT하는 것을 최대한 지연시킨다는 뜻이다.**

일단 persist() 로 등록했지만 트랜잭션이 끝나기 전에 다시 변경될 수도 있기 때문이다. 따라서 DB 에 동기화가 필요한 시점, 예를 들어 트랜잭션이 종료되거나 등록된 엔티티가 반영돼야만 정상적인 결과가 나올 수 있는 쿼리가 실행될 때까지는 실제 DB로 등록하는 것을 지연시키는 기법을 사용한다. 간단한 캐시이긴 하지만, 나름 성능 향상을 가져올 수 있고 코드를 유연하게 만들 수 있는 유용한 방법이다.
문제는 이 때문에 MemberJpaDao 의 add() 에서 entityManager.persist() 를 실행했다고 해도 바로 DB 에는 INSERT 문이 전달되지 않는다는 점이다. 
**단지 메모리의 캐시에 저장되어 있을 뿐이다. JPA 입장에서는 작업이 모두 끝나고 트랜잭션이 커밋되는 순간**
**INSERT 문을 만들어 DB 에 저장을 시도할 것이다.**
그런데 JDBC 에서는 lPA 의 그런 사정을 알지 못한다. 따라서 JDBC는 count() 메소드가 실행되면 그 순간 DB 에 바로 조회용 SQL을 보내서 현재 테이블에 등록된 로우의 개수를 가져온다. 따라서 lPA 의 캐시에만 있고 DB 에는 반영되지 않은 두 번째 add() 의 결과는 나타나지 않는 것이다.
원래 lPA 나 하이버네이트는 JDBC 등과 함께 사용하도록 설계된 게 아니기 때문에 이런 문제가 발생한다. 따라서 ORM과 비 ORM 기술을 함께 사용할 때 상당히 주의를 기울여야 한다. DAO를 이용하는 서비스 계층의 코드는 사실 DAO 가 어떤 기술로 만들어졌는지를 알지 못한다. 따라서 별 의심 없이 위와 같은 코드를 그냥 작성해버리기 쉽다.

그렇다면 이 문제를 어떻게 풀어야 할까?
해결 방법은 한 가지뿐이다. lPA나 하이버네이트의 I 차 캐시에 저장됐지만 DB 에는 아직 반영되지 않은 엔티티가 있다면 관련 테이블을 참조하는 JDBC DAO나 iBatis DAO를 바로 이용하면 안 된다. 따라서 JDBC DAO의 쿼리를 사용하려면 JPA나 하이버네이트의 1차 캐시의 내용을 먼저 DB 에 반영해야 한다.
**가장 단순한 해결책은 lPA 의 저장이나 수정 작업을 한 후에는 강제로 캐시의 내용을 DB로 보내주는 EntityManager나 Session 의 flush() 메소드를 사용하는 것이다. 리스트 2-65 에서는 MemberJpaDao 의 메소드를 이 방식으로 동작하도록 수정했다.**



리스트 2-35 flush() 사용

~~~java
public void add(Member m) {
    entityManager.persist(m);
	entityManager.flush();
}
~~~

**flush( ) 메소드는 현재 캐시의 내용을 즉시 DB 에 반영한다.** 
따라서 JDBC DAO 의 add( ) 메소드를 실행했을 때처럼 바로 INSERT 문이 DB로 전달되어 새로운 레코드가 추가된다. 
**이렇게 해두면 이후에 JDBC DAO에서 Member 테이블에 count() 쿼리를 실행 해도 JPA 에서 진행한 작업까지 모두 반영된 결과를 가져올 수 있다.**

이렇게 add() 나 merge( ) 등에서 항상 flush( )를 사용하도록 만들면 간단히 문제를 해결할 수 있긴 하지만, 
**반면에 jPA나 하이버네이트 입장에서는 1차 캐시의 장점을 희생해야 한다.** 
**JDBC DAO를 함께 사용하지 않고 jPA만 사용히는 비즈니스 로직에서도 항상 flush( )를 쓴다는 것은 손해다.** 
또， JPA나 하이버네이트에서는 persist() 나 merge( )를 명시적으로 호출하지 않아도 DB 에서 가져온 엔티티 오브젝트는 필드를 수정하는 것만으로도 UPDATE 가 일어나는 수정이 된다는 문제가 있다. 

이런 경우에도 의도 적으로 flush() 를 수행해줘야 한다. 따라서 코드가 지저분해질 뿐만 아니라， DAO의 시용 기술을 의식해서 서비스 계층의 코드를 만들어야 한다는 문제점도 있다.
**또 다른 접근 방법은 JDBC 의 DAO 가 호출될 때 JPA 나 하이버네이트의 캐시를 flush( ) 하도록 만들어주는 것이다.** 

AOP를 이용하면 lPA/하이버네이트 캐시의 flush( )를 호출해주는 부가기능을 JDBC DAO 에 간단히 추가해줄 수 있다. 이렇게 해두면 **JDBC DAO를 시용하지 않고 JPA DAO만 이용하는 경우에는 jPA 캐시를 효과 적으로 활용할 수 있고， JDBC DAO를 함께 사용할 때도 데이터의 정확성을 보장해줄 수있다.**





## 2.6.5 JTA를 이용한 글로벌/분산 트랜잭션

한 개 이상의 DB 나 JMS 의 작업을 하나의 트랜잭션 안에서 동작하게 하려면 서버가 제공히는 트랜잭션 매니저를 JTA를 통해 사용해야 한다. 
스프링에서는 서버에 설정해둔 XA DataSource와 트랜잭션 매니저 그리고 UserTransaction 등을 JNDI를 통해 가져와 모든 데이터 액세스 기술에서 사용할 수 있다. 
JTA와 분산/글로벌 트랜잭션을 사용하기 위한 설정은 자바서버마다 다르므로 해당 서버의 매뉴얼을 참고해서 등록하는 방법을 알아둬야한다.

리스트 2-66 JTA를 적용한 설정

~~~xml
&amp;lt;jee: jndi -lookup id=&quot;dataSource1&quot; jndi-name=&quot;jdbc/xaDS1&quot; /&amp;gt;
&lt;bean id=&quot;memberDao&quot; class=&quot; ... MemberDao&quot;&gt; 
	&lt;property name=&quot;dataSource&quot; ref=&quot;dataSource1&quot; /&gt;
&lt;/bean&gt;

&lt;jee:jndi-lookup id=&quot;dataSource2&quot; jndi-name=&quot;jdbc/xaDS2&quot; /&gt; 
	&lt;bean id=&quot;usageDao&quot; 뎌=&quot;&quot; c=&quot;&quot; lass=&quot; ....UsageDao.. &quot;&gt;
		&lt;property name=&quot;dataSource&quot; ref=&quot;dataSource2&quot; /&gt; 
	&lt;/bean&gt;


&lt;bean id=&quot;txManager&quot; class=&quot;org. springframework.transaction.jta.JtaTransactionManager&quot; /&gt;
~~~



이 설정에는 두 개의 DataSource 타입 빈이 등장한다. **이 두 개의 DataSource 빈은 스프링 안에서 만들어지는 게 아니라 서버에서 제공해주는 DataSource를 JNDI로 가져온 것이다**. 
**서버에는 분산 트랜잭션을 위한 XA 프로토콜을 지원하는 XA DataSource 두 개가 jdbc/xaDSl 과 jdbc/xaDS2 라는 JNDI 이름으로 둥록되어 있어야 한다.** 

이 두개의 DataSource를 사용하는 DAO도 각각 등록해준다. DAO 의 데이터 액세스 기술은 어떤것이든상관없다.
마지막으로 JtaTransactionManager를 빈으로 등록한다. 
JtaTransactionManager는 여타 트랜잭션 매니저와는 다르게 프로퍼티로 DataSource 나 SessionFactory 등의 빈을 참조하지 않는다. 

대신 서버에 등록된 트랜잭션 매니저를 가져와 JTA를 이용해서 트랜잭션을 관리해줄 뿐이다. 이미 서버의 JTA 서비스에는 JNDI로 가져온 두 개의 XA DataSource 가 등록되어 있을 것이다. JTA는 서버에서 미리 설정해두기만 하면 스프링 에서 사용하는 것은 어떤 트랜잭션 매니저보다 간단하다.

**JtaTransactionManager는 JNDI 를 통해 JTA TransactionManager 와 JTAUserTransaction을 찾아온다.** 
이때 사용하는 JNDI 이름은 WAS 에서 자주 사용되는 기본적인 이름을 이용한다.
UserTransaction은 &quot;java:comp/UserTransaction&quot; 을 사용하고， 
TransactionManager는 &quot;java:comp/TransactionManager&quot; , &quot;java:appserver/TransactionManager&quot; ’&quot;java:pm/TransactionManager&quot; ’ &quot;java: /TransactionManager&quot; 네 가지 이름을 시도해서 가장 먼저 발견되는 것을 사용한다.
기본 이름이 아닌 JNDI 이름으로 UserTransaction 이나 TransactionManager 가 등록되어 있다면 JtaTransactionManager 의 transactionManagerName 과 userTransactionName 프로퍼티를 이용해서 JNDI 이름을 지정해줘야 한다.





### 독립형 JTA 트랜잭션 매니저

JTA는 WAS 가 제공하는 서비스를 이용하는 경우가 일반적이지만, 원한다면 서버의 지원 없이도 애플리케이션 안에 JTA 서비스 기능을 내장허는 독립형 JTA 방식으로 이용할 수 있다. 

**이 방식을 사용하면 JTA를 지원히는 WAS 가 아닌 톰켓과 같은 서블릿 컨테이너에서도 JTA 기능을 이용하는 것이 가능하다**. 

**서버에 포함돼서 서비스로 동작하는 것은아니지만 JTA의 다중트랜잭션 리소스를 위한글로벌 트랜잭션 기능을활용할수 있다.** 

- 스프링 안에서 간단한 설정을 추가하는 것만으로 JTA 의 기능을 시용할 수 있다는 점에서 매력적이다.
  독립형 JTA 트랜잭션 매니저는 ObjectWeb의 JTA 엔진인 JOTM 과 Atomikos의 TransactionalEssentials가 대표적이다. 
  두가지 모두 오픈소스 제품이므로 자유롭게 가져다 쓸 수 있다. Atomikos 에서는 오픈소스 외에도 고급 기능을 가진 상용 제품인 ExtremeTransactions를 판매하기도 한다.

  

이 두 가지 모두 스프링의 JtaTransactionManager와 결합해서 JTA 트랜잭션 서비스로 사용할수있다.
Atomikos 의 TransactionalEssentials를 스프링에 적용한 예를 살펴보자.
**먼저 리스트 2-67 과 같이 Atomikos 의 JTA TransactionManager 와 JTA UserTransaction을 빈으로 등록한다.** 
**이 두 가지 JTA 서비스는 서버에서 제공해주지 않기 때문에 스프링의 빈으로 등록해서 서비스를 이용해야 한다.** 

스프링의 트랜잭션 매니저와 여기서 사용한 JTA 트랜잭션 매니저는 다른 것이므로 혼동해서는 안 된다. 
스프링의 JtaTransactionManager는 JTA 트랜잭션 매니저를 스프링 애플리케이션이 이용 하게 해주는 트랜잭션 추상화를 위한 클래스일 뿐이다.



리스트 2-ff1 JTA 트랜잭션 매니저와 사용자 트랜잭션 등록

~~~xml
&lt;bean id=&quot;atomikosTransactionManager&quot; class=&quot;com.atomikos.icatch . jta.UserTransactionManager&quot; lmtMethod=&quot;init&quot; destroy-method=&quot;close&quot;&gt;
&lt;property name=&quot;forceShutdown&quot;&gt;&lt;value&gt;true&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id=&quot;atomikosUserTransaction&quot; class=&quot;com.atomikos.icatch.jta.UserTransactionlmp&quot;&gt;
&lt;property name=&quot;transactionTimeout&quot;&gt;&lt;value&gt;300&lt;/value&gt;&lt;/property&gt; 
&lt;/bean&gt;
~~~



다음은 리스트 2 -68과 같이 스프링 JtaTransactionManager를 등록하고 서벼의 트랜잭션 서비스 대신 앞에서 빈으로 빈으로 등록해둔 Atomikos JTA 서비스를 이용하도 록프로퍼티를설정해줘야한다.

리스트 2-58JTATransactionManager 등록

~~~xml
&amp;lt;bean id=“transactionManager&quot; class=&quot;org. springframework. transaction. j ta. JtaTransactionManager&quot;&amp;gt; &lt;property name=&quot;transactionManager&quot; ref=&quot;atomikosTransactionManager&quot; /&gt; &lt;property name=&quot;userTransaction&quot; ref=&quot;atomikosUserTransaction&quot; /&gt; &amp;lt;/bean&amp;gt;
~~~







다음은 XA를 지원하는 DataSource를 빈으로 등록할 차례다. 
글로벌/분산 트랜잭션을 사용히는 만큼 여러 개의 DB를 사용하도록 하나 이상의 DataSource를 등록한다.
**DataSource는 JTA 트랜잭션 매니저와 XA 프로토콜을 통해 트랜잭션이 동작하도록 만들어야 한다.** 
따라서 일반 DataSource 대신 XA를 지원하는 XA DataSource를 사용해야 한다. 
**Atomikos는 XA 지원 드라이버 를 사용할 수도 있고. XA를 지원하지 않는 드라이버를 Atomikos 의 도웅을 통해 XA 드라이버처럼 사용하게 만들 수도 있다.** 
여기서는 MySQL 이 제공히는 XA DataSource 인 MysqlXADataSource를 사용해보겠다.
먼저 리스트 2-69와 같이 첫 번째 DB를 위한 DataSource를 등록해보자. JTA 에서 사용할 DataSource 에는 고유한 리소스 이름을 지정해줘야 한다.



리스트 2• 39 XA DataSource 등록

~~~xml
&amp;lt;bean id=&quot;dataSource1&quot; class=“ com.atomikos.jdbc .AtomikosDataSourceBean&quot;
init-method=&quot;init&quot; destroy캐lethod=&quot;close&quot;&amp;gt; 
&lt;property name=&quot;uniqueResourceName&quot; value=&quot;MySQLXA1&quot; /&gt;
&amp;lt;property name=&quot;xaDataSourceClassName&quot; value=&quot;com .mysql. j dbc. j dbc2 .optional.MysqlXADataSource“ /&amp;gt; 
&lt;property name=&quot;xaProperties&quot;&gt; 
&lt;props&gt; 
	&lt;prop key=&quot;user&quot;&gt;jtauser&lt;/prop&gt; 
    &lt;prop key=&quot;password&quot;&gt;jtapassword&lt;/prop&gt; 
     &lt;prop key=&quot;url&quot;&gt;jdbc :mysql :/localhost/tx1&lt;/prop&gt; 
&lt;/props&gt;
&lt;/property&gt; 
&lt;property name=&quot;poolSize&quot; value=&quot;l&quot; /&gt; &amp;lt;/bean&amp;gt;
~~~

같은 방법으로 리스트 2-70과 같이 두 번째와 세 번째 DataSource를 등록한다.



리스트 2-70 나머지 XA DataSource 등록

~~~xml
&lt;bean id=&quot;dataSource2&quot; class=&quot;com.atomikos.jdbc.AtomikosDataSourceBean&quot;&gt; 
    &lt;property name=&quot;uniqueResourceName&quot; value=&quot;MySQLXA2&quot; /&gt;
&lt;/bean&gt;
&lt;bean id=&quot;dataSource3&quot; class=&quot;com.atomikos.jdbc.AtomikosDataSourceBean&quot;&gt; 
  &lt;property name=&quot;uniqueResourceName&quot; value=&quot;MySQLXA3&quot; /&gt;
&lt;/bean&gt;
~~~



이제 각각의 데이터 소스를 사용하는 JDBC DAO나 iBatis SqlMapClient 또는
JPA EntityManagerFactory. 하이버네이트 SessionFactory를 등록하고 DAO를 만든다. 이때 각 데이터 액세스 기술에서 사용되는 DataSourceTransactionManager 나
JpaTransactionManager 같은 트랜잭션 매니저는 등록할 멸요가 없다.
이제 모든 준비가 묻났다. 세 가지 DB를 사용하는， 다른 기술로 만들어진 DAO들이 JTA를 통해 하나의 트랜잭션 안에서 동작함을 확인할 수 있을 것이다. 이렇게 3 개의 DB를 시용하는 JTA 설정과 학습 태스트는 예제 코드의 tx/JtaTxTest ，j ava와 tx/
jtatxtest-context ， xml에 나와 있으니 참고하기 바란다.







### WAS 트랜잭션 매니저의 고급 기능 사용하기

스프링의 JtaTransactionManager는 JTA 의 표준 스펙을 따르는 API를 사용해 트랜잭션을 관리한다. 그런데 WebLogic 이나 OC4J. WebSphere 등의 고급 WAS 에서는 표준 JTA는 지원하지 않는. WAS 가 제공하는 고급 트랜잭션 기능을 활용할 수 있다.
WAS 별 전용 트랜잭션 매니저를 살펴보자.	

- WebSphereUowTransactionManager

  WebSphereUowTransactionManager를 JtaTransactionManager 대신 사용하면 IBM
  WebSphere 의 UOWManager를 통해서 WebSphere 가 제공히는 트랜잭션 서비스의 기능을 최대한 활용할 수 있다. 
  **IBM WebSphere 팀의 공식적인 기술지원을 통해서 개발된 만큼 안정성을 보장받을 수 있다.** 
  **JTA 에서 기본적으로 보장되지 않는 트랜잭션 일시중단 기능이 제공되며 ， 이를 통해 REQUIRES_NEW 같은 트랜잭션 전파속성을 사용할수있다 .**

- WebLogicJtaTransactionManager

  WebLogic 서버의 트랜잭션 서비스를 최대한 활용할 수 있게 해준다. 트랜잭션 이름， 트랜잭션별 격리수준설정， 트랜잭션의 일시중지와 재시작등을모두활용할수 있다. 

  **또 WebLogic 서버의 트랜잭션 모니터를 통해 스프링에서 진행되는 트랜잭션을 관찰할 수 있게 해준다.**

- OC4JJtaTransactionManager

  OC4J 서버의 트랜잭션 기능에 최적화된 트랜잭션 매니저다. 트랜잭션별 격리수준 설정을 지원하며 **OC4J 의 트랜잭션 모니터에서 스프링의 트랜잭션을 볼 수 있게 해준다.** 오라클팀이 만들어서 스프링에 제공한 코드를 바탕으로 만틀어졌다.

위 세 가지 서버를 사용히는 경우라면 JtaTransactionManager 대신 해당 서버 전용 트랜잭션 매니저를 사용하는 편이 좋다. 

**서버에 따라 트랜잭션 매니저의 종류를 변경하 기가 귀찮다면 . JtaTransactionManager 빈을 등록하는 대신 스프링이 제공하는 서버 자동인식 기능을 가진 전용 태그를 시용할 수 있다.**
 &lt;tx:jta-transaction-manager /&gt;

tx 스키마의 jta-transactlon-manager 태그를 이용해 JTA 트랜잭션 매니저를 등록 할수있다. 
**이 방식의장점은서버를자동인식해서 적절한 JTA 트랜잭션을등록해준다는 점이다**. 
이 설정을 가진 애플리케이션을 WebSphere 에 가져가면 WebSphere용 JTA 트랜잭션 매니저가 등록되고.OC4J 에 배치하면 OC4J용 트랜잭션 매니저가 자동등록 된다. 
세 개의 서버 외에 배치됐을 때는 기본인 JtaTransactionManager 가 사용된다.































&lt;/tx:method&gt;&lt;/tx:method&gt;&lt;/tx:method&gt;&lt;/tx:attributes&gt;&lt;/tx:method&gt;&lt;/tx:annotation-driven&gt;&lt;/aop:config&gt;&lt;/tx:attributes&gt;&lt;/Member&gt;&lt;/aop:pointcut&gt;&lt;/aop:config&gt;&lt;/aop:config&gt;&lt;/aop:config&gt;</content>

      
      
      
      
      

      <author>
          <name>seongtaekkim</name>
        
        
      </author>

      

      
        <category term="spring" />
      

      
        <summary type="html">– 토비의스프링 2권 정리 – 토비의스프링2권 2장</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">토비의스프링1권 8장 내용</title>
      <link href="https://seongtaekkim.github.io/spring-toby1_8" rel="alternate" type="text/html" title="토비의스프링1권 8장 내용" />
      <published>2021-08-19T01:36:01+09:00</published>
      <updated>2021-08-19T01:36:01+09:00</updated>
      <id>https://seongtaekkim.github.io/spring-toby1_8</id>
      <content type="html" xml:base="https://seongtaekkim.github.io/spring-toby1_8">&lt;p&gt;&lt;span class=&quot;table-of-contents-list&quot;&gt;– 토비의스프링 1권 정리&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;table-of-contents-list&quot;&gt;
    &lt;li&gt;&lt;a href=&quot;./spring-toby1_8&quot;&gt;토비의스프링1권 8장&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./spring-toby1_9&quot;&gt;토비의스프링1권 9장&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;84-스프링의-기술&quot;&gt;8.4 스프링의 기술&lt;/h1&gt;

&lt;p&gt;스프링의 목적중 하나는 POJO방식의 애플리케이션 개발을 가능하게 하는 것이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;이를 위해 세가지 기술( IoC/DI, AOP, PSA)를  제공한다.&lt;/li&gt;
  &lt;li&gt;세가지 기술을 충분히 잘 사용하면 POJO방식의 개발이 가능하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;기술과 비즈니스 로직을 분리하고 POJO 방식의 애플리케이션 개발을 가능하게 한다는 스프링의 목적을 쉽게 이루려면 스프링과 같은 POJO 프레임워크가 필요하다.&lt;/p&gt;

&lt;p&gt;스프링에는 POJO 프로그래밍을 손쉽게 할 수 있도록 지원하는 세 가지 가능기술(enabling technology)을 제공한다.&lt;/p&gt;

&lt;p&gt;앞서 살펴봤던 스프링 삼각형이라는 그림에 나와 있듯이, 엔터프라이즈 개발에서 POJO 개발이 가능하려면 삼각형의 각 변을 이루고 있는 기술들이 뒷받침돼야 한다.&lt;/p&gt;

&lt;p&gt;그 세 가지 기술은 바로 IoC/ DI , AOP, PSA다.&lt;/p&gt;

&lt;p&gt;이 세 가지 모두 스프링이 있기 이전에도 여러 가지 형태로 시도됐고 발전하고 있던 기술이었다.&lt;/p&gt;

&lt;p&gt;사실은 객체지향의 설계와 개발원리를 잘 적용하다 보면 자연스럽게 만들어지는 것이기도 하다.&lt;/p&gt;

&lt;p&gt;다만 스프링은 그것을 통일성 있게, 더 세련된 방법으로, 자바 엔터프라이즈 개발의 전 영역에 걸쳐 효과적으로 적용될 수 있도록 프레임워크 형태로 제공하고있다.&lt;/p&gt;

&lt;p&gt;어떤 개발자는 스프링을 단지 이런 기술을 제공하는 기술 프레임워크로 이해하기도 한다. 스프링은 IoC/DI 컨테이너라거나, AOP 툴이라거나 엔터프라이즈 서비스 추상화PSA를 제공해주는 프레임워크라는 식으로 이해한다는 뜻이다.&lt;/p&gt;

&lt;p&gt;물론 틀린 얘기는 아니 지만 그렇게 스프링을 특정 기술을 지원해주는 단순한 프레임워크로 이해하면 스프링의 목적과 가치를 놓치기 쉽다.&lt;/p&gt;

&lt;p&gt;스프링의 기술들은 스프링 프레임워크가 만들어진 진정한 목표인 POJO 기반의 엔터프라이즈 개발을 편리하게 해주는 도구일 뿐이다. 또 다른 관점에서 보자면 IoC/DI , AOP , PSA 라는 것 자체가 이미 스프링이 중요한 가치를 두는 객체지향의 원리를 충실히 적용해서 나온 결과이기도 하다.&lt;/p&gt;

&lt;p&gt;스프링은 엔터프라이즈 개발에 등장히는 다양한기술에 대해 이미 잘 만들어진 서비스 추상화 기능을 제공하고 있지만, 그렇다고 스프링이 제공하는 PSA만 달랑 사용하고 말라는 뜻은 아니다.&lt;/p&gt;

&lt;p&gt;스프링 사용자라면 스프링이 직접 제공하지 않는 기술에 대해서도 PSA를 적용할 줄 알아야 한다.&lt;/p&gt;

&lt;p&gt;그것이 스프링의 목적과 개발 철학에 부합하는 스프링의 사용법이다. 그래서 스프링의 기술들은 스프링의 목적과 핵심 가치를 기준으로 살펴보고 이해하는 것이 중요하다.&lt;/p&gt;

&lt;h2 id=&quot;841-제어의-역전loc-의존관계-주입di&quot;&gt;8.4.1 제어의 역전(loC)/ 의존관계 주입(DI)&lt;/h2&gt;

&lt;p&gt;DI는 왜 사용하는 걸까?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;개방폐쇄원칙이라는 객체지향설계원칙에 의하면,&lt;/li&gt;
  &lt;li&gt;DI는 확장에는 열려있고, 변경에는 닫혀있어 유연한 개발이 가능하기 때문에 사용한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;IoC/DI 는 스프링의 가장 기본이 되는 기술이자 스프링의 핵심 개발 원칙이기도 하다. 나머지 두 가지 기술인 AOP와 PSA도 IoC/DI 에 바탕을 두고 있다. 3대 기술은 아니지만 자주 등장하는 템플릿/콜백 패턴이 적용된 부분도 IoC/DI가 그 핵심 원리다.&lt;/p&gt;

&lt;p&gt;IoC/ DI 의 기본 원리는 1장에서 충분히 살펴봤으니, 여기서는 IoC/DI 의 활용 방법을 생각해 보자. 이런 질문을 해볼 수 있다. 왜 두 개의 오브젝트를 분리해서 만들고, 인터페이스를 두고 느슨하게 연결한 뒤, 실제 사용할 대상은 DI를 통해 외부에서 지정하는 것일까?&lt;/p&gt;

&lt;p&gt;이렇게 DI 방식으로 하는 것이 그렇지 않은 경우, 즉 직접 자신이 사용할 오브젝트를 new 키워드로 생성해서 사용히는 강한 결합을 쓰는 방법보다 나은 점은 무엇일까?&lt;/p&gt;

&lt;p&gt;가장 간단한 답변은 ‘유연한 확장이 가능하게 하기 위해서’라고 할 수 있다.&lt;/p&gt;

&lt;p&gt;DI는 개방 폐쇄 원칙 OCP 이라는 객체지향 설계 원칙으로 잘 설명될 수 있다. 유연한 확장이라는 장점은 OCP 의 ‘확장’에는 열려 있다(개방)’에 해당한다.&lt;/p&gt;

&lt;p&gt;DI는 역시 OCP 의 ‘변경에는 닫혀 있다(폐쇄)’라는 말로도 설명이 가능하다. 폐쇄 관점에서 볼 때 장점은 ‘재사용이 가능하다’라고볼수있다.&lt;/p&gt;

&lt;p&gt;A→B 라는 의존관계를 갖는 오브젝트 구조라고 생각해보자. 여기서 확장은 B 가 자유롭게 변경될 수 있음을 의미한다. 이는 B 가 변경돼도 A는 아무런 영향을 받지 않고 그대로 유지 가능하다는 뜻이기도 하다.&lt;/p&gt;

&lt;p&gt;B 관점 에 서는 유연한 확장이고 A 관점으로 보자면 변경 없이 재사용이 기능하다고 볼 수 있는 것이다.  B가  B1, B2 ,B3 으로 구현 방법이 바뀌어도 된다고 볼 수도 있고, B1, B2 ,B3 처럼 의존 대상이 바뀌어도 A는 그대로 재사용이 가능하다고 볼 수도 있다.&lt;/p&gt;

&lt;h3 id=&quot;di의활용방법&quot;&gt;DI의활용방법&lt;/h3&gt;

&lt;p&gt;개념적인 설명 말고 좀 더 구체적으로 DI 의 활용 방식을 살펴보면서 그 장점을 생각해 보자.&lt;/p&gt;

&lt;h3 id=&quot;1-핵심기능의-변경&quot;&gt;1. 핵심기능의 변경&lt;/h3&gt;

&lt;p&gt;DI 의 가장 대표적인 적용 방법은 바로 의존 대상의 구현을 바꾸는 것이다. 디자인 패턴의 전략 패턴이 대표적인 예다.&lt;/p&gt;

&lt;p&gt;A→B 구조에서 A 의 기능 일부를 B 에게 위임한다고 했을 때 B 의 구현 방식을 필요에 따라 통째로 B1,B2,B3 으로 비꾸는 것이다.&lt;/p&gt;

&lt;p&gt;예를 들어보면 서비스 오브젝트가 사용하는 DAO 가 있다고 할 때, DAO 의 구현을 JDBC로 했다가,   그것을 JPA , 하이버네이트, JDO, iBatis 등으로 변경하는 것을 생각할 수 있다. 구현 방식을 통째로 바꾸는 것이다.&lt;/p&gt;

&lt;p&gt;샤용자 관리 서비스라고 보자면 사용자의 등급을 결정하는 정책을 담은 코드를  DI로 분리할 수 있다.&lt;/p&gt;

&lt;p&gt;만약 비즈니스 로직이 변경돼서 새로운 등급결정 정책을 적용해야 한다면, DI를 이용해 새로운 정책을 담은 클래스로 통째로 변경해주면 된다.&lt;/p&gt;

&lt;p&gt;이렇게 실제 의존하는 대상이 가진 핵심기능을 DI 설정을 통해 변경하는 것이 대표적인 DI의 활용 방법이다. 하지만 이게 다는 아니다.&lt;/p&gt;

&lt;h3 id=&quot;2-핵심기능의-동적인-변경&quot;&gt;2. 핵심기능의 동적인 변경&lt;/h3&gt;

&lt;p&gt;두 번째 활용 방법은 첫 번째랑 비슷하게 의존 오브젝트의 핵심기능 자체를 바꾸는 것이다.               하지만 일반적인 DI를 이용한 변경 방법과는 달리, 동적으로 매번 다르게 변경할 수 있다.&lt;/p&gt;

&lt;p&gt;DI도 기본적으로는 런타임 시에 동적으로 의존 오브젝트를 연결해주는 것이긴 하지만 일단 DI 되고 나면 그 후로는 바뀌지 않는다.&lt;/p&gt;

&lt;p&gt;즉 동적인 방식으로 연결되지만 한번 DI 되면 바뀌지 않는 정적인 관계를 맺어주는 것이다.&lt;/p&gt;

&lt;p&gt;하지만 DI를 잘 활용하면 애플리케이션이 동작하는 중간에 그 의존 대상을 다이내믹하게 변경할수 있다.&lt;/p&gt;

&lt;p&gt;예를 들면 사용자의 등급에 따라서 다른 DataSource를 사용하게 만들 수도 있다.&lt;/p&gt;

&lt;p&gt;DAO는 DataSource에 의존한다. DAO → DataSource 관계가 만들어진다.&lt;/p&gt;

&lt;p&gt;그런데 이를 DAO 하나가 여러 개의 DataSource 에 의존하게 만들 수도 있다.  그리고 현재 접속한 사용자의 등급에 따라서 그때그때 다른 DataSource를 DAO 가 사용하게 할 수도 있다.&lt;/p&gt;

&lt;p&gt;VIP 사용자는 좀 더 속도가 빠른 DB를 이용하게 해서 빠른 처리 속도를 보장해주려고 할 때 적용할 수 있는 기법이다.&lt;/p&gt;

&lt;p&gt;물론 DAO를 따로 만들 필요는 없다. 대신 매우 지능적인 방식으로 동작하는 DI 덕분에 선택적으로 사용할 Data Source를 바꿔주는 기법이 가능하다.&lt;/p&gt;

&lt;p&gt;또 다른 예를생각해보면 사용자별로 모두 독립적인 의존오브젝트를 두게 만들수도 있다.&lt;/p&gt;

&lt;p&gt;한번 로그인한 사용자는 로그아웃하거나 다른 브라우저로 다시 들어오기 전에는 계속 자신만의 오브젝트를 유지하게 하고 서비스 오브젝트가 이를 DI 받아서 사용하게 할 수 있다. 이때는 핵심기능이 바뀐다기보다는 기능은 같지만 독립적인 상태 정보를 저장할 수 있는 자신만의 오브젝트를 가질 수 있다는 뜻이다. 매번 요청이 있을 때마다 새로운 오브젝트가 필요하다면 new를 이용해 새로 만들어도 그만이겠지만， 한번 로그인한 사용자에게는 계속 같은 오브젝트가 적용되려면 DI를 이용하는 이 방식이 가장편리하다.&lt;/p&gt;

&lt;p&gt;동적인 방식으로 핵심기능을 변경하는 건, 기술적으로 보자면 다이내믹 라우팅 프록시나 프록시 오브젝트 기법을 활용한 것이다. 그런 기법을 적용할 수 있었던 이유는 역시 DI가 있기 때문이다.&lt;/p&gt;

&lt;p&gt;DI 없이는 불가능하다. DI의 원칙은 여전히 지켜지므로 확장과 재사용이라는 장점은 손상되지 않고오히려 더 가치를 드러낸다.&lt;/p&gt;

&lt;h3 id=&quot;3-부가기능의추가&quot;&gt;3. 부가기능의추가&lt;/h3&gt;

&lt;p&gt;DI 의 세 번째 활용 방법은 핵심기능은 그대로 둔 채로 부가기능을 추가하는 것이다.&lt;/p&gt;

&lt;p&gt;데코레이터 패턴을 생각해보면 된다. 인터페이스를 두고 사용하게 하고, 실제 사용할 오브젝트는 외부에서 주입하는 DI를 적용해두면  데코레이터 패턴을 쉽게 적용할수 있다.&lt;/p&gt;

&lt;p&gt;그래서 핵심기능과 클라이언트 코드에는 전혀 영향을 주지 않으면서 부가적인 기능을 얼마든지 추가할수 있다.&lt;/p&gt;

&lt;p&gt;트랜잭션 기능을 부여했던 것이 그 대표적인 예다.  때로는 핵심기능은 그대로 둔채로 결과나 전달 파라미터를 조작할 수도 있고, 파라미터나 리턴 결과를 활용해 로깅이나 보안 처리 같은 부가적인 작업을 수행할 수도 있다.&lt;/p&gt;

&lt;p&gt;부가기능이라기보다는 부가작업이라고 본다면 이벤트 발생 작업의 추가같은 것도 생각해볼수 있다. 부가 기능의 추가 방식을 특정 오브젝트가 아니라 좀 더 많은 대상으로 일반화해서 적용하면 AOP가된다.&lt;/p&gt;

&lt;p&gt;부가기능을 추가할 수 있는 것도 바로 DI 덕분이다. DI 구조로 만들어놨기 때문에 가능한 것이며 DI의 핵심 원칙인 OCP 에도 충실하게 잘 들어맞는다.&lt;/p&gt;

&lt;p&gt;OCP 가 말하는 확장에 열려 있다는 것은 전략패턴에서처럼 핵심기능을 변경해서 쓰는 수준만을 말하는게아님을기억해야한다.&lt;/p&gt;

&lt;h3 id=&quot;4-인터페이스의변경&quot;&gt;4. 인터페이스의변경&lt;/h3&gt;

&lt;p&gt;때로는 사용하려고 하는 오브젝트가 가진 인터페이스가 클라이언트와 호환되지 않는 경우가 있다. 또는 여러 종류의 인터페이스를 가졌지만 사실은 비슷한 기능을 담당하는 오브젝트를 바꿔가면서 사용하고 싶을 때도 있다.&lt;/p&gt;

&lt;p&gt;이렇게 클라이언트가 사용하는 인터페이스와 실제 오브젝트 사이에 인터페이스가 일치하지 않는 경우에도 DI가 유용하다.&lt;/p&gt;

&lt;p&gt;A가 C 오브젝트를 사용하려 한다고 해보자. 하지만 A는 원래 B 인터페이스를 사용하도록 만들어져 있고 C는 B인터페이스를 구현하지 않았다. 이때 A가 DI를 통해 B의 구현 오브젝트를 받도록 만들어져 있다면 B인터페이스를 구현했으면서 내부에서 C를 호출해주는 기능을 가진 어댑터 오브젝트를 만들어 A에  DI해주면 된다.&lt;/p&gt;

&lt;p&gt;220V 전기를 원하는 9V, 6V, 12V 식으로 바꿔주는 어댑터처럼, 인터페이스가 다른 오브젝트를 클라이언트가 사용히는 인터페이스로 바꿔주는 기능을 이용하면 되는 것이다.&lt;/p&gt;

&lt;p&gt;A→B (c로 위임) → C 처럼 구성된다. 여전히 A는 DI덕분에 자신의 코드를 수정하지 않아도 된다. 이처럼 인터페이스가 일치하지 않는 호출이 필요한 경우에도 DI는 유용하다.&lt;/p&gt;

&lt;p&gt;디자인 패턴에서 말하는 오브젝트 방식의 어댑터 패턴의 응용이라고 볼수있다.&lt;/p&gt;

&lt;p&gt;이를 좀 더 일반화해서 아예 인터페이스가 다른 다양한 구현을 같은 방식으로 사용하도록, 중간에 인터페이스 어댑터 역할을 해주는 레이어를 하나 추가하는 방법도 있다. DI의 응용 방법 중 하나이자 스프링의 대표적인 기술로도 분류되는 일관성 있는 서비스추상회 PSA가 그런 방법이다.&lt;/p&gt;

&lt;p&gt;PSA는 클라이언트가 일관성 있게 사용할 수있는 인터페이스를 정의해주고  DI를 통해 어댑터 역할을 하는 오브젝트를 이용하게 해준다. 이를 통해서 다른 인터페이스를 가진 로우레벨의 기술을 변경하거나 확장해 가면서 사용할수 있는 것이다.&lt;/p&gt;

&lt;h2 id=&quot;어댑터-패턴-예제&quot;&gt;어댑터 패턴 예제&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;220v로 동작하는 전자기기를 어댑터를 통해서 110v에서 동작하도록 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/204d32a9-c7ea-4308-bb47-0a371aa30fd9/Untitled.png&quot; alt=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/204d32a9-c7ea-4308-bb47-0a371aa30fd9/Untitled.png&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;110v로동작하는 헤어드라이어와 220v로 동작하는 에어컨을 정의한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Electronic110V&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;powerOn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Electronic220V&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;conect&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;HairDryer&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt;  &lt;span class=&quot;nc&quot;&gt;Electronic110V&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;powerOn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;헤어드라이어 110v on&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AirConditioner&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt;  &lt;span class=&quot;nc&quot;&gt;Electronic220V&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;connect&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;에어컨디셔너 220v&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;220v의 에어컨을 110v에서 동작할수 있도록 어뎁터를 생성해준다.&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SocketAdapter&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Electronic110V&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Electronic220V&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;electronic220V&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;SocketAdapter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Electronic220V&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;electronic220V&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;electronic220V&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;electronic220V&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;powerOn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;electronic220V&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;connect&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;110v를 상속받았으나, 실제로는 220v로 객체를생성하여 함수를 수행함.&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Main&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

        &lt;span class=&quot;nc&quot;&gt;HairDryer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hairDryer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;HairDryer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;connect&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hairDryer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// 220v를 110v로 변환.&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;AirConditioner&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;airConditioner&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AirConditioner&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;Electronic110V&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;airAdapter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SocketAdapter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;airConditioner&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;connect&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;airAdapter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 110v 콘센트&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;connect&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Electronic110V&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;electronic110V&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;electronic110V&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;powerOn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;110v를 실행하기 위해 adapter를 이용하여 220v 전자기기를  켤 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;5-프록시&quot;&gt;5. 프록시&lt;/h3&gt;

&lt;p&gt;프록시 패턴의 전형적인 응용 방법도 있다. 필요한 시점에서 실제 사용할 오브젝트를 초기화하고 리소스를 준비하게 해주는 지연된 로딩 lazy loading을 적용하려면 프록시가 필요하다.&lt;/p&gt;

&lt;p&gt;원격 오브젝트를 호출할 때 마치 로컬에 존재하는 오브젝트처럼 사용할 수 있게 해주는 원격 프록시를 적용하려고 할 때도 프록시가 필요하다.&lt;/p&gt;

&lt;p&gt;두 가지 방법 모두 DI를 필요로한다. 스프링은 EJB 원격 호출을 포함해서 웹 서비스, REST호출,  HTTP 방식의 호출 등 다양한 리모팅 기술을 지원한다. 당연히 모두 DI를 통해 이뤄진다.&lt;/p&gt;

&lt;h3 id=&quot;6-템플릿과-콜백&quot;&gt;6. 템플릿과 콜백&lt;/h3&gt;

&lt;p&gt;탬플릿/콜백 패턴은 DI의 특별한 적용 방법이다. 반복적으로 등장하지만 항상 고정 적인 작업 흐름과 그 사이에서 자주 바뀌는 부분을 분리해서 탬플릿과 콜백으로 만들고 이를 DI 원리를 응용해 적용하면 지저분하게 매번 만들어야 히는 코드를 간결하게 만틀 수 있다.&lt;/p&gt;

&lt;p&gt;스프링이 제공하는 20여 가지의 템플릿/콜백이 적용된 기능을 가져다 활용하는 것뿐 아니라 필요에 따라서는 DI 원리를 따라 직접 응용할 수 있어야 한다. 콜백을 템플릿에 주입하는 방식으로 동작하게 히는 것은 DI의 원리에 가장 충실한 응용 방법이다.&lt;/p&gt;

&lt;p&gt;콜백을 얼마든지 만들어서 사용할 수 있다는 건 개방을 통한 유연한 확장성을 보여주는 것이며,       템플릿은 한 번 만들어두면 계속 재사용할 수 있다는 건 기능의 확장에도 변하지 않는다는 OCP 의 폐쇄 원칙에 가장 잘 들어맞는 것이다.&lt;/p&gt;

&lt;h3 id=&quot;7-싱글톤과-오브젝트-스코프&quot;&gt;7. 싱글톤과 오브젝트 스코프&lt;/h3&gt;

&lt;p&gt;DI 가 필요한 중요한 이유 중 한 가지는 DI할 오브젝트의 생명주기를 제어할 수 있다는 것이다.&lt;/p&gt;

&lt;p&gt;DI를 프레임워크로 이용한다는 건 DI 대상 오브젝트를 컨테이너가 관리한다는 의미다.&lt;/p&gt;

&lt;p&gt;오브젝트의 생성부터 관계설정, 이용,소멸에 이르기까지의 모든 과정을 DI컨테이너가 주관하기 때문에 그 오브젝트의 스코프를 자유롭게 제어할 수있다.&lt;/p&gt;

&lt;p&gt;가장 기본이 되는 스코프는 역시 싱글톤이다. 하나 또는 소수의 오브젝트가 수많은 클라이언트를 상대로 고성능 서비스를 제공하는 방식은 엔터프라이즈 개발에서 매우 중요하다.&lt;/p&gt;

&lt;p&gt;상태를 갖지 않도록 만든 오브젝트가 동시에 여러 스레드의 요청을 처리하는 이런 방식을 적용하려면 만들어지는 오브젝트의 개수를 제어히는 일이 매우 중요하다.&lt;/p&gt;

&lt;p&gt;전통적인 싱글톤 패턴은 오브젝트에 많은 제약을 가해서 만들어지기 때문에 그다지 권장되지 않는다.&lt;/p&gt;

&lt;p&gt;그보다는 컨테이너가 오브젝트를 관리하는 IoC 방식이 유용하다. 스프링의 DI는 기본적으로 싱글톤으로 오브젝트를 만들어서 사용하게 한다. 컨테이너가 알아서 싱글톤을 만들고 관리하기 때문에 클래스 자체는 싱글 톤을 고려하지 않고 자유롭게 설계해도 된다는 장점이 있다.&lt;/p&gt;

&lt;p&gt;때론 단일 싱글톤이 아니라 임의의 생명주기를 갖는 오브젝트가 필요할 때도 있다.&lt;/p&gt;

&lt;p&gt;스프링에서는 싱글톤 외에도 다양한 스코프를 갖는 오브젝트를 만들어 DI 에 사용할 수도 있다.&lt;/p&gt;

&lt;p&gt;HTTP 요청당 하나의 오브젝트가 만들어지거나, HTTP 세션당 하나씩 오브젝트가 만들어지게 할 수 있다.&lt;/p&gt;

&lt;p&gt;개발자 스스로 일정한 스코프를 갖는 오브젝트를 만들고 이를 DI 에 적용하는 것도 가능하다.&lt;/p&gt;

&lt;p&gt;이렇게 오브젝트 스코프를 제어하는 방법 또한 DI를 적용했기 때문에 가능한 활용방법이다.&lt;/p&gt;

&lt;h3 id=&quot;8-테스트&quot;&gt;8. 테스트&lt;/h3&gt;

&lt;p&gt;마지막으로 살펴볼 DI 의 중요한 용도는 바로 테스트다.&lt;/p&gt;

&lt;p&gt;여타 오브젝트와 협력해서 동작하는 오브젝트를 효과적으로 테스트하는 방법은 가능한 한 고립시키는 것이다.&lt;/p&gt;

&lt;p&gt;즉 다른 오브젝트와의 사이에서 일어나는 일을 테스트를 위해 조작할 수 있도록 만든다.&lt;/p&gt;

&lt;p&gt;그래야만 테스트 대상인 오브젝트의 기능에 충실하게 테스트가 기능하다. 자칫 다른 오브젝트와의 협력을 통해 동작하는 기능을 다 허용하고 테스트하다가는 한번에 수십 개의 오브젝트와 DB 환경까지 모두 테스트해야 하는 부담을 안을 수 있다.&lt;/p&gt;

&lt;p&gt;그래서 태스트할 대상이 의존하는 오브젝트를, 테스트를 목적으로 만들어진 목오브젝트로 대체하면 유용하다.&lt;/p&gt;

&lt;p&gt;복잡한 테스트 데이터가 준비되어 있어야 원히는 결과를 가져올 수 있는 DAO를 사용히는 오브젝트가 있다고 해보자. DAO를 이용하는 서비스 오브젝트를 태스트하기 위해서 DAO도 완벽하게 작성되어 있음을 먼저 확인해야 하고. DAO 가 테스트를 위해 적합한 결괴를 돌려주도록, 필요한 테스트 데이터까지 모두 준비해야 한다면 배보다 배꼽이 더 큰 일이 되기 십상이다.&lt;/p&gt;

&lt;p&gt;정작 원하는 것은 십여 줄밖에 안 되는 조건에 따라 다르게 동작하는 서비스 오브젝트 코드인 데， 테스트를 준비하면서 DAO와 테스트 데이터 때문에 너무 많은 시간을 쏟아야 한다면 곤란하다.&lt;/p&gt;

&lt;p&gt;그래서는 테스트 만드는 게 짐이 되고 태스트를 사용하기가 점점 꺼려질것이다.&lt;/p&gt;

&lt;p&gt;그래서 의존 오브젝트를 대신해서 스텁 또는 목 오브젝트 같은 테스트 대역을 활용해야 한다. 이때도 DI 는 중요한 역할을 한다. DI를 위해 만든 수정자 메소드를 사용하면 테스트 코드 안에서 수동으로 목 오브젝트를 주입할 수 있다. 또는 테스트용 으로 설정을 별도로 만드는 방법도 있다. DI없이는 이런 테스트 기법을 적용하기란 불가능하다.&lt;/p&gt;

&lt;p&gt;갈수록 테스트의 중요성이 커져가고 있으니 DI의 활용 방법에서 테스트가 차지하는 비중도 커질 것이다.&lt;/p&gt;

&lt;p&gt;그 외에도 DI의 활용 방법은 다양하다. 이 정도만 살펴봐도 런타임 시 유연하게 구현을 비꿀 수 있다는 DI라는 개념이 실전에서 얼마나 활용도가 다양한지 알 수 있을 것이다. 잘 살펴보면 DI 의 용도는 디자인 패턴 중에서 오브젝트 합성 방식을 따르는 패턴과 관련이 있음을 알수 있다. GoF 의 디자인 패턴 중에서 인터페이스를두고 오브젝트를 분리히는 구조를 가진 오브젝트 스코프의 패턴은 DI 의 구조에 대부분 잘 들어맞는다. 그런 패턴의 장점들을 애플리케이션 전 영역에서 간단한 설정만으로 자연스럽게 적용할 수 있게 만들어주는 것이 바로 DI 다.&lt;/p&gt;

&lt;p&gt;이런 활용 방법은 한 번에 한 가지만 선택적으로 사용해야 하는 건 아니다. 여러 가지 활용 방법을 한 번에 적용할 수도 있다. 예를 들변 하나의 DI 대신에 대해 핵심기능도 업무 변화에 따라 바꾸면서， 부가기능도 여러 개 추가해넣고， 테스트에서도 활용하는 식으로 사용해도 된다.&lt;/p&gt;

&lt;h2 id=&quot;842-애스펙트-지향-프로그래밍aop&quot;&gt;8.4.2 애스펙트 지향 프로그래밍(AOP)&lt;/h2&gt;

&lt;p&gt;애스펙트 지향 프로그래밍이라고 많이 알려진 AOP도 스프링의 3 대 가능기술의 하나다.&lt;/p&gt;

&lt;p&gt;계속해서 스프링은 객체지향 기술과 프로그래밍을 위해 존재하는 프레임워크라고 설명했는데,      난데없이 애스펙트 지향 프로그래밍이라는 새로운 프로그래밍 패러다임이왜 필요할까?                  사실 애스펙트 지향 프로그래밍은 객체지향 프로그래밍 OOP처럼 독립적인 프로그래밍 패러다임이 아니다.  AOP와 OOP는 서로 배타적이 아니라는말이다.&lt;/p&gt;

&lt;p&gt;객체지향 기술은 매우 성공적인 프로그래밍 방식임에 분명하다. 하지만 한편으로는 점점 복잡해져 가는 애플리케이션의 요구조건과 기술적인 난해함을 모두 해결하는데 한계가 있기도 하다.&lt;/p&gt;

&lt;p&gt;AOP는 바로 이러한 객체지향 기술의 한계와 단점을 극복하도록 도와주는 보조적인 프로그래밍 기술이다. AOP를 사용하면 그 결과로 OOP를 더욱 OOP 답게 만들 수 있다. AOP는 90년대부터 연구됐고, 여러 가지 제품으로도 나왔지만 이를 가장 성공적으로 엔터프라이즈 개발에 보급한 것이 바로 스프링이다.&lt;/p&gt;

&lt;p&gt;스프링의 목적인. POJO 만으로 엔터프라이즈 애플리케이션을 개발하면서도 엔터프라이즈 서비스를 선언적으로 제공하는 데 반드시 필요한 것이 바로 이 AOP 기술이다. IoC /DI 를 이용해서 POJO 에 선언적인 엔터프라이즈 서비스를 제공할 수 있지만 일부 서비스는 순수한 객체지향 기법만으로는 POJO 의 조건을 유지한 채로 적용하기 힘들다. 바로 이런 문제를 해결하기 위해 AOP가 필요하다.&lt;/p&gt;

&lt;p&gt;스프링의 AOP는 스프링이 POJO 프로그래밍을 지원하려는 그 핵심 목적을 위해 중요한 역할을 하고 있다.&lt;/p&gt;

&lt;h3 id=&quot;aop의적용기법&quot;&gt;AOP의적용기법&lt;/h3&gt;

&lt;p&gt;AOP를 자바 언어에 적용하는 기법은 크게 두 가지로 분류할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;첫-번째는-스프링과-같이-다이내믹-프록시룰-사용하는-방법이다&quot;&gt;첫 번째는 스프링과 같이 다이내믹 프록시룰 사용하는 방법이다&lt;/h3&gt;

&lt;p&gt;이 방법은 기존 코드에 영향을 주지 않고 부가기능을 적용하게 해주는 데코레이터 패턴을 응용한 것이다.&lt;/p&gt;

&lt;p&gt;자바의 객체지향 패턴을 활용한 방법이기 때문에 만들기 쉽고 적용하기 간펀하다. 대신 부가기능을 부여할 수 있는 곳은 메소드의 호출이 일어 나는지점 뿐이라는 제약이 있다. 인터페이스와 DI를활용하는 데코레이터 패턴이 기반원리이기 때문이다. 부가기능을 구현한 코드나 기능을 적용할 대상을 찾는 방법 모두 평범한 자바 클래스로 만들면 된다.&lt;/p&gt;

&lt;p&gt;스프링의 기본적인 AOP 구현 방법은 다이내믹 프록시를 이용하는 프록시 AOP 방식이다. 엔터프라이즈개발에서 필요로 하는 AOP는 대부분이 이 프록시 방식의 AOP면 된다.&lt;/p&gt;

&lt;h3 id=&quot;두-번째는-자바-언어의-한계를-넘어서는-언어의-확장을-이용하는-방법이다&quot;&gt;두 번째는 자바 언어의 한계를 넘어서는 언어의 확장을 이용하는 방법이다&lt;/h3&gt;

&lt;p&gt;AspectJ라는 유명한 오픈소스 AOP 툴이 있다.&lt;/p&gt;

&lt;p&gt;이 AspectJ는 강력한 고급 기능을 가진 AOP를 제공한다. AspectJ는 프록시 방식의 AOP 에서는 불가능한 다양한 조인 포인트를 제공한다.&lt;/p&gt;

&lt;p&gt;메소드 호출뿐 아니라 인스턴스 생성 , 필드 액세스, 특정 호출 경로를 가진 메소드 호출 등에도 부가기능을 제공할 수 있다. 이런 고급 AOP 기능을 적용하려면 자바 언어와 JDK의 지원만으로는 불가능하다.&lt;/p&gt;

&lt;p&gt;그 대신 별도의 AOP 컴파일러를 이용한 빌드 과정을 거치거나, 클래스가 메모리로 로딩될 때 그 바이트 코드를 조작히는 위빙과 같은 별도의 방법을 이용해야 한다.&lt;/p&gt;

&lt;p&gt;그만큼 사용하기 까다 롭고 번잡하지만 경우에 따라서는 프록시 방식의 AOP로는 할 수 없는 작업을 위해 AspectJ를 사용해야 한다.&lt;/p&gt;

&lt;p&gt;스프링은 프록시 방식의 AOP를 기본으로 하고 있지만, 원한다면 AspectJ를 이용한 AOP로 바꿔서 사용할 수 있다. 스프링의 특별한 기능 중에는 AspectJ를 꼭 사용해야 하는것도있다.&lt;/p&gt;

&lt;h3 id=&quot;aop의적용단계&quot;&gt;AOP의적용단계&lt;/h3&gt;

&lt;p&gt;AOP 가 객체지향 개발 방법에서 기본 아이디어를 가져왔다고는 하지만 본격적으로 적용하기에는 그 성격이 자바의 일반적인 개발 방법과는 상당히 다르기 때문에 제대로 적용하려면 충분한 시간과 노력이 필요하다.&lt;/p&gt;

&lt;p&gt;또 AOP 의 장점이 많다고 해서 무작정 사용 하면 심각한 문제가 발생할 위험이 있다. 개발자 개개인이 아무렇게나 AOP를 남발해서 사용하다 보면 다른 개발자가 만든 코드가 예상하지 않은 방식으로 돌아가는 등의 혼란을 초래할 수 있기 때문이다.&lt;/p&gt;

&lt;p&gt;AOP는 하나의 모듈이 수많은 오브젝트에 보이지 않게 적용되기 때문에 매우 주의해서 사용해야 한다. AOP 에 익숙하지 않은 상태라면 차근차근 단계를 밟아 AOP를 도입히는 접근 방법 이좋다 .&lt;/p&gt;

&lt;h3 id=&quot;aop-적용-1-단계-미리-준비된-aop-이용&quot;&gt;AOP 적용 1 단계: 미리 준비된 AOP 이용&lt;/h3&gt;

&lt;p&gt;일단 처음에는 스프링이 미리 만들어서 제공히는 AOP 기능을 그대로 가져다 적용하는 것으로 시작한다. 스프링이 직접 제공하는 대표적인 AOP는 바로 트랜잭션이다.&lt;/p&gt;

&lt;p&gt;DB를 사용하는 애플리케이션이라면 트랜잭션이 필요할테니 이 트랜잭션 적용을 스프링 AOP 도입의 첫 번째 단계로 이용한다. AOP 설정을 통해서 트랜잭션이 어떻게 많은 오브젝트에 투명하게 적용되는지 관찰해보고, AOP 의 특성과 동작원리를 이해해보자.&lt;/p&gt;

&lt;p&gt;스프링에는 트랜잭션만큼 자주 사용되진 않지만 특정 아키텍처를 선택했을 때 사용할 수 있도록 준비된 AOP 기능이 하나 더 있다. @Configurable 애노태이션을 이용해서 도메인 오브젝트에 DI 를 자동적용해주는 AOP 기능이다. 도메인 오브젝트를 전용 계층에 두고 접근하는 아키텍처 방식을 따를 때 반드시 필요하다.&lt;/p&gt;

&lt;p&gt;프록시 AOP면 충분한 트랜잭션과 달리, @Configurable을 위해서는 AspectJ를 이용한 AOP가 반드시필요하다.&lt;/p&gt;

&lt;p&gt;이 두가지가 스프링이 미리 준비해서 제공히는대표적인 AOP 기능이다. 두가지 모두 간단한 설정을 추가하는 것만으로도 쉽게 적용되기 때문에 AOP 에 대한 지식이나 경험이 많지 않더라도 간단히   이용 가능하다는 장점이 있다.&lt;/p&gt;

&lt;h3 id=&quot;aop-적용-2단계--전담팀올-통한-정책-aop-적용&quot;&gt;AOP 적용 2단계 : 전담팀올 통한 정책 AOP 적용&lt;/h3&gt;

&lt;p&gt;다음 단계는 좀 더 적극적으로 AOP를 적용할 차례다.&lt;/p&gt;

&lt;p&gt;아직까지는 개발자 개개인이 AOP 기능을 직접 이용하게 해서는 안 된다. 대신 애플리케이션 전체적으로 이용 가능한 것을 소수의 AOP 담당자 관리하에 적용해볼 수 있다.&lt;/p&gt;

&lt;p&gt;대표적으로 비즈니스 로직을 가진 오브젝트에 대한 보안, 특정 계층의 오브젝트 이용 전후의 작업 기록을 남기는로깅, 데이터 추적을 위한 트레이싱, 특정 구간의 실시간 성능모니터링과 같은 정책적으로 적용할 만한 기능에 AOP를 이용하는 것이다.&lt;/p&gt;

&lt;p&gt;이런 기능을 개발자가 직접 자신이 만드는 코드에 추가하려면, 개발 표준이나 가이드라인이 미리 완벽하게 준비되어 있어서 이를 따라 개발하게 해야 한다.&lt;/p&gt;

&lt;p&gt;하지만 개발자가 실수로 빼 먹을 수도 있고, 가이드라인을 제대로 따르지 못하고 엉뚱하게 적용할 수도 있다. 더 큰 문제는 개발 정책이나 기준이 바뀌면 모든 개발자가 지금까지 작업한 것을 모두 수정하고 일일이 검증해야 하는 큰 부담을 지게 된다.&lt;/p&gt;

&lt;p&gt;하지만 이런 일을 AOP를 이용해 한번에 적용한다면 일반 개발자의 작업에는 전혀 영향을 주지 않을 수 있다.  AOP를 책임지는 소수의 팀만 수고하면 그만이다.&lt;/p&gt;

&lt;p&gt;또한 AOP는 언제든지 기능을 추가하거나 제거할 수 있다. 기존 코드에는 당연히 아무런 영향을 주지 않으면서 말이다. 이런 특정을 잘 이용하면 운영 중에 필요한 기능 외에 개발 가이드라인이나 표준을 따라서 코드가 작성되어 있는지를 검증하는 작업을 AOP를 이용해 할 수 있다.&lt;/p&gt;

&lt;p&gt;예를 들면 레이어 간의 호출에 대한 제한이 있다고 생각해보자. JSP 뷰에서는 DAO나 서비스 계층의 오브젝트를 직접 호출하면 안 된다는 정책이 있다.&lt;/p&gt;

&lt;p&gt;하지만 개발자는 곧잘 이런 기준을 무시하고 제멋대로 짜기 일쑤 다. 이런 것을 코드리뷰를 통해      일일이 검증하기는쉽지 않다.&lt;/p&gt;

&lt;p&gt;이럴 때 AOP가유용 하게 쓰일 수 있다. 모든 DAO 의 메소드 호출에 적용되는 AOP 모듈을 하나 만든다. 그리고 메소드 호출이 일어났을 때 어드바이스를 통해 호출 경로를 조사할 수 있다.&lt;/p&gt;

&lt;p&gt;만약 서비스 계층 같은 허용된 계층으로부터의 호출이 아니라면 정책위반 예외를 던지게 할 수 있다. 또 서비스 계층에서 던질 수 있는 예외의 종류가 정해져 있다고 해보자. 그런데 개발자가 임의의 예외를 만들거나 선택해서 마구 사용할 수도 있다. 이런 경우라면 서비스 계층의 메소드에 대해 예외가 던져졌을 때만 동작히는 AOP 모률을 만들 수 있다. 그리고 그 안에서 예외의 종류를 검사해서 허용된 게 아니면 역시 정책위반 예외를 만들어서 던지고 관리자에게 통보가 가도록 할 수 있다.&lt;/p&gt;

&lt;p&gt;이렇게 AOP는 동적으로 동작하면서 개발 정책을 위반한 코드를 잡아내는 데도 유용하다.&lt;/p&gt;

&lt;p&gt;물론 개발이 끝나고 실전에 적용할 때는 정책 검증을 위한 AOP 설정을 간단히 제거 해버리면된다 .&lt;/p&gt;

&lt;h3 id=&quot;aop-적용-3단계--aop의-자유로운-이용&quot;&gt;AOP 적용 3단계 : AOP의 자유로운 이용&lt;/h3&gt;

&lt;p&gt;첫 번째와 두 번째 단계를 거쳐서 AOP 에 어느 정도 친숙해지고, 그 장단점과 응용 전략, 위험성 등을 어느 정도 이해했다면 이제는 개발자 스스로가 AOP를 활용할 수있는 단계로 넘어갈 수 있다.&lt;/p&gt;

&lt;p&gt;이전 단계에서는 애플리케이션 전체적으로 적용되는 정책 AOP를 위주로 했다면 이제는 개발자가  구현하는 기능에 적용하면 유용한 세부 적인 AOP를 이용할 수 있다. 큰 범위에 걸쳐서 적용되는 기능은 아니지만 한 모듈 또는 특정 기능 안에서도 AOP 로 분리하면 유용한 것들이 있다.&lt;/p&gt;

&lt;p&gt;물론 다른 팀이나 개발자가 만든 코드에 몰래 적용되는 AOP 기능은 만들어선 안 된다. 그런 위험만 주의한다면 얼마든지 개발자가 자신이 다루는 코드에 AOP를 적극 활용할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;843-포터블-서비스-추상화psa&quot;&gt;8.4.3 포터블 서비스 추상화(PSA)&lt;/h2&gt;

&lt;p&gt;세 번째 가능기술은 환경과 세부 기술의 변회에 관계없이 일관된 방식으로 기술에 접근 할 수 있게 해주는 PSA (Portable Service Abstraction) 이다.&lt;/p&gt;

&lt;p&gt;POJO로 개발된 코드는 특정 환경이나 구현 방식에 종속적이지 않아야 한다. 스프링은 JavaEE를 기본 플랫폼으로 히는 자바 엔터프라이즈 개발에 주로 사용된다.&lt;/p&gt;

&lt;p&gt;따라서 다양한 JavaEE 기술에 의존적일 수밖에 없다. 특정 환경과 기술에 종속적이지 않다는게 그런 기술을 사용하지 않는다는 뜻은 아니다.&lt;/p&gt;

&lt;p&gt;다만 POJO 코드가 그런 기술에 직접 노출되어 만들어지지 않는다는 말이다.&lt;/p&gt;

&lt;p&gt;이를 위해 스프링이 제공히는 대표적인 기술이 바로 일관성 있는 서비스 추상화 기술이다.&lt;/p&gt;

&lt;p&gt;스프링은 엔터프라이즈 개발에 사용되는 다양한 기술에 대한 서비스 추상화 기능을 제공한다. 어떤 것은 AOP 나 템플릿/콜백 패턴과 결합돼서 시용되기 때문에 직접적으로 서비스를 이용할 필요가 없다.&lt;/p&gt;

&lt;p&gt;대신 설정을 통해 어떤 종류의 기술을 사용할지 지정 해줘야한다.&lt;/p&gt;

&lt;p&gt;트랜잭션 서비스 추상화는 코드를 이용해 트랜잭션을 제어하지 않는다면 직접 이용할 이유가 없다.&lt;/p&gt;

&lt;p&gt;트랜잭션은 대부분 AOP 를 이용해 적용하기 때문에 직접 코드를 만들지 않기 때문이다.&lt;/p&gt;

&lt;p&gt;대신 설정에서는 스프링의 트랜잭션 추상화 인터페이스인 PlatformTransactionManager를 구현한 구체적인 서비스 클래스를 빈으로 등록해줘야 한다.&lt;/p&gt;

&lt;p&gt;JTA를 이용해 트랜잭션을 적용하고 싶다변 JtaTransactionManager를 빈으로 등록하고 JTA 환경에 대한 설정을 프로퍼티로 넣어주면 된다.&lt;/p&gt;

&lt;p&gt;직접 스프링이 제공하는 API 를 사용해서 만드는 경우도 있다.OXM 이나 JavaMail 을 이용한다면 스프링이 정의한 추상 API 를 이용해 코드를 작성한다. 그리고 구체적인 기술과 설정은 XML 파일 안에서 지정한다.&lt;/p&gt;

&lt;p&gt;스프링의 서비스 추상화의 개념과 장점을 잘 이해한다면 때에 따라 직접 서비스 추상화 기법을 적용할 필요도 있다.&lt;/p&gt;

&lt;p&gt;엔터프라이즈 개발에 사용되는 기술은 끊임없이 쏟아져 나온다. 표준 기술뿐 아니라 오픈소스 라이브러리, 상용 프레임워크 형태로도 하루가 멀다 하고 새로운 기술이 등장한다.&lt;/p&gt;

&lt;p&gt;보편적으로 사용되는 기술이라면 아마도 다음 버전의 스프링에서 서비스 추상화 대상으로 포함시킬 가능성이 있다.&lt;/p&gt;

&lt;p&gt;하지만 그것을 굳이 기다려야 할 이유는 없다.  필요하면 스프링이 그랬던 것처럼 직접 추상 레이어를 도입하고 일관성 있는 API를 정의해서 사용하면 된다.&lt;/p&gt;

&lt;p&gt;서비스 추상화를 위해 필요한 기술은 DI 뿐이다. 결국 DI 응용 방법의 한 가지이므로 DI 를 적극 활용해서 개발한다면 서비스 추상화는 자연스럽게 만들어 쓸 수 있다. 서비스 추상회는 단지 구체적인 기술에 종속되지 않게 하기 위해서만 사용되는 건 아니다.&lt;/p&gt;

&lt;p&gt;테스트가 어렵게 만들어진 API 나 설정을 통해 주요 기능을 외부에서 제어하게 만들고 싶을 때도 이용할 수 있다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>seongtaekkim</name>
        
        
      </author>

      

      
        <category term="spring" />
      

      
        <summary type="html">– 토비의스프링 1권 정리 토비의스프링1권 8장 토비의스프링1권 9장</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">토비의스프링1권 9장</title>
      <link href="https://seongtaekkim.github.io/spring-toby1_9-summary" rel="alternate" type="text/html" title="토비의스프링1권 9장" />
      <published>2021-08-18T01:36:01+09:00</published>
      <updated>2021-08-18T01:36:01+09:00</updated>
      <id>https://seongtaekkim.github.io/spring-toby1_9-summary</id>
      <content type="html" xml:base="https://seongtaekkim.github.io/spring-toby1_9-summary">&lt;p&gt;&lt;span class=&quot;table-of-contents-list&quot;&gt;– 토비의스프링 1권 정리&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;table-of-contents-list&quot;&gt;
    &lt;li&gt;&lt;a href=&quot;./spring-toby1_8&quot;&gt;토비의스프링1권 8장&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./spring-toby1_9&quot;&gt;토비의스프링1권 9장&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;test&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;alert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;가나다라마바사&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;syntaxHighlight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;code&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;Hello World&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;bar&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content>

      
      
      
      
      

      <author>
          <name>seongtaekkim</name>
        
        
      </author>

      

      
        <category term="spring" />
      

      
        <summary type="html">– 토비의스프링 1권 정리 토비의스프링1권 8장 토비의스프링1권 9장</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">토비의스프링1권 9장 내용</title>
      <link href="https://seongtaekkim.github.io/spring-toby1_9" rel="alternate" type="text/html" title="토비의스프링1권 9장 내용" />
      <published>2021-08-18T01:36:01+09:00</published>
      <updated>2021-08-18T01:36:01+09:00</updated>
      <id>https://seongtaekkim.github.io/spring-toby1_9</id>
      <content type="html" xml:base="https://seongtaekkim.github.io/spring-toby1_9">&lt;p&gt;&lt;span class=&quot;table-of-contents-list&quot;&gt;– 토비의스프링 1권 정리&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;table-of-contents-list&quot;&gt;
    &lt;li&gt;&lt;a href=&quot;./spring-toby1_8&quot;&gt;토비의스프링1권 8장&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;./spring-toby1_9&quot;&gt;토비의스프링1권 9장&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;9장에서는&lt;/p&gt;

&lt;p&gt;스프링을 이용해 애플리케이션 프로젝트를 처음 구성할 때 알아야 할 기본적인 내용을 다룬다.&lt;/p&gt;

&lt;p&gt;또, 스프링 개발에 도움이 되는 개발 툴과 빌드 방법도 살펴볼 것이다.&lt;/p&gt;

&lt;p&gt;마지막으로 스프링을 애플리케이션에 적용할 수 있는 아키텍처의 종류와 특징에 대해서도 알아본다.&lt;/p&gt;

&lt;p&gt;스프링은 어떤 종류의 애플리케이션에도 잘 들어맞도록 매우 유연하게 설계된 범용 프레임워크다.&lt;/p&gt;

&lt;p&gt;그래서 아키텍처의 종류나 프로젝트를 구성하는 방법에 대한 자유도가 매우 높다.&lt;/p&gt;

&lt;p&gt;그만큼 프로젝트 구성 방법이나 아키텍처를 선택할 때 주의를 기울일 필요가 있다. 스프링이 유연하다고 해서 아무렇게나 가져다 쓰면 스프링이 주는 유익을 제대로 얻지 못할수도 있기 때문이다.&lt;/p&gt;

&lt;h1 id=&quot;91-자바엔터프라이즈-플랫폼과-스프링-애플리케이션&quot;&gt;9.1 자바엔터프라이즈 플랫폼과 스프링 애플리케이션&lt;/h1&gt;

&lt;p&gt;스프링으로 만들 수 있는 애플리케이션의 종류에는 제한이 없다.&lt;/p&gt;

&lt;p&gt;자바 언어를 사용하는 모든 종류의 프로젝트라면 어디든 사용할 수 있다. 웹을 이용히는 자바 엔터프라이즈 시스템 개발에도 사용할 수 있고, 스윙이나 이클립스 RCP로 만드는 독립형 standalone 프 로그램에도 적용 가능하다. 사용할 수 있는 기능에 제한이 있기는 하겠지만 애플릿이나 모바일 애플리케이션 개발에도 이용할 수 있다. 심지어 스프링을 핵심 엔진으로 사용하는 엔터프라이즈 미들웨어 제품도 있다.&lt;/p&gt;

&lt;p&gt;그러나 스프링의 탄생 배경이나 스프링이 주로 제공하는 기능의 목록을 봐도 알 수있듯이, 스프링은 주로 자바 엔터프라이즈 환경에서 동작하는 애플리케이션을 개발하는 목적으로 사용된다.&lt;/p&gt;

&lt;p&gt;서버에서 동작히는 엔터프라이즈 애플리케이션을 제외한 다른 형태의 애플리케이션에 스프링을 제대로 적용하기 위해서는 SpringRCP 프로젝트나 &lt;a href=&quot;http://spring.me/&quot;&gt;Spring.ME&lt;/a&gt; 같은 추가적인 스프링 지원기술이 필요하다.&lt;/p&gt;

&lt;p&gt;따라서 이 책에서는 자바 엔터 프라이즈 환경에서 사용되는 스프링 개발에 관한 내용만을 다룰 것이다.&lt;/p&gt;

&lt;p&gt;자바 엔터프라이즈 애플리케이션은 서버에서 동작하며 클라이언트를 상대로 서비스를 제공하도록 되어 있다. 즉 클라이언트의 요청을 받아서 그에 대한 작업을 수행하고 그 결과를 돌려주는 것이 기본적인 동작 방식이다. 하지만 클라이언트의 요청 없이도 정해진 시간이나 특정 이벤트 발생에 따라 독자적으로 작업을 수행하기도 한다.&lt;/p&gt;

&lt;h2 id=&quot;911--클라이언트와-백엔드-시스템&quot;&gt;9.1.1  클라이언트와 백엔드 시스템&lt;/h2&gt;

&lt;p&gt;엔터프라이즈 애플리케이션은 자신이 클라이언트가 돼서 또 다른 엔터프라이즈 시스템에 서비스를 요청할 수도 있다.&lt;/p&gt;

&lt;p&gt;또는 데이터베이스나 레거시 시스템 같은 엔터프라이즈 정보 시스템(EIS) 이라고 불리는 백엔드 시스템의 기능을 이용해 동작하기도 한다.&lt;/p&gt;

&lt;p&gt;가장 많이 사용되는 구조는 클라이언트가 웹 브라우저이고 백엔드 시스템이 DB인 구성이다.&lt;/p&gt;

&lt;p&gt;간단히 ‘DB를 사용히는 웹 애플리케이션’이라고 한다. 웹 클라이언트와 DB 가 사용되지 않는 시스템은 거의 없으니, 이를 스프링이 사용되는 애플리케이션의 기본 구조라고 생각할 수도 있다.&lt;/p&gt;

&lt;p&gt;그런 면에서 스프링의 주요 기능은 웹 브라우저를 클라이언트로 하고 DB에 데이터를 저장, 조회하는 데 집중되어 있다. 그렇다고 해서 꼭 클라이언트는 웹 브라우저여야 하며 백엔드 시스렘은 DB를 이용 해야만  하는 것만은 아니다. 웹 브라우저에서 동작하기는 하지만, HTML을 사용하는 표준 웹 클라이언트 외에도 Flex 나 X 인터넷 제품처럼 독립적으로 강력한 기능을 가진 RIA Rich Internet Application 클라이언트가 사용되기도 한다.&lt;/p&gt;

&lt;p&gt;또는 HTTP 프로토콜을 이용해 통신하는 다른 엔터프라이즈 시스템일 때도 있다.&lt;/p&gt;

&lt;p&gt;자바 서버가 받아들일 수 있는 방식으로 요청을 보내기만 한다면 어떤 종류의 클라이언트이든 상관없다.&lt;/p&gt;

&lt;p&gt;실제로 MS 의 .NET 애플리케이션도 스프링을 이용하는 클라이언트로 많이 사용된다. 하나의 스프링 애플리케이션이 동시에 여러 종류의 클라이언트를 상대로 서비스를 제공하는 경우도 흔하다. 스프링 엔터프라이즈 애플리케이션이 이용하는 백엔드 시스템으로는 DB는 물론이고 메시징 서버， 메일 서버， 메인프레임도 가능하다.&lt;/p&gt;

&lt;p&gt;자바가 제공하는 접속 방식을 지원 하는 시스템이면 된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;웹 서비스를 제공하는 서버도 자주 사용된다.&lt;/li&gt;
  &lt;li&gt;원격 EJB 서버를 사용할 수도 있다.&lt;/li&gt;
  &lt;li&gt;한 번에 여러 종류의 백엔드 시스템을 이용할 수 있다.&lt;/li&gt;
  &lt;li&gt;여러 개의 DB를 동시에 이용하는 것도 가능하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c4da229c-911e-4824-bebb-5d36d73c03b8/Untitled.png&quot; alt=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c4da229c-911e-4824-bebb-5d36d73c03b8/Untitled.png&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;912-애플리케이션-서버&quot;&gt;9.1.2 애플리케이션 서버&lt;/h2&gt;

&lt;p&gt;스프링으로 만든 애플리케이션을 자바 서버환경에 배포하려면 JavaEE(또는 J2EE) 서버가 필요하다. JavaEE 표준을 따르는 애플리케이션 서버는 크게 두 가지로 구분할 수 있다. 하나는 JavaEE 의 대부분의 표준 기술을 지원하고 다양한 형태의 모듈로 배포가 가능한 완전한 웹 애플리케이션 서버 WAS 이고,&lt;/p&gt;

&lt;p&gt;다른 하나는 웹 모듈의 배포만 기능한 경량급 WAS 또는 서블릿 /JSP 컨테이너다.&lt;/p&gt;

&lt;h3 id=&quot;경량급-was서블릿-컨테이너&quot;&gt;경량급 WAS/서블릿 컨테이너&lt;/h3&gt;

&lt;p&gt;스프링은 기본적으로 톰켓Tomcat 이나 제티 Jetty 같은 가벼운 서블릿 컨테이너만 있어도 충분하다. EJB 나 리소스 커넥터, WAS 가 제공하는 분산 서비스 등이 굳이 필요하지 않다면 서블릿 컨테이너로도 엔터프라이즈 애플리케이션에 필요한 핵심기능을 모두 이용할 수 있다.&lt;/p&gt;

&lt;p&gt;기존에 EJB와 WAS를 사용해야 가능했던 선언적인 트랜잭션 이나 선언적 보안, DB 연결 풀링,  리모팅이나 웹 서비스는 물론이고 추가적인 라이브러리의 도움을 받으면 분산/글로벌 트랜잭션까지도 가능하다.&lt;/p&gt;

&lt;h3 id=&quot;was&quot;&gt;WAS&lt;/h3&gt;

&lt;p&gt;물론 고가의 WAS를 사용하면 그만를 장점이 있다. 성능 면에서는 대단히 낫지 않더라도 미션 크리티컬한 시스템에서 요구하는 고도의 안정성이나 고성능 시스템에서 필수적인 안정적인 리소스 관리 레거시 시스템의 연동이나 기존 EJB로 개발된 모듈을 함께 사용되는 등의 필요가 있다면 상용 또는 오픈소스 WAS를 이용할 수 있다.&lt;/p&gt;

&lt;p&gt;또 WAS는 상대적으로 관리 기능이나 모니터링 기능이 뛰어나서 여러 대의 서버를 동시에 운영할 때 유리한 점이 많다.&lt;/p&gt;

&lt;p&gt;무엇보다도 자바 엔터프라이즈 버전(JavaEE) 표준을 최대한 활용할 수 있다.&lt;/p&gt;

&lt;p&gt;스프링은 3.0 기준으로 J2EE 1.4와 JavaEE 5.0에 완벽히 호환된다. 또 일부 JavaEE 6.0의 기능을 지원하기도 한다.&lt;/p&gt;

&lt;p&gt;스프링의 개발팀은 필요할 때는 비용을 들이더라도 적합한 조건을 가진 WAS를 사용할 것을 권장한다. 스프링은 JavaEE와 배타적이라고 생각하는 사람들도 있는데 그렇지 않다. 스프링은 JavaEE 표준 기술을 적극 지원하고 있다. 물론 WAS를 사용할 때는 분명한 이유와 근거가 있는지 먼저 충분히 검토해야 한다. 훨씬 가볍고 빠르며 저렴한 비용으로 사용할 수 있는 서블릿 컨테이너로도 대개는 충분한데 특별한 이유도 없이 무겁고 다루기 힘든데다 비싸기까지 한 WAS 를 사용할 필요는 없기 때문이다.&lt;/p&gt;

&lt;h3 id=&quot;스프링소스-tcserver&quot;&gt;스프링소스 tcServer&lt;/h3&gt;

&lt;p&gt;톰캣에는 없는 고급서버관리기능 배포기능과 진단기능 기술지원을 받을 수 있다. 근데 결국 운영서버,기술지원은 유료임 ;;;&lt;/p&gt;

&lt;p&gt;실제로 개발환경과 운영환경에서 가장 많이 사용되는 자바서버는 웹 모듈만 지원하는 서블릿 컨테이너인 아파치 톰켓이다.&lt;/p&gt;

&lt;p&gt;스프링을 개발을 책임지고 있는 기업인 스프링소스에는 아파치 프로젝트인 HTTPD 서버와 톰켓의 핵심 개발자들이 포진해 있다.&lt;/p&gt;

&lt;p&gt;톰켓 전문가인 이들이 중심이 돼서 톰켓을 기반으로 엔터프라이즈 스프링 애플리케이션에 최적화된 경량급 애플리케이션 서버인 tcServer를 개발했다.&lt;/p&gt;

&lt;p&gt;tcServer를 이용하면 기존 톰켓에서는 아쉬웠던 고급 서버 관리 기능 배포 기능과 진단 기능을 포함해서 톰켓 전문가에게 받는 기술지원도 함께 제공받을 수 있다.&lt;/p&gt;

&lt;p&gt;대부분의 기능은 사용하지도 않을 고급 WAS를 구매하는 데 비싼 비용을 들이기는 부담스럽고, 그렇다고 운영하고 관리 하기 불편한데다 필요할 때 기술지원도 받을 길이 없는 오픈소스 제품인 톰켓을 그대로 시용하기는 불안하다면 tcServer가 좋은 대안이다.&lt;/p&gt;

&lt;p&gt;tcServer의 가장 큰 장점은 스프링 개발회사가 개발하는 것인 만큼 스프링 애플리케이션 개발과 운영에 꼭 필요한 중요한 기능이 많이 제공된다는 점이다. tcSerer는 개발자 버전이 따로 있어서 개발을 위해서 라면 자유롭게 이용 기능하다. 정식 운영서버에서 사용하고 기술지원을 받으려면 유료로 라이선스를 구매해야 한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;결국 유료 ㅡㅡ;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;913-스프링-애플리케이션의-배포단위&quot;&gt;9.1.3 스프링 애플리케이션의 배포단위&lt;/h2&gt;

&lt;p&gt;스프링으로 만든 애플리케이션은 다음의 세 가지 단위로 배포할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;1-독립-웹모듈&quot;&gt;1. 독립 웹모듈&lt;/h3&gt;

&lt;p&gt;스프링은 보통 war로 패키징된 독립 웹 모듈로 배포된다. 톰켓 같은 서블릿 컨테이너를 쓴다면 독립 웹 모듈이 유일한 방법이다.&lt;/p&gt;

&lt;p&gt;WAS 로 배포한다고 하더라도 독립 웹모듈을 사용하는 경우가 대부분일 것이다. EJB모듈을 함께 사용한다거나 여러개의 웹 모듈을 묶어서 하나의 웹 애플리케이션 모듈로 만들지 않는 한 독립 웹 모률이 가장 단순하고 편리한 배포 단위다.&lt;/p&gt;

&lt;h3 id=&quot;2-엔터프라이즈-애플리케이션&quot;&gt;2. 엔터프라이즈 애플리케이션&lt;/h3&gt;

&lt;p&gt;경우에 따라선 확장자가 ear인 엔터프라이즈 애플리케이션으로 패키징해서 배포할 수도 있다.&lt;/p&gt;

&lt;p&gt;스프링 애플리케이션에서 EJB 모듈을 긴밀하게 사용하거나 반대로 EJB모듈에서 스프링으로 만든 애플리케이션을 이용해야 한다면, EJB와 스프링 웹 모듈을 엔터프라이즈 애플리케이션으로 통합해야 한다.&lt;/p&gt;

&lt;p&gt;때로는 EJB 모듈은 없지만 엔터프라이즈 애플리케이션 배포 방식을 선택하는 경우가 있다. 하나 이상의 웹 모듈과 별도로 분리된 공유 기능한 스프링 컨텍스트를 엔터프라이즈 애플리케이션으로 묶어주는방법이다.&lt;/p&gt;

&lt;h3 id=&quot;3-백그리운드-서비스모듈&quot;&gt;3. 백그리운드 서비스모듈&lt;/h3&gt;

&lt;p&gt;이 두 가지 방법 외에도 J2EEl 1.4에서 등장한 rar패키징 방법도 있다. rar는 리소스 커넥터를 만들어 배포할 때 사용하는 방식인데, 만약 스프링으로 만든 애플리케이션이 UI를 가질 필요는 없고 서버 내에서 백그라운드 서비스처럼 동작할 필요가 있다면 rar 모듈로 만들어서 배포할 수 있다.&lt;/p&gt;

&lt;p&gt;이때는 J2EE 1.4나 그 이상의 표준을 따르는 WAS 가 반드시 필요하다.&lt;/p&gt;

&lt;p&gt;운영 플랫폼이나 서버의 종류는 개발 중에라도 언제든지 필요에 따라 변경이 가능하다.&lt;/p&gt;

&lt;p&gt;어차피 서플릿 컨테이너나 웹 모듈 모두 JavaEE 표준의 일부일 뿐이기 때문에 설정만 바꾸면 어렵지 않게 이전이 가능하다.&lt;/p&gt;

&lt;p&gt;다만 특정 서버환경에서만 제공하는기능을 시용한다면 변경이 힘들 수도 있다. 장기적으로 서버를 변경하거나 서버의 종류를 비꿀 가능성이 있다면, 서버의 기능에 종속되지 않도록 주의하거나 손쉽게 다른 서버의 기능 으로 변경 기능하도록 추상화해서 사용해야 한다.&lt;/p&gt;

&lt;h1 id=&quot;92-개발도구와-환경&quot;&gt;9.2 개발도구와 환경&lt;/h1&gt;

&lt;h2 id=&quot;921-javasejdk-javaee&quot;&gt;9.2.1 JavaSE/JDK. JavaEE&lt;/h2&gt;

&lt;h3 id=&quot;javasejdk&quot;&gt;JavaSE/JDK&lt;/h3&gt;

&lt;p&gt;스프링 3.0은 JavaSE 5 버전에서 추가된 새로운 언어와 문법의 특정을 최대한 활용해서 개발됐기 때문에 기본적으로 JDK 5.0 또는 그 이상을 필요로 한다. 또 일부 기능은 JDK 6.0 의 API 를 이용해 개발된 것도 있다. 예를 들어 JDBC 4.0 의 새로운 API를 사용히는 스프링의 기능이 필요하다면 JDK 6.0을 써야 한다. 스프링 3.0 이전에는 JDK 5.0 이싱벼l 서 사용할 수 있는 최적화된 기능을 별도의 모률로 제공했었다. 하지만 이제는 JDK 5.0 이 기본이 됐으므로 스프링 모률에서 그런 구분 자체가 사라졌다. 특별한 상황이 아니라면 이미 씬SUN 에서 공식지원을 종료해서 그 수명이 다한 JDK 1 .4나 그 이전 환경을 고집할 이유는 없다. 아직도 JDK 1 .4 .2에 머물고 있다면 스프링 3.0을 사용하기 위해서라도 JDK 5.0 이나 그 이후 버전으로 업그레이드해야 한다.&lt;/p&gt;

&lt;h3 id=&quot;javaeej2ee&quot;&gt;JavaEE/J2EE&lt;/h3&gt;

&lt;p&gt;스프링 3.0 이 사용될 자바 엔터프라이즈 플랫폼으로는 J2EE 1.4 버전이나 JavaEE 5.0 이 필요하다. 스프링 3.0 자체는 JDK 6.0과 JavaEE 5.0을 기준으로 개발됐지만 주요 기능은 JDK 5.0 에서 동작하는 J2EE 1.4 버전과 호환되게 제작되어 있다. 다만 J2EE 1.4 버전 서버를 사용할 때는 JDK 5.0 에서 동작하는지 반드시 확인해야 한다. 만약 WAS 자체가 JDK 5.0에서는 사용할 수 없다면 스프링 3.0 의 이용은 불가능하다. 상용 WAS 중에서 WebLogic 9 이나 WebSphere 6.1 같은 서버는 J2EE 1.4 서버이긴 하지만 JDK 5.0 에서 사용할 수 있는 것이다. 따라서 스프링 3.0 의 적용이 가능하다.&lt;/p&gt;

&lt;h2 id=&quot;빈-의존관계-그래프&quot;&gt;빈 의존관계 그래프&lt;/h2&gt;

&lt;p&gt;그림 9-8은 스프링 IDE 가 그려준 빈의 의존관계 그래프다. SpringIDE는 XML 설정파일을 읽어서 자동으로 그래프를 그려준다. 각 빈이 서로 어떻게 참조하고 있는 지, 어떤프로퍼티를갖고 있는지를한눈에 볼수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9df43331-4e45-456f-86b5-a6719cc679dd/Untitled.png&quot; alt=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9df43331-4e45-456f-86b5-a6719cc679dd/Untitled.png&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;924-라이브러리-관리와-빌드-툴&quot;&gt;9.2.4 라이브러리 관리와 빌드 툴&lt;/h2&gt;

&lt;h3 id=&quot;라이브러리-관리의-어려움&quot;&gt;라이브러리 관리의 어려움&lt;/h3&gt;

&lt;p&gt;과연 스프링으로 애플리케이션을 만들 때 어떤 라이브러리 파일들이 필요할까? 스프링 자체만 해도 20개 까지 세분화된 jar 모듈이 존재한다. 스프링이 직접 참조하는 필요 라이브러리는 100 개가 넘는다.&lt;/p&gt;

&lt;p&gt;스프링이 직접 참조하지 않는 프레임워크나 라이브러리 까지 포함하면 스프링으로 만드는 프로젝트에 포함될 가능성이 있는 라이브러리의 종류는 수백여 개에 달할 것이다.&lt;/p&gt;

&lt;p&gt;요즘은 웬만한 기능은 기존의 오픈소스 라이브러리를 활용하기 때문에 프레임워크 하나에 적게는 5~6 개에서 많게는 수십 개씩 의존 라이브러리가 필요한 경우도 많다.&lt;/p&gt;

&lt;p&gt;문제는 이런 의존 라이브러리가 항상 필요한 건 아니라는 점이다. 스프링만 해도 20개의 모듈과 100 여 개의 직접 참조라이브러리가 있지만 그 모든 모듈과 라이브러리가 매번 다 쓰이는 건 아니다.     필요한 기능과 시용하기로 결정한 기술에 따라서 적절한 선택이 필요하다.&lt;/p&gt;

&lt;p&gt;라이브러리마다 여러 개의 버전이 있다는 것도 문제다. 각 라이브러리마다 정확히 어떤 버전을 사용해야 할지도 알아야 한다.&lt;/p&gt;

&lt;p&gt;A 라는 기능을 사용하는 데 필요한 라이브러리는 B의 1.0부터 1.2까지 사이여야하고 B가동작하려면 C 라이브러리의 2.0은반드시 필요한데, B 의 일부 기능을 사용할 때는 선택적으로 D 라이브러리의 3.0 이 있어야 한다는 식의 지식이 필요하다는 뜻이다.&lt;/p&gt;

&lt;p&gt;라이브러리 종류는 같지만 버전이 맞지 않으면 컴파일이 되지 않을 수 있고 운이 나쁘면 컴파일은 정상적으로 되고 동작은 하지만 운영 중에 오류가 발생할 수 있다.&lt;/p&gt;

&lt;p&gt;필요한 라이브러리의 조합을 만들다 보면 복잡한 의존관계 속에서 같은 라이브러 리의 다른 버전이 동시에 펼요해서 문제가 발생하기도 한다. 라이브러리 관리 작업에서 발생할 수 있는 가장 골치 아픈 상황이다. 예를 들어 A 라이브러리는 B와 C 에 의존 한다. 그런데 B와 C 가 각각 D 라는 같은 라이브러리를 다시 의존하고 있다. 문제는 B 와 C 가 각각 다른 버전의 D를 사용하는 경우다. 예를 들어 B는 D의 1.0을 이용하는데 C는 D 의 2.0을 이용한다고 해보자.B와 C는 독립적으로 만들어진 프레임워크 또는 라이브러리라 서로의 호환성에 대해 항상 신경 쓸 수는 없기 때문에 이런 문제가 발생하는 것이다.&lt;/p&gt;

&lt;p&gt;라이브러리 2.0 이 1.0과 완벽히 호환된다면 문제가 없다. 이때는 둘 중에서 최신 버전을 선택하면 된다. 하지만 어떤 경우 버전이 올라가면서 같은 클래스인데도 완전히 다른 방식으로 동작하거나 내부 구조가 바뀌어서 전혀 호환되지 않는 경우도 있다.&lt;/p&gt;

&lt;p&gt;자바는 모듈이라는 개념이 없다. 독립 모듈로 패키징이 가능한 Jar 파일이 있는데 무슨 소리냐고 할지 모르겠지만 정말 모듈 개념이 없다. 만약 같은 패키지와 이름을 가진 클래스지만 구현이 다른 클래스 파일이 a.jar와 b.jar 두 개에 있다고 하자.&lt;/p&gt;

&lt;p&gt;그리고 a.jar 와 b.jar가 모두 클래스패스에 있다고 해보자. 이 경우 모듈 a.jar 안에 있는 클래스를 사용하겠다거나 b.jar 안에 있는 클래스를 사용하겠다고 선택할 수 있을까? a.jar와 b.jar 가 같은 웹 모듈의 라이브러리에 등록되어 있다면 Jar 파일 구분은 별 의미가 없다. 자바의 jar는 기본적으로 압축 패키징 방법일 뿐이지 구분 기능한 독립된 모률이 아니다.&lt;/p&gt;

&lt;p&gt;앞에서 설명한 경우를 다시 생각해보자. 그림 9-11 은 같은 라이브러리의 두 가지 버전이 존재하는 애플리케이션의 의존관계를 나타낸다. C 1.0과 C 2.0 에 이름이 같지만 구현이 다른 클래스가 있다면 이에 의존하고 있는 A 나 B 중 하나는 비정상적으로 동작할 것이다. 라이브러리 의존관계 관리의 가장 큰 난제다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c86a5ff4-2c86-4cab-a124-e6cee1e76a8e/Untitled.png&quot; alt=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c86a5ff4-2c86-4cab-a124-e6cee1e76a8e/Untitled.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 문제를 풀 수 있는 가장 간단한 방법은 재패키징(repackaging) 이다. 한쪽 버전의 클래스를 다른 패키지로 옮겨서 서로 구별되는 클래스로 만들어주는 방법이다. 물론 이에 의존히는 라이브러리의 코드도 변경된 패키지 내의 클래스를 사용하도록 수정돼야 한다. C 1.0과 C 2.0 모두 org.library.LibClass 라는 이름의 클래스를 가졌다고 하자. 두 개의 클래스가 이름은 같지만 호환이 안 된다면 그중 한 버전을 org.library.repack.LibClass 와 같은 식으로 패키지를 바꿔주고 이 버전을 사용하는 라이브러리도 org.library.repack 패키지 밑에 있는 클래스를 쓰도록 만들어야 한다.&lt;/p&gt;

&lt;p&gt;이런 재패키징 작업은 간단하진 않다. 모든 소스 또는 바이트코드를 일일이 찾아서 수정해주는 만만치 않은 작업이다. 실제로 이런 문제가 제법 많이 발생하고 있기 때문에 재패키징을 지원해주는 툴도 존재한다.&lt;/p&gt;

&lt;p&gt;구글 코드에서 찾을 수 있는 명령어를 이용하면 간단한 명령으로 한 번에 복잡한 라이브러리 클래스를 모두 재패키징할 수있다. 스프링이 사용히는 라이브러리의 의존관계를 따져보면 이렇게 버전이 다르면서 같은 라이브러리를 사용하는 경우가 여럿 발견된다. 특히 ASM (http ://asm.ow2.org)은 워낙 많은 곳에서 사용되면서 서로 버전이 호환이 안 되는 경우가 많아 자주 문제를 일으키는 악명 높은 라이브러리다. 그래서 스프링은 ASM 라이브러리를 통째로 재패키징해서 org.springframework.asm 이라는 스프링 패키지 밑으로 클래스를 옮겨두고 이를 사용 한다. 그렇게 해야 하이버네이트를 비롯해서 ASM을 사용하는 여타 라이브러리와 버전 충돌문제를 피할 수 있기 때문이다.&lt;/p&gt;

&lt;p&gt;이렇게 스프링을 이용한 애플리케이션을 만들 때 필요한 라이브러리의 종류와 버전을 적절히 선정하고 개발하면서 추가적으로 필요로 하는 라이브러리를 추가하거나 또는 제거하는 등의 관리 작업은 결코 쉬운 일이 아니다.&lt;/p&gt;

&lt;h3 id=&quot;라이브러리선정&quot;&gt;라이브러리선정&lt;/h3&gt;

&lt;p&gt;다행히도 이미 프로젝트의 기본틀이 잡혀 있고 시용할 라이브러리와 프로젝트폴더 구조까지 다 결정된 프로젝트에 참여해서 순수한 애플리케이션 개발에만 전념할 수 있다면 이런 걱정은 일단 덜 수 있다.&lt;/p&gt;

&lt;p&gt;하지만 자신이 직접 프로젝트를구성하고 필요한 라이브러리를 선정하거나 추가 제거하는 등의 관리를 해야 하는 상황이라면 여러모로 신경 써야할게많다.&lt;/p&gt;

&lt;p&gt;가장 먼저 해야 할 작업은 스프링으로 만드는 애플리케이션에서 정확히 어떤 기능이 필요한지를 정리하는 것이다.&lt;/p&gt;

&lt;p&gt;각 기능을 지원하는 기술이 여러 가지 종류가 있다면 그중에서 어떤 것을 사용할지도 결정해야 한다.&lt;/p&gt;

&lt;h3 id=&quot;스프링모듈&quot;&gt;스프링모듈&lt;/h3&gt;

&lt;p&gt;사용할 기능과 기술 목록이 모두 만들어졌으면 일단 스프링 모듈부터 선정한다. 스프링에는 총 20 개의 모듈이 있다. 일부는 거의 모든 애플리케이션에서 공통적으로 사용되는 필수 모듈이다.&lt;/p&gt;

&lt;p&gt;그 외의 모듈은 애플리케이션의 아키텍처와 사용 기술에 따라서 선택적으로 적용할 수 있다. 어떤 경우에 어떤 모듈이 필요한지에 대해서는 부록 A.2 절 ‘스프링 모률의 의존관계’를 참조하기 바란다. 스프링의 모듈 사이에도 의존관계가 있다. 모듈 사이의 의존관계는 필수와 선택 으로 나뉠 수 있다. 예를 들어 A 모듈이 의존하는 모듈은 B, C, D가 있다고 하자. 이중 B는 필수이고 C, D는 선택 가능하다면 A를 사용할 때 B는 무조건 추가해주면 되고 C와 D는 A 모듈이 가진 기능 중 어떤 것을 사용하느냐에 따라서 필요할 수도 있고 필요 없을 수도 있다.&lt;/p&gt;

&lt;p&gt;부록 A 에 나와 있는 모듈의 의존관계와 주요 기능을 잘 살펴보고 필수 의존모듈과 선택 의존모듈을 잘 구분해서 선정하자.&lt;/p&gt;

&lt;h3 id=&quot;라이브러리&quot;&gt;라이브러리&lt;/h3&gt;

&lt;p&gt;스프링의 각 모듈은 또 다른 모듈에 의존하기도 하지만 오픈소스 라이브러리 또는 표준 API를 필요로 하기도 하고 경우에 따라서는 상용 제품의 라이브러리에 의존한다. 부록 B 에 나와 있는 각 모듈과 라이브러리의 의존관계 매트릭스를 보면 각 모듈이 반드시 필요로하는 라이브러리가 무엇인지 선택적으로 사용하는 것은 무엇인지 알 수 있다.&lt;/p&gt;

&lt;p&gt;부록 B 에 나온 스프링 모듈과 그에 의존하는 라이브러리의 종류와 특징을 살펴보고 그 중에서 적절한 라이브러리를 선택한다.&lt;/p&gt;

&lt;p&gt;부록 B 에 소개된 스프링 의존 라이브러리는 스프링이 직접 참조하는 라이브러리일 뿐이다. 때로는 각 라이브리리를 활용하는 방법에 따라서 다른 서드파티 라이브러리를 필요로 하는 경우가 있다.&lt;/p&gt;

&lt;p&gt;예를 들어 하이버네이트는 스프링 애플리케이션에서 자주 사용되고, 스프링이 직접 지원하고 있기 때문에 스프링의 의존 라이브러리에 속한다.&lt;/p&gt;

&lt;p&gt;그런데 하이버네이트 자체를 놓고 보면 다시 세부 기능을 어떻게 사용하느냐에 따라서 또 다른 라이브러리가 필요할 수 있다. 이와 같은 정보는 해당 프레임워크나 라이브러리의 문서를 참조해서 필요한 라이브러리가 어떤 것인지 직접 찾아 봐야한다.&lt;/p&gt;

&lt;p&gt;부록 A와 부록 B 에 나와 있는, 모듈과 라이브러리의 의존관계와 필요한 경우에 대한 설명을 주의 깊게 읽어보고 적용하면 기본적으로 필요한 라이브러리를 선정할 수 있다.&lt;/p&gt;

&lt;p&gt;하지만 때로는 어떤 라이브러리를 추가해야 할지 말지 애매한 경우가 있다. 그런 경우 에는 어쩔 수 없이 시행착오 방법을 이용해야 한다.&lt;/p&gt;

&lt;p&gt;먼저 모든 스프링 관련 라이브러리 jar 파일을 모두 가져다 하나의 폴더에 몰아넣고 각각 별도의 폴더에 압축을 풀어준다. 대부분의 압축 유틸리티가 지원하는 ‘파일 이름을 폴더로 해서 압축 풀기’ 기능을 활용하면 된다.&lt;/p&gt;

&lt;p&gt;그리고 확실히 필요하다고 생각되는 최소한의 라이브러리와 모률만 가지고 일단 개발을 시작한다. 코드를 만들고 테스트를 수행하거나 애플리케이션을 기동하면 아마도 클래스를 찾을 수 없다는 예외 (ClassNotFoundException )를 만나게 될 것이다. 찾을 수 없다는 클래스의 이름을 가지고 라이브러리 압축을풀어둔폴더에서 검색을해본다. OS 의 탐색기의 검색 기능이나명령 행에서 파일을 검색하는 명령을 사용하면 된다. 클래스를 찾게 되면 그 클래스가 어느 라이브러리 jar 파일에서 나온 것인지 확인한 뒤에 해당 파일을 추가해준다. 그리고 다시 태스트나 애플리케이션을 돌려서 필요한 클래스와 라이브러리 파일을 계속 추가 해준다. 애플리케이션의 주요 기능을 가진 간단한 샘플을 하나 만들어가면서 해보면 빠르면 한두 시간 안에 필요한 라이브러리 파일을 모두 찾아낼 수 있을 것이다.&lt;/p&gt;

&lt;p&gt;이왕 이면 어떤 기능을 동작시켰을 때 어떤 클래스와 라이브러리가 필요했는지 기록해두면 나중에 도움이 된다. 단순하고 미련한 방법으로 보이겠지만 스프링 애플리케이션에서꼭 필요한 라이브러리를 찾는 데 가장 효과적인 방법이다.&lt;/p&gt;

&lt;p&gt;인터넷에서 jar 파일을 압축을 풀지 않고 검색하는 방법이나 Jar 파일 검색을 지원히는 툴을 찾아 시용해도 좋을것이다.&lt;/p&gt;

&lt;p&gt;필요한 라이브러리가 없으면 애플리케이션이 동작하다가 에러가 나거나 아예 컴파일되지 않는다. 반대로 필요하지 않은 라이브러리가 있을 땐 아무런 문제가 발생하지 않는다. 하지만 불필요한 라이브러리를 추가해두는 것은 또 다른 위험이 있다.&lt;/p&gt;

&lt;p&gt;때로는 무작정 모든 라이브러리 파일을 다 추가해놓고 사용하는 개발자도 있다. 그 때문에 애플리케이션 모률의 파일 크기가 커지는 것은 물론이고 이후에 라이브러리를 관리히는데 심각한애를먹을수도 있다.&lt;/p&gt;

&lt;p&gt;때로는 의존라이브러리의 버전충돌문제처럼 풀기 어려운 문제가 발생하기도 한다. 따라서 불필요한 라이브러리는 처음부터 추가하지 않아야 하며, 사용 기술이나 기능이 변경돼서 불필요해진 라이브러리도 바로 제거할 수 있도록노력해야만한다.&lt;/p&gt;

&lt;p&gt;물론 라이브러리 관리는 어떤 방법을 쓰더라도 간단하지 않다. 이미 만들어진 다양한 프레임워크와 라이브러리의 조합으로 애플리케이션을 만드는 시대이기 때문이다.&lt;/p&gt;

&lt;p&gt;또 빠르게 업데이트되는 기술과 버전이 주는 부담도 있다. 부록 A와 부록 B 에 나오는 의존관계 정보를 참고해서 성실하고 꼼꼼하게 필요한 라이브러리와 모ㅠ듈을 찾아 사용 하는길이 최선이다.&lt;/p&gt;

&lt;h1 id=&quot;93-애플리케이션-아키텍처&quot;&gt;9.3 애플리케이션 아키텍처&lt;/h1&gt;

&lt;p&gt;클라이언트와 백엔드 시스템의 종류와 사용 기술, 연동 방법을 결정했다면 시스탬 레벨의 아키텍처는 대략 구성된 셈이다. 다음으로 결정할 사항은 스프링 웹 애플리케이션의 아키텍처다.&lt;/p&gt;

&lt;p&gt;아키텍처는 여러 가지 방식으로 정의되고 이해될 수 있는 용어다. 가장 단순한 정의를 보자면 어떤 경계 안에 있는 내부 구성요소들이 어떤 책임을 갖고 있고, 어떤 방식으로 서로 관계를 맺고 동작하는지를 규정히는 것이라고 할 수 있다.&lt;/p&gt;

&lt;p&gt;아키텍처는 단순히 정적인 구조를 나타내는 것으로만 생각하기 쉽지만 실제로는 그 구조에서 일어나는 동적인 행위와 갚은 관계가 있다.&lt;/p&gt;

&lt;h2 id=&quot;931-계층형-아키텍처&quot;&gt;9.3.1 계층형 아키텍처&lt;/h2&gt;

&lt;p&gt;관심, 책임, 성격이 변하는 이유와 방식이 서로 다른 것들을 분리함으로써 분리된 각 요소의 응집도는 높여주고 서로의 결합도를 낮춰췄을 때의 장점과 유익이 무엇인지 살펴 봤다.&lt;/p&gt;

&lt;p&gt;성격이 다른모듈이 강하게 결합되어 한데 모여 있으면 한가지 이유로 변경이 일어날때 그와 상관이 없는 요소도 함께 영향을 받게 된다. 따라서 불필요한 부분까지 변경이 일어나고 그로 인해 작업은 더뎌지고 오류가 발생할 가능성이 높아진다.&lt;/p&gt;

&lt;p&gt;어느 부분을 수정해야 할지를 파악하기도 쉽지 않다. 따라서 인터페이스와 같은 유연한 경계를 만들어두고 분리하거나 모아주는 작업이 필요하다.&lt;/p&gt;

&lt;h3 id=&quot;아키텍처와-soc&quot;&gt;아키텍처와 SoC&lt;/h3&gt;

&lt;p&gt;지금까지는 주로 오브젝트 레벨에서 이런 분리의 문제에 대해 생각해봤다. 성격이 다른 코드가 얽혀 있는 것을 두 개의 오브젝트로 분리하고, 그 사이에 유연한 결합을 가질 수있도록 인터페이스를 두고 그 관계를 맺어주는 제 3 의 존재인 DI 컨테이너를 둬서 오브젝트 끼리는 직접적인 관계를 알지 못하도록 만드는 것이 지금까지 해온 DI를 기반으로한 유연한 설계와 구현 전략이었다.&lt;/p&gt;

&lt;p&gt;이런 원리는 아키텍처 레벨에서 좀 더 큰 단위에 대해서도 동일하게 적용할 수 있다. 오브젝트를 하나의 모듈단위라고 생각해보자. 때론 그보다 작은 단위, 예를 들면 하나의 클래스 안에 있는 메소드 레벨에서도 같은 원리를 적용할 수 있다. 심지어 하나의 메소드 안의 코드에도 같은 방식의 접근이 가능하다. 반대로 모듈의 단위를 크게 확장해 볼수도있다.&lt;/p&gt;

&lt;p&gt;애플리케이션을 구성하는 오브젝트들을 비슷한 성격과 책임을 가진 것들끼리 묶을수 있다.&lt;/p&gt;

&lt;p&gt;예를 들면 데이터 액세스 로직을 담당하는 DAO들은 하나의 단위로 생각해도 좋다. 어떤 DAO든 비슷한 성격을 띠고 유사한 방식으로 다른 오브젝트와 관계를 갖는다.  또 비즈니스 로직을 구현해놓은 비즈니스 서비스 오브젝트들도 같은 성격으로 묶을수 있다. 서비스 오브젝트들은 특정 기술과 환경에 종속되지 않으면서 도메인의 업무에는 밀접하게 관련을 갖고 있는 POJO로 만들어진다.&lt;/p&gt;

&lt;p&gt;주로 DAO를 이용해 정보의 저장과 검색 등을하고, DB 의 엔티티 모델과 유사한 도메인 오브젝트를 이용해 데이터를 저장하고 가공하고 주고받는다. 아직 다루진 않았지만 웹을 처리히는 코드 또한 독자적인 성격으로 분류가 가능하다.&lt;/p&gt;

&lt;p&gt;서블릿 컨테이너로부터 받은 사용자의 요청정보를 해석해서 그것을 POJO 기반의 서비스 오브젝트에 전달해주고, 결과를 받아서 다시 웹 사용자 인터페이스에 표시 가능한 형태로 변환해주는 일을 한다.&lt;/p&gt;

&lt;p&gt;이렇게 애플리케이션의 오브젝트들은 다시 유사한 성격을 띤 그룹으로 나눌 수가 있다. 만약 이렇게 나뉘어 있지 않다면 어떻게 될까?&lt;/p&gt;

&lt;p&gt;DB 에서 정보를 어떻게 가져오는지에 대한 로직을 담은 SQL과, JDBC 코드와 HTML 태그 사이에 읽어온 정보를 넣는 코드가 함께 존재할 수도 있다.&lt;/p&gt;

&lt;p&gt;성격과 책임이 분명히 다른 것들이 한데 모여 얽혀 있으면 많은 문제가 발생한다.&lt;/p&gt;

&lt;p&gt;JSP 만으로 웹 애플리케이션을 작성해본 경험이 있는 사람이라면 이런 문제점을 잘 알고 있을 것이다. 테이블을 어떻게 그리는지를 &amp;lt;table&amp;gt; 태그로 작성하다가, 업무 로직에 따라 값을 계산하기 위해 &amp;lt;% if %&amp;gt; 문을 넣었다가, DB 접속을 위해 &amp;lt;% getConnection( … ) %&amp;gt;을 써서 커넥션을 가져오고 SQL도 적고, 결과에 따라서 다른 화면으로 넘어가게 하는 조건도 달고 … 급한 마옴에 일단 동작은 하도록 어떻게 해서든 만들기는 했지만 나중에 자신이 만든 코드도 다시 손대기 싫을 만큼 지저분한 것을 보고는 차라리 다시 작성하는 편이 빠르겠다고 생각했을지 모르겠다.&lt;/p&gt;

&lt;p&gt;그래서 성격이 다른 것은 아키텍처 레벨에서 분리해주는 게 좋다. 이렇게 분리된 각 오브젝트는 독자적으로 개발과 테스트가 가능해서 개발과 변경 작업이 모두 빨라질 수있다. 또 구현 방법이나 세부 로직은 서로 영향을 주지 않고 변경될 수 있을 만큼 유연하다. 전체를 이해하기도 상대적으로 쉽다. 물론 아주 간단한 Hello World 정도의 프로 그램이라면 JSP 하나에 모아놓고 만드는 게 더 쉬울지 모르지만, 제대로 된 게시판 하나만 만들려고 해도 적절한 분리는 필수다.&lt;/p&gt;

&lt;p&gt;이렇게 책임과 성격이 다른 것을 크게 그룹으로 만들어 분리해두는 것을 아키텍처 차원에서는 계층형 아키택처 layered architecture 라고 부른다.&lt;/p&gt;

&lt;p&gt;또는 계층이라는 의미를 가진 영어 단어인 티어 tier를 써서 멀티티어 아키텍처라고도 한다. 보통 웹 기반의 엔터프라이즈 애플리케이션은 일반적으로 세 개의 계층을 갖는다고 해서 3계층 애플리케이션이라고도 한다. 물론 반드시 모든 엔터프라이즈 애플리케이션을 3계층으로 만들어야만 하는 것은 아니다. 경우에 따라서 전통적인 3계층 방식이 아닌 다른 구분 방법을 선택하기도 한다.&lt;/p&gt;

&lt;p&gt;또 각 계층을 좀 더 세분화해서 더 작은 단위의 계층으로 나눌 수도 있다. 하지만 전형 적인 웹 엔터프라이즈 애플리케이션은 책임과 성격으로 보자면 일단 3계층의 논리적인 분류가 기능하다. 그것을 물리적으로 또는 전략적으로 세분화하거나 또는 더 결합시켜서 만들 수도 있기는 하지만 그래도 각기 다른 세 가지 특성을 가진 코드의 분류는 여전히 유효하다.&lt;/p&gt;

&lt;h3 id=&quot;3계층-아키텍처와-수직-계층&quot;&gt;3계층 아키텍처와 수직 계층&lt;/h3&gt;

&lt;p&gt;3계층 아키텍처는 백엔드의 DB나 레거시 시스템과 연동히는 인터페이스 역할을 하는 데이터 액세스DataAccess 계층, 비즈니스 로직을 담고 있는 서비스 계층, 주로 웹 기반의 UI를 만들어내고 그 흐름을 관리하는 프레젠테이션 계층으로 구분한다.&lt;/p&gt;

&lt;p&gt;그런데 이 3계층 아키텍처의 각 계층을 부르는 이름은 워낙 다양해서 때론 혼란스러울 수도 있다. 각각 의미가 있는 이름이기 때문에 모두 기억해두고 사용히는 것이 좋다. 그림 9-13 은 3계층 아키텍처의 구조와 그 이름을 보여준다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7d3b02f9-e0f3-43c8-b9dc-f8129a0e4c7b/Untitled.png&quot; alt=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7d3b02f9-e0f3-43c8-b9dc-f8129a0e4c7b/Untitled.png&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;데이터액셰스-계층&quot;&gt;데이터액셰스 계층&lt;/h3&gt;

&lt;p&gt;데이터 액세스 계층은 DAO 계층이라고도 불린다. DAO 패턴을 보편적으로 시용하기 때문이다.&lt;/p&gt;

&lt;p&gt;또한 데이터 액세스 계층은 DB 외에도 ERP , 레거시 시스템, 메인프레임 등에 접근하는 역할을 하기 때문에 EIs(Enterprise Information System)계층이 라고도 한다.&lt;/p&gt;

&lt;p&gt;하지만 대개는 장기적인 데이터 저장을 목적으로 하는 DB이용이 주된 책임이 다. 또 외부 시스템을 호출해서 서비스를 이용하는 것은 기반(infrastructure) 계층으로 따로 분류하기도 한다. 따라서 이 책에서는 데이터 액세스 계층이라고 부르겠다.&lt;/p&gt;

&lt;p&gt;데이터 액세스 계층은 사용 기술에 따라서 다시 세분화된 계층으로 구분될 수 있다. 애플리케이션에서 담당하는 역할에 따라 분류한 3계층 구조와 달리, 데이터 액세스계층 안에서 다시 세분화히는 경우는 추상화 수준에 따른 구분이기 때문에 수직적인 계층이라고 부르기도 한다. 기본 3계층은 기술 계층보다는 역할에 따라 구분한 것이므로 보통 그림으로 나타낼 때도 가로로 배열한다.&lt;/p&gt;

&lt;p&gt;반면에 같은 책임을 가졌지만 추상화 레벨에 따라 구분하는 경우는 세로로 배열해서 표현한다. 스프링의 JdbcTemplate을 사용히는 DAO 계층이라면 그림 9-14와 같이 나타낼 수 있다. 이렇게 계층이라는 말은 각각 다른 의미와 상햄서 쓰일 수 있으니 문맥에 맞게 적절한 의미로 이해해야 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8c170ec3-279a-4bf2-97ee-511fff9776b6/Untitled.png&quot; alt=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8c170ec3-279a-4bf2-97ee-511fff9776b6/Untitled.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;JdbcTemplate을 사용히는 데이터 액세스 계층의 특정은 JdbcTemplate 이 추상화를 위한 계층으로 사용돼서 로우레벨의 기반 계층에 존재하는 JDBC와 드라이버, 스프링의 트랜재션 추상화 서비스의 동기화 기능을 간접적으로 이용하게 만든다는 것이다.&lt;/p&gt;

&lt;p&gt;물론 JdbcTemplate이 있어도 DAO 코드에서 강제로 JDBC API를 직접 이용하거나 트랜잭션 동기화 API에 접근하는 것이 불가능하진 않다.&lt;/p&gt;

&lt;p&gt;하지만 추상화 계층구조를 따른다면 항상 JdbcTemplate을 통해 접근하도록 코드를 작성하는 것이 바람직하다. 추상화 계층은 필요하다면 얼마든지 추가할 수 있다. 만약 JdbcTemplate 의 기능과 7장에서 만들었던 SqlService 의 SQL을 가져오는 기능을 묶어서 더 단순한 방법으로 DAO 코드를 작성하고 싶다면 또 하나의 추상 계층을 추가할 수 있다.&lt;/p&gt;

&lt;p&gt;그림 9-15 는 이렇게 새로운 추상 계층을 도입해서 하위 계층의 종류가 다른 서비스를 일관된 방식으로 접근할 수 있게 만들어주는 구조다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f563bf73-0873-4d87-a302-6682e213b0dc/Untitled.png&quot; alt=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f563bf73-0873-4d87-a302-6682e213b0dc/Untitled.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이렇게 새로운 계층을 추가하면 개발자의 애플리케이션 코드에 지대한 영향을 주기 때문에 매우 신중하게 결정해야 한다. 한번 새로운 계층과 API를 만들어 적용하면 이를 최대한 유지할 수 있도록 하위 계층의 변화에 대응해야 하는 책임도 갖게 된다. DAO 코드의 사용 패턴을 개발팀 또는 프로젝트 수준에서 잘 분석하고 정리할 수 있다면 새로운 추상 계층의 도입을 고려해볼 만하다. 만약 추상 계층을 새로 추가하는 것은 부담스럽고 경우에 따라서 유연하게 하위 계층의 API 를 활용할 필요가 있다면, 공통적인 기능을 분리해서 유틸리티나 헬퍼 메소드 또는 오브젝트로 제공해주는 것도 좋은 방법이다. 이때는 하위 계층과 공통 기능의 사용 방법에 대한 가이드라인이나 코딩 정책이 잘 만들어져서 개발자에게 제공될 필요가 있다.&lt;/p&gt;

&lt;h3 id=&quot;서비스계층&quot;&gt;서비스계층&lt;/h3&gt;

&lt;p&gt;서비스 계층은 구조로 보자면 가장 단순하다. 잘 만들어진 스프링 애플리케이션의 서비스계층 클래스는 이상적인 POJO로 작성된다.&lt;/p&gt;

&lt;p&gt;POJO로 만든다면 객체지향적인 설계기법이 적용된 코드를 통해서 비즈니스 로직의 핵심을 잘 담아내고, 이를 쉽게 테스트하고 유연하게 확장할 수 있다. 서비스 계층은 DAO 계층을 호출하고 이를 활용해서 만들어진다.&lt;/p&gt;

&lt;p&gt;때론 데이터 액세스를 위한 기능 외에 서버나 시스템 레벨 에서 제공하는 기반 서비스를 활용할 필요도 있다.&lt;/p&gt;

&lt;p&gt;예를 들어 웹 서비스와 같은 원격 호출을 통해 정보를 가져오거나 메일 또는 메시징 서비스를 이용하는 것이 대표적인 예다. 이런 기반 서비스는 3 계층 어디에서나 접근이 가능하도록 만들 수도 있고， 아키텍처를 설계하기에 따라서 반드시 서비스 계층을 통해 사용되도록 제한할 수도 있다. 코드의 특정과장단점 활용 예를 잘 살펴서 결정하면 된다. 서비스 계층은 특별한 경우가 아니라면 추상화 수직 계층구조를 가질 필요가 없다. 단순히 POJO 레벨에서 비즈니스 로직을 모델링하다가 상속구조를 만들 수 있을진 몰라도 기술 API를 직접 다루는 코드가 아니기 때문에 기술에 일관된 방식으로 접근하게 하거나 편하게 사용하게 해주는 추상화는 필요 없기 때문이다.&lt;/p&gt;

&lt;p&gt;기반 서비스 계층을 사용하는 경우에도 데이터 액세스 계층을 사용하는 경우와 마찬가지로 독립된 계층의 서비스를 이용하는 것으로 봐야 한다.&lt;/p&gt;

&lt;p&gt;비즈니스 로직을 담은 서비스 계층과 엔터프라이즈 서비스를 제공하는 기반 서비스 계층은 이름 때문에 혼동되기 쉬우므로주의하자.&lt;/p&gt;

&lt;p&gt;그림 9-16은 서비스 계층과 기반 서비스 계층 DAO 계층의 관계를 나타낸 것이 다. 여기서는 기반 서비스 계층이 3계층 어디에서나 접근이 가능한 구조로 설정했다. 여기서 눈여겨봐둘 것은 기반 서비스 계층이 서비스 계층의 오브젝트를 호출히는 경우다. 일반적으로는 서비스 계층이 필요에 따라 기반 서비스 계층의 API를 호출해서 이용한다.&lt;/p&gt;

&lt;p&gt;하지만 반대로 서비스 계층의 코드를 기반 서비스 계층에서 실행시키는 경우가 있다.&lt;/p&gt;

&lt;p&gt;스케줄링이 대표적인 경우다. 미리 정해진 시간에 특정 서비스 계층의 로직이 동작하게 만드는 백그라운드 서비스가 필요하다면 그때는 기반 서비스 계층에서 서비스 계층의 오브젝트를 이용하게 할 수도 있다.&lt;/p&gt;

&lt;p&gt;원칙적으로 서비스 계층 코드가 기반 서비스 계층의 구현에 종속되면 안 된다. 서비스 계층의 코드는 추상화된 기반 서비스 인터페이스를 통해서만 접근하도록 만들 어서 특정 구현과 기술에 대한 종속성을 제거해야 한다. 또는 AOP를 통해서 서비스 계층의 코드를 침범하지 않고 부가기능을 추가하는 방법을 활용해야 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3240441b-c84f-4666-9e64-a9e3fc1b40d8/Untitled.png&quot; alt=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3240441b-c84f-4666-9e64-a9e3fc1b40d8/Untitled.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이상적인 서비스 계층은 백엔드 시스템과 연결되는 데이터 액세스 계층이 바뀌고, 클라이언트와 연결되는 프레젠테이션 계층이 모두 바뀌어도 그대로 유지될 수 있어야 한다. 엔터프라이즈 애플리케이션에서 가장 중요한 자산은 도메인의 핵심 비즈니스 로직이 들어 있는 서비스 계층이어야 한다&lt;/p&gt;

&lt;h3 id=&quot;프레젠테이션계충&quot;&gt;프레젠테이션계충&lt;/h3&gt;

&lt;p&gt;프레젠테이션 계층은 가장 복잡한 계층이다. 프레젠테이션 계층은 매우 다양한 기술과 프레임워크의 조합을 가질 수 있다.&lt;/p&gt;

&lt;p&gt;웹과 프레젠테이션 기술은 끊임없이 발전하고 진보하고 새로운 모댈이 등장하기 때문이다. 따라서 프레젠태이션 계층에서 사용할 기술과 구조를 선택하는 일은 간단하지 않다.&lt;/p&gt;

&lt;p&gt;엔터프라이즈 애플리케이션의 프레젠테이션 계층은 클라이언트의 종류와 상관없이 HTTP 프로토콜을 사용하는 서블릿이 바탕이 된다. HTTP 외의 프로토콜을 사용하는 엔터프라이즈 서비스가 전혀 없는 것은 아니지만, 방화벽 문제라든가 통합된 보안의 문제 등으로 인해 HTTP로 모두 수렴되는추세다.&lt;/p&gt;

&lt;p&gt;단순한 HTML과 자바스크립트만을 사용하는 브라우저이든, 다운로드돼서 브라우저의 플러그인 안에서 동작하는 플래시 애플리케이션이나 액티브X 기반의 애플리케이션이든, 닷넷으로 만든 독립형 애플리케이션이든, RESTful 스타일의 클라이언트 또는 WS-* 방식의 웹 서비스 클라이언트든 상관없이 대부분의 엔터프라이즈 애플리케이션을 사용하는 클라이언트들은 HTTP 프로토콜을 선호한다.&lt;/p&gt;

&lt;p&gt;따라서 이런 클라이언트와 연결돼서 동작하는 프레젠테이션 계층은 자바에서 HTTP 프로토콜을 처리하는 가장 기본 엔진이 서블릿 기술을 바탕으로 한다.&lt;/p&gt;

&lt;p&gt;프레젠테이션 계층은 다른 계층과 달리 클라이언트까지 그 범위를 확장될 수도 있다. 초기 클라이언트 모댈은 단순히 HTML로 만들어진 결과를 사람이 볼 수 있도록 그려주고, 폼을 통해 입력받은 값을 전달하는 것이었다. 모든 프레젠테이션 로직은 서버의 프레젠테이션 계층의 컴포넌트에서 처리된다. 화면 흐름을 결정하는 것이나 사용자 입력 값에 대한 검증, 서비스 계층의 호출과 전달되는 값의 포맷의 변화， 뷰View라고 불리는 화면을 어떻게 그릴지에 대한 로직 등이 모두 서버에서 처리됐다.&lt;/p&gt;

&lt;p&gt;이때의 클라이언트는 단순히 서버 프레젠테이션 계층의 기능에 대한 사용자 인터페이스에 불과했다. 하지만 최근에는 점점 많은 프레젠테이션 로직이 클라이언트로 이동하고 있다. RIA (Rich Internet Application) 라고 불리는 기술이나 SOFEA(Service Oriented Front End Architecture) 아키텍처가 대표적인 예다.&lt;/p&gt;

&lt;p&gt;스프링은 웹 기반의 프레젠테이션 계층을 개발할 수 있는 전용 웹 프레임워크를 제공한다. 동시에 스프링은 다양한 서드파티 웹 기술을 지원하기도 한다. 아예 프레젠테이션 계층을 통째로 스프링이 아닌 다른 웹 기술을 가져다 사용할 수도 있다. 스프링 애플리케이션에 적용할 수 없는 웹 기술은 없다고 봐도 좋다. 심지어 JSP를 사용히는 모델 l 을 사용할 수도 있으니 말이다.&lt;/p&gt;

&lt;h3 id=&quot;계층형-아키텍처-설계의-원칙&quot;&gt;계층형 아키텍처 설계의 원칙&lt;/h3&gt;

&lt;p&gt;오브젝트와 그 관계에 적용했던 대부분의 객체지향 설계의 원칙은 아키텍처 레벨의 계층과 그 관계에도 동일하게 적용할 수 있다. 각 계층은 응집도가 높으면서 다른 계층과는 낮은결합도를 유지할수있어야한다.&lt;/p&gt;

&lt;p&gt;각 계층은 자신의 계층의 책임에만 충실해야 한다. 데이터 액세스 계층은 데이터 액세스에 관한 모든 것을 스스로 처리해야 한다. 데이터 액세스 계층에 비즈니스 로직을 담거나 웹 파라미터를 파싱하는 코드나 결과를 화면에 어떻게 뿌릴지 결정히는 코드가 들어간다면 응집도가 낮아진다.&lt;/p&gt;

&lt;p&gt;결과적으로 변화에 대한 유연성이 떨어지고 이해하기 힘든 코드를 가진 계층이 되고 말 것이다. 각 계층은 자신의 역할에만 충실해야 하고 자신과 관련된 기술이 아닌 다른 기술 API 의 사용을 삼가해야 한다. 자신의 역할과 기술에만 충실한 계층을 만들면 각 계층 사이의 결합도는 자연스럽게 낮아진다.&lt;/p&gt;

&lt;p&gt;각 계층이 자신의 책임에 충실하게 작성되어 있다면 필요한 그 밖의 작업은 다른 계층에 요청하게 될 것이다.&lt;/p&gt;

&lt;p&gt;이때는 계층 레벨에 정의한 인터페이스를 통해서 요청을 하게 되고, 계층 간에 사용되는 인터페이스 메소드에는 특정 계층의 기술이 최대한 드러나지 않게 만들어야 한다. 그렇지 않으면 계층 사이에 결합도가 높아질 뿐만 아니라, 계층 간의 기술이나 역할이 서로 침범히는 일이 일어난다.&lt;/p&gt;

&lt;p&gt;종종 실수하는 계층 간 설계의 예를 살펴보자. 다음은 서비스 계층이 DAO를 호출할때 사용하도록 정의한 인터페이스의 메소드다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ResultSet&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;findUsersByName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SQLException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;findUsersByName() 메소드의 문제는 데이터 액세스 계층의 기술과 그 역할을 다른 계층에 노출한다는 점이다.&lt;/p&gt;

&lt;p&gt;결과를 JDBC 의 ResultSet 오브젝트로 돌려주면 이를 사용 하는 서비스 계층의 코드는 ResultSet 이라는 데이터 액세스 계층에서 만들어진 오브젝 트를 직접 다뤄야만 한다. 결국 JDBC 라는 특정 데이터 액세스 계층 기술에 종속되는 서비스 계층의 코드가 되고 만다.&lt;/p&gt;

&lt;p&gt;또한 ResultSet 을 다룰 때 발생하는 예외처리도 필요 하고, 경우에 따라서는 리소스를 반환하거나   DB 커넥션을 종료시키는 등의 데이터 액세스 작업도 맡아야 한다. 예외도 마찬가지다. 앞에서 살펴봤듯이 SQLException 이라는 JDBC 기술 종속 적인 예외를,  그것도 체크 예외로 던져버리면, 이를 사용하는 서비스 계층에서는 SQLException을 해석해서 예외상황을 분석하고 이를 처리하는 코드를 만들어야 한다.&lt;/p&gt;

&lt;p&gt;특정 데이터 액세스 계층의 구현에 종속되는 강한 결합이 만들어진다. 계층 간에 강한 결합이 생기면 유연성이 떨어지기 때문에 각 계층의 내부 구현이 변화되면 다른 계층의 묘드도 함께 수정해줘야 한다. 또한 코드의 중복이 일어날 가능성이 높고 전체 묘드를 이해하기는 힘들어진다. 오브젝트 간의 강한 결합이 있을 때 발생 하는 문제와 성격이 유사하고 그 파장은 훨씬 심각하다.&lt;/p&gt;

&lt;p&gt;계층에는 수많은 오브젝트가 있고 그 오브젝트가 다른 계층의 오브젝트와 어떻게 관계를 맺는지에 대한 일반적인 규칙이 있기 때문이다. 앞의 DAO 인터페이스의 메소드는 다음과 같이 수정돼야 한다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;findUsersByName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DataAccessException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;User는 사용자 정보를 담고 있는 단순한 오브젝트다. 따라서 특정 계층의 기술이나 구현에 종속되지 않는다. 결과는 이렇게 특정 계층에 종속되지 않는 단순한 오브젝트의 형태로 전달해야 한다. 또 데이터 액세스 예외와 같이 특별한 경우에만 전달될 기능성이 있는 것은 스프링의 DataAccessException 처럼 런타임 예외로 만들어야 한다.&lt;/p&gt;

&lt;p&gt;그래서 대개는 그 존재를 무시해도 되도록 만들어야 한다. 특별한 이유로 데이터 액세스 예외를 다뤄야 히는 경우에라도 JOBC , JPA , JDO , 하이버네이트처럼 특정 구현 방식에 종속되지 않는 추상적인형태로 만들어줘야 한다.&lt;/p&gt;

&lt;p&gt;그렇게 해야만 낮은 결합도를 유지할수 있고유연한변경이 가능해진다.&lt;/p&gt;

&lt;p&gt;또， 흔히 저지르는 실수 중의 하나는 프레젠테이션 계층의 오브젝트를 그대로 서비스 계층으로 전달하는 것이다. 서블릿의 HttpServletRequest 나 HttpServletResponse HttpSession 같은 타입을 서비스 계층 인터페이스 메소드의 파라미터 타입으로 사용하면 안된다.&lt;/p&gt;

&lt;p&gt;계층의 경계를넘어갈때는반드시 특정 계층에종속되지 않는 오브젝트 형태로 변환해줘야한다.&lt;/p&gt;

&lt;p&gt;만약 서비스 계층의 코드에 웹 프레젠테이션 계층의 기술을 노출했다고 해보자. 웹방식의 클라이언트가 아닌 다른 시스템에서 요청을 받아서 처리해야 하는 경우에는 웹기술에 종속된 코드는 재사용이 불가능해진다.&lt;/p&gt;

&lt;p&gt;결국 같은 로직을 가졌지만 클라이언트의 종류에 따라서 비즈니스 로직 코드가 달라지는 결과를 초래할 수도 있다. 서비스 계층에서 웹과 관련된 예외가 발생할 수도 있다. 이때 문제의 원인을 찾기가 어려워지기 쉽다. 더 큰 문제는 테스트다. 서비스 계층에 웹 관련 오브젝트가 존재하면 POJO 기반의 빠르고 간단한 단위 테스트를 작성하기 힘들어진다.&lt;/p&gt;

&lt;p&gt;어떤 경우에라도 계층 사이의 낮은 결합도를 깨뜨리지 않도록 설계해야 한다.&lt;/p&gt;

&lt;p&gt;당연히 계층 사이의 호출은 인터페이스를 통해 이뤄져야 한다. 인터페이스를 하나 더 만드는 것이 번거롭다고 그냥 클래스를 이용해서는 안 된다.&lt;/p&gt;

&lt;p&gt;인터페이스를 사용하게 한다는건 각 계층의 경계를 넘어서 들어오는 요청을 명확히 정의하겠다는 의미다. 여기서 말하는 인터페이스란 단지 자바의 interface 키워드를 사용하라는 의미가 아니다. 인터 페이스에 아무 생각 없이 클래스의 모든 public 메소드를 추가한다면 인터페이스를 사용하는 가치가 떨어진다.&lt;/p&gt;

&lt;p&gt;한번 정의돼서 다른 계층에서 사용하기 시작한 엔터페이스 메소드는 변경이 매우 까다롭고 비용이 많이 든다. 따라서 매우 신중하게 결정해야 하며 계층 내부의 예상되는 변화에도 쉽게 바뀌지 않도록 주의해서 만틀어야 한다. 당연히 다른 계층에서 꼭 필요한 메소드만 노출해야 한다.&lt;/p&gt;

&lt;p&gt;스프링의 DI 는 기본적으로 오브젝트 사이의 관계를 다룬다. 따라서 계층 사이의 경계나 그 관계에 직접적으로 관여하지 않는다. 하지만 모든 경계에는 오브젝트가 존재하고 그 사이의 관계도 오브젝트 대 오브젝트로 정의되기 마련이다. 그런 면에서 스프링의 DI가 계층사이의 관계에도 적용된다고볼수 있다. 하지만 DI는 계층을구분해주지 않기 때문에 빈 사이의 의존관계를 만들 때 주의해야 한다.&lt;/p&gt;

&lt;p&gt;한 계층의 내부에서만 사용 되도록 만든 빈 오브젝트가 있는데 이를 DI 를 통해 다른 계층에서 함부로 가져다 쓰는 일은 피해야 한다는 말이다. 또, 중간 계층을 건너뛰어서 관계를 갖지 않는 계층의 빈을 직접 DI 하지 않도록주의해야한다.&lt;/p&gt;

&lt;h2 id=&quot;932-애플리케이션-정보-아키텍처&quot;&gt;9.3.2 애플리케이션 정보 아키텍처&lt;/h2&gt;

&lt;p&gt;엔터프라이즈 시스템은 본질적으로 동시에 많은 작업이 빠르게 수행돼야 하는 시스템이다. 사용자의 작업 상태를 오래 유지할 수 있는 독립 애플리케이션과 달리 엔터프라이즈 애플리케이션은 일반적으로 사용자의 요청을 처리하는 동안만 간단한 상태를 유지한다.&lt;/p&gt;

&lt;p&gt;애플리케이션의 주요 상태정보는 클라이언트나 백엔드 시스템에 분산돼서 보관된다. 비교적 장기간 보관되는 상태정보는 주로 DB 나 메인프레임 같은 EIS 백엔드 시스랩에 저장된다.&lt;/p&gt;

&lt;p&gt;하나의 업무 작업이 여러 번의 요청과 페이지에 걸쳐 일어나는 경우에 유지돼야 하는 임시 상태정보는 클라이언트에 일시적으로 보관되기도 하고 서버의 사용자별 세션 메모리에 저장되기도 한다.&lt;/p&gt;

&lt;p&gt;이렇게 애플리케이션을 사이에 두고 흘러다니는 정보를 어떤 식으로 다룰지를 결정하는 일도 아키텍처를 결정할 때 매우 중요한 기준이 된다.&lt;/p&gt;

&lt;p&gt;엔터프라이즈 애플리케이션에 존재하는 정보를 단순히 데이터로 다루는 경우와 오브젝트로 다루는 경우, 두 가지 기준으로 구분해볼 수 있다.&lt;/p&gt;

&lt;p&gt;데이터 중심 아키텍처는 애플리케이션에 흘러다니는 정보를 단순히 값이나 값을 담기 위한 목적의 오브젝트 형태로 취급히는 구조다 DB나 백엔드 시스템에서 가져온 정보를 값으로 다루고 그 값을 취급하는 코드를 만들어 로직을 구현하고 값을 그대로 프레젠태이션 계층의 뷰, 즉 사용자가 보는 화면과 연결해주는 것이다.&lt;/p&gt;

&lt;p&gt;이런 방식은 객체지향 기술이나 언어를 사용하지 않던 시절의 엔터프라이즈 애플리케이션과 크게 다를 바 없다.&lt;/p&gt;

&lt;p&gt;데이터 중심 설계의 특징은 비즈니스 로직이 DB 내부의저장 프로시저나 SQL 에 담겨 있는 경우가 많다는 점이다.&lt;/p&gt;

&lt;p&gt;보통 DB 에서 돌려주는 내용을 그대로 맵이나 단순 결과 저장용 오브젝트에 넣어서 전달한다. DB 결과 값을 사용 하는 일부 비즈니스 로직이 서비스 계층에 존재하기도 하고 아무런 가공 없이 그대로 프레젠테이션 계층에 전달되어 사용자에게 보이기도 한다.&lt;/p&gt;

&lt;p&gt;데이터 중심 아키텍처는 핵심 비즈니스 로직을 어디에 많이 두는지에 따라서 DB에 무게를 두는 구조와 서비스 계층의 코드에 무게를 두는 구조로 구분할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;dbsql-중심의-로직-구현-방식&quot;&gt;DB/SQL 중심의 로직 구현 방식&lt;/h3&gt;

&lt;p&gt;데이터 중심 구조의 특징은 하나의 업무 트랜잭션에 모든 계층의 코드가 종속되는 경향이 있다는 점이다. 예를 들어 사용자의 이름으로 사용자 정보를 검색해서 일치하는 사용자의 아이디, 비밀번호， 이름, 가입일자만을 보여주는 작업이 있다고하자.&lt;/p&gt;

&lt;p&gt;이것이 하나의 업무 단위가 되면 모든 계층의 코드가 이 기준에 맞춰서 만들어진다. 사용자 조회 라는 단위 업무를 위해서만 존재하는 각 계층의 코드가 만들어진다는 뜻이다.&lt;/p&gt;

&lt;p&gt;검색조건은 SQL로 만들어진다. 사용자 정보를 웹 페이지에 나타낼 때 가입일자 중에서 연도만 보여줘야 한다면, 가입일자 필드에서 연도를 추출하는 것은 SQL 의 날짜처리 펑션을 이용해야 한다.&lt;/p&gt;

&lt;p&gt;그래야 SQL의 결괴를 그대로 웹 페이지의 정보 필드에 1: 1로 매핑해서 넣어줄 수 있기 때문이다.&lt;/p&gt;

&lt;p&gt;결국 SQL은 이미 화면에 어떤 식으로 출력이 될지 알고 있는 셈이다.&lt;/p&gt;

&lt;p&gt;SQL 의 결과는 컬럼 이름을 키로 갖는 맵에 저장되거나 조회 페이지에 필요한 네 가지 정보를 담을 수 있는 단순한 오브젝트를 저장돼서 전달된다.&lt;/p&gt;

&lt;p&gt;서비스계층은 별로 할일이 없다. 프레젠테이션 계층의 JSP 뷰는 DAO의 SQL에서 정확히 어떤 펼드 값을 리턴할지, 어떤 포맷으로 전달할지 알고 있다.&lt;/p&gt;

&lt;p&gt;SQL의 SELECT 절에 나오는 컬럼 이름을 그대로 사용해서 전달된 맵이나 결과를 저장히는 오브젝트에서 값을 가져와 화면에 출력한다. 만약 새로운 필드가 추가되거나 DB 테이블의 컬럼 이름이 변경됐다면, 그에 따라서 맵이나 오브젝트에 저장될 엔트리 또는 프로퍼티 이름이 바뀌거나 추가될 것이 고 그에 맞게 뷰의 내용도 변경된다.&lt;/p&gt;

&lt;p&gt;모든 계층의 코드는 ‘이름을 이용한 고객 조회’라는 업무에 종속된다.&lt;/p&gt;

&lt;p&gt;또한 업무의 내용이 바뀌면 모든 계층의 코드가 함께 변경된다.&lt;/p&gt;

&lt;p&gt;종속적일 뿐 아니라 배타적이어서 다른 단위 업무에 재시용되기 힘들다. 유사한 방법의 사용자 조회용 DAO 메소드라도 화면에 나타날 정보가 다르면 SQL 이 달라지기 때문에 새로 만들어야 한다.&lt;/p&gt;

&lt;p&gt;대용량 데이터를 다루면서 빠른 처리가 필요한 경우에는 일부 로직을 DB 내에 존재하는 PL/SQL과 같은 저장 프로시저 형태로 만들기도 한다. 조회 로직이 조건이 많고 복잡하다면 그만큼 복잡한 SQL 이 만들어 질 것이다. 자바 코드의 로직은 기껏해야 사용자 요청에 따라서 어떤 SQL을 가진 DAO를 실행할지 를 결정히는 정도일 것이다.&lt;/p&gt;

&lt;p&gt;대부분의 코드는 대응되는작업 단위에 1 : 1 로 매핑된다. 여러 작업에서 반복되는 기능이 었다면 그에 대한 코드는 중복되기 쉽다. 보통 작업 단위,  즉 업무 트랜잭션 단위로 코드를 묶어서 만들지 기능을 세분화해서 분리하고 재사용하지 않기 때문이다. 하나의 업무 트랜잭션을 모두 담은 서비스 계층 코드와 해당 업무에 특화된 SQL을 담은 하나 또는 여러 개의 DAO 메 소드로 구성된다.&lt;/p&gt;

&lt;p&gt;서비스 계층이 프레젠테이션 계층에 전달 하는 결과의 포맷은 보통 DAO 의 SQL 결과와 같고, 웹페이지의 출력 내용과도 1: 1 로대응된다. 그림 9-17은 이런 방식의 아키텍처 구조를 나타낸다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/27a8efba-c9cd-4756-910a-01350fad4c63/Untitled.png&quot; alt=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/27a8efba-c9cd-4756-910a-01350fad4c63/Untitled.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이런 식의 개발 방법과 아키텍처는 사실 자바 기술이 발전하기 이전의 엔터프라이즈 시스템에서 흔히 발견할 수 있다. 굳이 자바라는 객체지향 언어와 프로그래밍 기술을 사용하지 않더라도 3계층구조로 만드는전통적인 개발방법에서, 또는 서비스계층이 별의미가 없으므로 주요로직을 클라이언트의 독립 프로그램에 담아두고 DB 처리 로직만 DB 에 분리해둔 2계층 구조에서도 비슷하게 발견할 수 있다.&lt;/p&gt;

&lt;p&gt;이런 방식은 개발하기 쉽다는 장점이 있다. 적어도 처음에는 그렇다.&lt;/p&gt;

&lt;p&gt;대부분의 개발 자는 이미 복잡한 로직을 SQL로 작성하는 데 익숙하다. 계층으로 세분화되기는 하지만 업무 트랜잭션, 또는 요구사항별로 구분해서 코드로 만드는 건 쉽다. 각 업무의 핵심을 담은 SQL을 중심으로 DAO부터 사용자가 보는 화면까지 한 벌씩 만들면 되기 때문에 툴이나 코드 생성기를 이용해서 자동화하는 데도 유리하다.&lt;/p&gt;

&lt;p&gt;하지만 이런 방식은 자바 코드를 단지 DB 와 웹 화면을 연 결 해주는 단순한 인터페이스 도구로 전락시키는 것이다. 자바의 오브젝트는 단지 HTTP 서비스 채널을 만들어주고 JDBC를 이용해 DB 기능을 사용하게 히는 스크립트 정도로 역할이 축소된다.&lt;/p&gt;

&lt;p&gt;굳이 자바를 쓰지 않고 전통적인 언어나 단순한 스크립트 언어 또는 DB 등에서 제공히는 툴로 대치하더라도 별 차이가 없을 것이다.&lt;/p&gt;

&lt;p&gt;이렇게 DB 중심의 업무 단위로 코드를 만들면 애플리케이션 내에서 흘러다니는 정보는 항상 단순한 포맷의 데이터다. 간혹 필요하다면 SQL 의 결과로 가져온 데이터를 분석하거나 조작히는 간단한 비즈니스 로직을 추가할 수는 있다. 하지만 이런 코드는 항상 SQL과 그 결과에 종속되기 때문에 SQL 의 변화가 일어나면 같이 변경돼야 한다.&lt;/p&gt;

&lt;p&gt;겉으로 보기에는 각 계층이 독립적으로 보이지만 그 사이를 이동하는 데이터가 일종의 접착제 역할을 해서 강한 결합을 만들게 된다.&lt;/p&gt;

&lt;p&gt;스프링을 사용하면 이런 데이터 중심의 코드를 만들 수 있을 뿐만 아니라, 실제로 매우 흔하게 발견된다. 데이터와 업무 트랜잭션 중심의 개발에 익숙한 사람들이 많고 이런 아키텍처를 의도적으로 선호히는 개발자도 많기 때문이다. 개발자들끼리 서로 간섭 없이 자신에게 할당된 기능을 독립적으로 만드는 데도 편하다. 최소한의 공통 모둘 정도만 제공되는 것을 사용하고 그 외의 기능은 단위 업무 또는 웹 화면 단위로 만들 어진다.&lt;/p&gt;

&lt;p&gt;하지만 이런 개발 방식은 변화에 매우 취약하다.&lt;/p&gt;

&lt;p&gt;객체지향의 장점이 별로 활용되지 못히는데다 각 계층의 코드가 긴밀하게 연결되어 있기 때문이다.&lt;/p&gt;

&lt;p&gt;중복을 제거하기도 쉽지 않다. 업무 트랜잭션에 따라 필드 하나가 달라도 거의 비슷한 DAO 메소드를 새로 만들기도 한다. 또한 로직을 DB 와 SQL 에 많이 담으면 담을수록 점점 확장성이 떨어진다. DB 는 확장에 한계가 있을 뿐 아니라 확장한다 하더라도 매우 큰 비용이 든다.&lt;/p&gt;

&lt;p&gt;잘 작성된 복잡한 SQL 하나가 수백 라인의 자바 코드가 펼요한 비즈니스 로직을 한번에 처리할수도 있다. 하지만과연 바람직한 것일까? 이런 복잡한 SQL을누구나 쉽게 이해하고필요에 따라유연하게 변경할수 있을까?&lt;/p&gt;

&lt;p&gt;또, 복잡한 SQL을처리하기 위해서 제한된 자원인 DB 에 큰 부담을 주는 게 과연 바람직한 일인지 생각해볼 필요가 있다.&lt;/p&gt;

&lt;p&gt;상대적으로 애플리케이션 서버와 그 안에 담긴 오브젝트는 비용이 적게 든다. 서버를 늘려 쉽게 확장할 수도 있다. 애플라케이션 서버의 비용은 매우 빠르게 하락하고 있다. 또 손쉽게 여러 대의 서버를 클러스터로 묶어서 하나의 서버처럼 동작하게 만들 수있다.&lt;/p&gt;

&lt;p&gt;오브젝트를 만들고 코드를 동작시키는 비용은 DB 에서 비슷한 작업을 할 때에 비해 저렴하다. 따라서 로직을 DB 보다는 애플리케이션으로 가져오는 편이 유리한 점이 많다. 비용도 저렴해질 뿐 아니라 안정성도 높아지고 코드를 검증하기도 매우 편하다.&lt;/p&gt;

&lt;p&gt;게다가. SQL 이나 저장 프로시저에 담긴 로직은 테스트하기 힘들다. 반면에 오브젝트에 담긴 로직은 간단히 검증할 수 있다. 또한 요즘 유행하는 객체지향 분석과 모델링의 결과로 나온 모델을 가져다 쉽게 오브젝트로 만들어낼 수 있다. 따라서 DB 에는 부하를 가능한 한 주지 않는 간단한 작업만 하고 복잡한 로직은 오브젝트에 담아서 애플리케이션 내에서 처리하도록 만드는 편이 낫다. 애플리케이션 서버는 저렴한 비용으로 손쉽게 서버를추가할수 있다.&lt;/p&gt;

&lt;p&gt;어쨌든 정치적이거나 현실적인 문제로 인해 이런 아키텍처와 접근 방법을 어쩔 수없이 선택해야 히는 경우도 있겠지만 단지 익숙하고 편하다는 이유로 스프링 애플리케이션 개발에도 여전히 DB 중심의 아키텍처를 선택한다면 스프링의 장점을 제대로 누릴수 있는 기회를 얻지 못할 것이 분명하다.&lt;/p&gt;

&lt;h3 id=&quot;거대한서비스계층방식&quot;&gt;거대한서비스계층방식&lt;/h3&gt;

&lt;p&gt;DB 에서 가져온 데이터가 애플리케이션에 흘러다니는 정보의 중심이 되는 아키텍처이긴 하지만 DB 에 많은 로직을 두는 개발 방법의 단점을 피하면서 애플리케이션 코드의 비중을 높이는 방법이 있다.&lt;/p&gt;

&lt;p&gt;DB 에는 부하가 걸리지 않도록 저장 프로시저의 사용을 자제하고 복잡한 SQL을 피하면서, 주요 로직은 서비스 계층의 코드에서 처리하도록 만드 는것이다.&lt;/p&gt;

&lt;p&gt;여전히 SQL 의 결과를 그대로 담고 있는 단순한 오브젝트 또는 맵을 이용해 데이터를 주고받는다. 대신 많은 비즈니스 로직을 DB 의 저장 프로시저나 SQL 에서 서비스 계층의 오브젝트로 옮겨왔기 때문에 애플리케이션 코드의 비중이 커진다. 그만큼 구조는 단순해지고 객체지향 개발의 장점을 살릴 기회가 많아진다.&lt;/p&gt;

&lt;p&gt;비즈니스 로직을 DB 나 SQL 에 담는 경우에는 항상 최종 결과만 DAO 에서 서비스 계층으로 전달된다. 반면에 거대 서비스 계층 방식에서는 DAO 에서 좀 더 단순한 결과를 돌려준다.&lt;/p&gt;

&lt;p&gt;DAO 가 돌려준 정보를 분석, 가공하면서 비즈니스 로직을 적용하는 것은 서비스 계층 코드의 책임이 된다. DAO와 SQL은 상대적으로 단순해지고, 그중 일부는 여러 서비스 계층 코드에서 재사용이 가능해진다.&lt;/p&gt;

&lt;p&gt;비즈니스 로직이 복잡해지면 서비스 계층의 코드도 매우 복잡해지고 커진다. 업무 트랜잭션 단위로 서비스 계층의 메소드가 만들어질 가능성이 높은데， 그러다 보면 하나의 메소드가 매우 거대해지기도 한다. 이를 여러 메소드로 분산시킨다면 메소드 크기는 상대적으로 줄겠지만 전체 클래스 코드의 양은 그대로다.&lt;/p&gt;

&lt;p&gt;상대적으로 단순한 DAO 로직을 사용하고, 비즈니스 로직의 대부분을 서비스 계층에 집중하는 이런 접근 방법은 결국 거대한 서비스 계층 ( Fat service layer) 을 만들게 된다. 데이터의 분석， 처리와 함께 비즈니스 로직의 대부분이 서비스 계층 코드에 집중되기 때문이다. 서비스 계층의 코드는 여전히 업무 트랜잭션 단위로 집중돼서 만들어지기 때문에 DAO를 공유할 수 있는 것을 제외하면 코드의 중복도 적지 않게 발생한다.&lt;/p&gt;

&lt;p&gt;그림 9-18은 거대 서비스 계층 방식의 아키텍처를 나타낸 것이다. 데이터 액세스 계층이나 DB 는 비즈니스 로직을 직접 담고 있지 않기 때문에 이전보다 훨씬 가벼워진다.&lt;/p&gt;

&lt;p&gt;대신 DB 가 돌려주는 데이터를 가지고 비즈니스 로직을 구현하는 서비스 계층이 매우 두터워진다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2ff6986e-d223-48e9-b1c2-aa9b31410398/Untitled.png&quot; alt=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2ff6986e-d223-48e9-b1c2-aa9b31410398/Untitled.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;거대 서비스 계층 방식의 장점은 애플리케이션의 코드에 비즈니스 로직이 담겨 있기 때문에 자바 언어의 장점을 활용해 로직을 구현할 수 있고 테스트하기도 수월하다는 점이다.&lt;/p&gt;

&lt;p&gt;또한 DAO가 다루는 SQL 이 복잡하지 않고 프레젠테이션 계층의 뷰와 1:1로 매핑 되지 않아도 되기 때문에 일부 DAO 코드는 여러 비즈니 스 로직에서 공유해서 사용할 수있다.&lt;/p&gt;

&lt;p&gt;하지만 데이터 액세스 계층의 SQL은 서비스 계층의 비즈니스 로직의 필요에 따라 만들어지기 쉽다. 그래서 계층 간의 결합도가 여전히 크다.&lt;/p&gt;

&lt;p&gt;서비스 계층의 메소드는 크기가 큰 업무트랜잭션 단위로 만들어지기 때문에 비슷한 기능의 코드가여러 메소드에서 중복돼서 나타나기 쉽다. 자주 사용되는 세부 로직을 추출해서 공통 기능으로 뽑아 내는 일도 불가능하진 않지만 일반화하기는 힘들다. 그 이유는 DAO가 제공해주는 값의 포맷에 따라 이 를 취급하는 방법이 달라지기 때문이다.&lt;/p&gt;

&lt;p&gt;사용자 정보를 간단히 조작해주는 공통적인 기능이 있다고 하자. 그런데 어떤 비즈니스 로직에서는 DAO로부터 시용자 정보를 다른 정보와 조인해서 함께 맵에 담아 가져오고， 또 어떤 로직에서는 사용자 정보 중 일부만 데이터 저장 오브젝트에 담아서 가져온다고 해보자. 이런 경우 사용자 정보가 담겨 있는 포뱃과 타입이 다르기 때문에 공통적인 사용자 정보 처리 기능을 만들어 사용하기가 힘들다.&lt;/p&gt;

&lt;p&gt;비록 DAO 에 복잡한 조건의 로직을 넣지는 않더라도 서비스 계층에서 필요한 정보를 한 번에 SQL을 통해 가져 오고, 그 값을 저장하는 방식이 일관성 없이 매번 달라질 수 있기 때문에 서비스 계층의 코드나 DAO 에 적지 않은 중복이 발생히는 것이다.&lt;/p&gt;

&lt;p&gt;반면에 각 단위 업무별로 독립적인 개발이 가능하므로 초기 개발 속도가 빠르고, 개발자 사이에 간섭 없이 독립적인 개발이 가능하다는 장점이 있다. 또한 핵심 로직이 자바코드 안에 담겨 있으므로 테스트하기가 상대적으로 수월하다.&lt;/p&gt;

&lt;p&gt;하지만 본격적인 객체 지향적 설계를 적용하기 힘들고, 개발자 개개인의 코딩 습관이나 실력에 따라서 비슷한 로직이더라도 전혀 다른 스타일의 코드가 나오기 십상이다. 개발 능력이 떨어지는 경우 에는 자바 코드로 구현한 비즈니스 로직이 복잡한 SQL보다 더 이해하기 힘들 수도 있다. 또한 계층별로 독립된 설계와 개발이 어렵고, 개발이 진행되면서 구현할 비즈니스 로직이나 설계에 변경이 생기거나 유지보수 중에 수정할 필요가 있을 경우 코드를 손대 기가 쉽지 않을 수 있다. 철저한 테스트를 만들어뒀다면 상대적으로 낫겠지만, 테스트가 불충분하거나 아예 없다면 오히려 SQL이나 저장프로시저보다 더 다루기 힘든 스파게티 코드로 전락할 위험도 있다.&lt;/p&gt;

&lt;p&gt;데이터 중심 아키텍처의 특정은 계층 사이의 결합도가 높은 편이고 응집도는 떨어진 다는 점이다. 화면을 중심으로 히는 업무 트랜잭션 단위로 코드가 모이기 때문에 처음엔 개발하기 편하지만 중복이 많아지기 쉽고 장기적으로 코드를 관리하고 발전시키기 힘들다는단점이있다.&lt;/p&gt;

&lt;h2 id=&quot;933-오브젝트-중심-아키텍처&quot;&gt;9.3.3 오브젝트 중심 아키텍처&lt;/h2&gt;

&lt;p&gt;오브젝트 중심 아키텍처가 데이터 중심 아키텍처와 다른 가장 큰 특징은 도메인 모델을 반영하는 오브젝트 구조를 만들어두고 그것을 각 계층 사이에서 정보를 전송하는 데 사용한다는 것이다.&lt;/p&gt;

&lt;p&gt;그래서 오브젝트 중심 아키텍처는 객체지향 분석과 모델링의 결과로 나오는 도메인 모델을 오브젝트 모델로 활용한다. 대개 도메인 모델은 DB의 엔티티 설계에도 반영되기 때문에 관계형 DB 의 엔티티 구조와도 유사한 형태일 가능성이 높다.&lt;/p&gt;

&lt;p&gt;물론 DB 에는 없지만 비즈니스로직에만 존재히는 모델도 있기 때문에 항상 일치하는 것은아니다. 이렇게 오브젝트를 만들어두고 오브젝트 구조 안에 정보를 담아서 각 계층 사이에 전달하게 만드는 것이 오브젝트 중심 아키텍처다.&lt;/p&gt;

&lt;h3 id=&quot;데이터와-오브젝트&quot;&gt;데이터와 오브젝트&lt;/h3&gt;

&lt;p&gt;간단한 예를 가지고 데이터와 오브젝트 방식을 비교해보자. 어떤 업무를분석해보니 카테고리와 상품이라는두가지 엔티티가 나온다고 해보자. 카테고리 하나에는 여러 개의 상품이 포함된다. 각 상품은 하나의 카테고리에 소속된다. 전형적인 1:N 의 관계다. 이 도메인 모델을 그려보면 그림 9-19와 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a8ab7538-ee99-4ead-ab0c-3801e1ca534e/Untitled.png&quot; alt=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a8ab7538-ee99-4ead-ab0c-3801e1ca534e/Untitled.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이를 DB 테이블로 만들면 두 태이블 사이의 관계를 위해서 Product 쪽에 Category와 관계를 만들어주는 외래키 FK를 하나 둬야 한다. 그래서 표 9-1 과 같은 태이블로 정의됐 다고하자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/075ffa28-4088-41cd-b251-43cc9d080c80/Untitled.png&quot; alt=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/075ffa28-4088-41cd-b251-43cc9d080c80/Untitled.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;조건에 맞는 모든 카테고리와 상품 정보를 가져와서 화면에 출력하는 기능을 만든다고 해보자.&lt;/p&gt;

&lt;p&gt;이때 데이터 중심 아키텍처에서는 SQL과 DB 관점에서 생각한다.&lt;/p&gt;

&lt;p&gt;이 두 개의 정보를 조합해서 가져오는 방법은 JOIN을 이용해 2차원 구조의 정보를 만드는 것이다.&lt;/p&gt;

&lt;p&gt;따라서 DAO 에서 다음과 같은 SQL을 사용하게 만들 것이다.&lt;/p&gt;

&lt;p&gt;SQL 실행 결과는 맵이나 배열에 담는다.&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;categoryid&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;description&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;productid&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;price&lt;/span&gt; 
&lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;product&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;join&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;category&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;c&lt;/span&gt; 
&lt;span class=&quot;k&quot;&gt;on&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;categoryid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;categoryid&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;배열에 담으려면 인덱스별로 필드 이름을 일일이 기억해야 하기 때문에 불편하다. 배열 대신 맵에 필드 이름과 값을 함께 담고 맵의 리스트를 만들어 돌려주는 게 편리하다.&lt;/p&gt;

&lt;p&gt;DAO 에서는 JDBC로 SQL을 실행하고 받은 결과를 리스트 9-8 과 같이 담아서 서비스 계층으로 넘겨줄 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/162fe14d-8ec0-403d-b22e-d0c1f3c4ce5b/Untitled.png&quot; alt=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/162fe14d-8ec0-403d-b22e-d0c1f3c4ce5b/Untitled.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;서비스 계층에 전달되는 것은 List&amp;lt;Map&amp;lt;String , Object» 타입이다. 이 타입만 봐서는 안에 담긴 내용이 어떤 것인지 알 수 없다.&lt;/p&gt;

&lt;p&gt;따라서 이 결과를 사용하는 서비스 계층이나 프레젠테이션 계층의 코드에서는 DAO 메소드에서 두 개의 테이블을 조인해서 다섯 가지 필드의 값을 가져오고 필드 이름을 키로 갖는 맵에 값을 저장했음을 알아야 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;만약 DAO 에서 SQL을 변경하거나 필드 개수나 순서, 이름을 바꾼다면 서비스 계층과 프레젠테이션 계층의 코드도 같이 변경돼야 한다.&lt;/p&gt;

&lt;p&gt;1:N 관계에 있는두 개의 테이블을 조인해서 2차원 구조로 풀어놓은 데이터이기 때문에 이 안에는 원래 Category와 Product가 I:N 의 관계를 맺고 있었고 어떻게 서로 참조할 수 있는지에 대한 정보는 없다.&lt;/p&gt;

&lt;p&gt;SQL을 통해서 가공된 데이터의 구조를 알고, 이를 활용하는 것이 전부다.&lt;/p&gt;

&lt;p&gt;이렇게 가져온 정보를 웹 페이지 내에서 수정해서 DB 에 다시 반영해야 한다면 어떻게 될까? 사용자가 수정한 정보는 다시 맵이나 배열 등에 담겨서 전달될 것이다.&lt;/p&gt;

&lt;p&gt;DB 수정 작업을 담당하는 DAO는 이렇게 전달되는 데이터의 구조를 알고 있어야 할 것이다. 이렇게 데이터 중심의 아키텍처에서는 DAO 가 만드는 SQL 의 결과에 모든 계층의 코드가 의존하게 된다. 도메인 분석을 통해 작성된 모델정보는 DB 에 대한 SQL을 작성할 때 외에는 코드에 반영되는 일이 없다.&lt;/p&gt;

&lt;p&gt;반면에 오브젝트 방식에서는 애플리케이션에서 사용되는 정보가 도메인 모델의 구조를 반영해서 만들어진 오브젝트 안에 담긴다. 도메인 모델은 애플리케이션 전 계층에서 동일한 의미를 갖는다. 따라서 도메인 모델이 반영된 도메인 오브젝트도 전 계층에서 일관된 구조를 유지한 채로 사용될 수 있다. SQL 이나 웹 페이지의 출력 포맷, 입력폼 등에 종속되지 않는 일관된 형식의 애플리케이션의 정보를 다룰 수 있게 된다.&lt;/p&gt;

&lt;p&gt;먼저 도메인 모델의 구조를 따라서 리스트 9-9와 같이 의미 있는 타입과 정보를 가진 클래스를정의한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3a737f7f-64a3-4405-99e0-15b376601d39/Untitled.png&quot; alt=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3a737f7f-64a3-4405-99e0-15b376601d39/Untitled.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이 구조는 단순히 특정 SQL에 대응되는 맵과 배열, 매번 달라지는 SQL 결과를 담기 위해 급조해서 만든 오브젝트외는 달리, 애플리케이션 어디에서도 시용될 수 있는 일관된 형식의 도메인 정보를 담고 있다.&lt;/p&gt;

&lt;p&gt;DB에서 SQL 결과로 가져온 값을 그대로 사용하는 경우외는 다르게,  도메인 모댈을 반영하는 오브젝트를 사용하면 자바 언어의 특성을 최대한 활용할 수 있도록 정보를 가공할 수 있다.&lt;/p&gt;

&lt;p&gt;대표적으로 오브젝트 사이의 관계를 나타내는 방법을 들 수 있다. RDB 에서는 테이블 간의 관계를 직접 명시하는 방법은 없다.&lt;/p&gt;

&lt;p&gt;대신 키의 조합을 통해 그때그때 태이블을 조인해서 의미 있는 관계를 만들어 내야 한다. 반면에 자바에는 관계하고 있는 다른 오브젝트와 직접 연결하는 방법이 있다. 레퍼런스 변수를 이용해서 다른 오브젝트를 참조하는 것이다. 하나 이상의 오브젝트와 관계를 가지려면 컬렉션을 이용할수도 있다.&lt;/p&gt;

&lt;p&gt;그래서 Product 클래스에는 Product 테이블처럼 categoryid 라는 외래키가 없다. 대신 Category 오브젝트를 가리키는 레퍼런스 변수를 갖고 있다.&lt;/p&gt;

&lt;p&gt;반대로 하나의 Category는 여러 개의 Product와 관계를 가질 수 있으므로 Set 이라는 컬렉션을 이용해 여러 개의 Product 오브젝트를 참조하게 만들 수 있다.&lt;/p&gt;

&lt;p&gt;DB 의 Category 테이블에는 Product 테이블과 어떻게 연결되는지에 대한 정보가 없다. 하지만 자바에서는 레퍼런스 변수를 통한 상호 참조가 가능하기 때문에 원한다면 Category 오브젝트에서 다음과 같은 코드로 Category 에 속한 Product를 간단히 가져올 수도 있다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nc&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;Product&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;products&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myCategory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getProducts&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;데이터 중심 방식에서는 Category와 그에 대응되는 Product 를 찾아 SQL을 이용해 조인한 디음 하나의 맵에 뭉뚱그려서 가져왔다.&lt;/p&gt;

&lt;p&gt;반면에 오브젝트 중심 방식에서는 테이블의 정보와 그 관계를 유지한 채로 정확한 개수의 Category 오브젝트와 그에 대응되는 Product 오르젝트로 만들어 사용한다.&lt;/p&gt;

&lt;p&gt;따라서 테이블에 Category가 하나이고 그에 대응되는 Product열이 5개라면 오브젝트도 하나의 Category 오브젝트와 이에 연결된 5개의 Product 가 만들어질 것이다.&lt;/p&gt;

&lt;p&gt;이 두 가지 오브젝트는 레퍼런스 변수를 통해 서로 연결되어 있기 때문에 메소드 파라미터나 리턴 값으로 전달할 때 Category 오브젝트 하나를 전달하더라도 그에 연결된 Product 5개가 함께 전달된다. 반대로 Product 의 컬렉션을 전달해도된다. 어차피 레퍼런스를 따라가면 서로 참조할 수 있기 때문이다. 이렇게 도메인 모델을 따르는 오브젝트 구조를 만들려면 DB 에서 가져온 데이터를 도메인 오브젝트 구조에 맞게 변환해줄 필요가 있다.&lt;/p&gt;

&lt;p&gt;한 번 변환되면 그 이후의 작업은 수월해진다. DAO는 자신이 DB 에서 가져와서 도메인 모델 오브젝트에 담아주는 정보가 어떤 업무 트랜잭션에서 어떻게 사용될지는 신경 쓰지 않아도 된다.&lt;/p&gt;

&lt;p&gt;서비스계층 또한 DAO에서 어떤 SQL을 사용했는지는 몰라도 된다. Category와 Product 정보를 두개의 SQL로 나눠서 가져왔든, 하나의 SQL로 조인해서 가져왔든 상관없다.&lt;/p&gt;

&lt;p&gt;서비스 계층에서 필요한 정보를 조건에 맞게 조회해서 도메인 모델오브젝트 형태로 돌려주는 DAO를 이용하기만 하면 된다.&lt;/p&gt;

&lt;p&gt;그리고 가져온 도메인 오브젝트에 담긴 정보를 활용해서 비즈니스 로직을 처리하면 된다. 프레젠태이션 계층에 전달할 때도 마찬가지다. 어떤 DAO가 사용됐고, 어떤 비즈니스 로직을 거쳤는지에 관해선 프레젠테이션 계층은 알 필요가 없다. 자신에게 전달된 도메인 오브젝트를 활용해서 필요한 정보를 화면에 출력하기만 하면된다.&lt;/p&gt;

&lt;h3 id=&quot;도메인-오브젝트를-사용하는-코드&quot;&gt;도메인 오브젝트를 사용하는 코드&lt;/h3&gt;

&lt;p&gt;오브젝트 중심 방식에서 비즈니스 로직의 구현이 얼마나 간단하고 명확한지 살펴보자. 어떤 카태고리에 포함된 상품의 모든 가격을 계산해야 하는 로직이 필요하다면 서비스 계층의 오브젝트 안에 리스트 9-10과 같은 메소드를 만들어 사용하면 된다.&lt;/p&gt;

&lt;p&gt;어떤 DAO를 이용해서 Category를 가져왔는지는 중요하지 않다. 조건을 가지고 Category를 하나 검색했을 수도 있고, 모든 Category 목록을 가져왔을 수도 있다. 어떻게든 Category 오브젝트를 갖고 있다면 calcTotalOfProductPrice() 메소드를 호출해서 카태고리에 담긴 모든 상품가격의 합을 계산할수있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8465e65d-499e-4e11-90ff-72c457ca0748/Untitled.png&quot; alt=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8465e65d-499e-4e11-90ff-72c457ca0748/Untitled.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;도메인 모델을 알고 있다면 calcTotalOfProductPrice() 메소드가 무슨 작업을 하는지 이해하기 어렵지 않다.&lt;/p&gt;

&lt;p&gt;테스트를 만들어 검증하기도 간단하고, 로직이 변경될 때묘드를 수정하기도 수월하다. Category 자체가 독립된 오브젝트이므로 서비스 계층 어디에서든지 Category 의 상품 가격을 계산해야 할 때는 이 메소드를 사용하면 된다. Category 내의 상품 가격을 계산하는 코드가 여러 개의 업무 트랜잭션에서 필요하다고 해도 코드의 중복이 일어나지 않을 수 있다. 반면에 데이터 중심 방식에서라면 이런식의 재사용 가능한 메소드를 만들어 사용하기가 쉽지않다.&lt;/p&gt;

&lt;p&gt;DAO 에 메소드를 추가해서 select sum(p.price) 로 시작하는 SQL을 실행해 DB 가 계산해주는 결과를 한 번에 가져오는 방법을 사용하려고 할지 모르겠다.&lt;/p&gt;

&lt;p&gt;아니면 주어진 카테고리에 포함된 상품의 가격 값의 목록을 배열 등에 담아서 돌려주는 DAO를 만들고 배열을 이용해서 합계를 계산하는 코드를 만들 수도 있다.&lt;/p&gt;

&lt;p&gt;문제는 하나의 Category 에 대해 상품 가격의 합을 계산하는 로직이라면 이런 방법을 사용하겠지만이미 DAO 에서 여러 개의 Category와 Product를 조인해서 가져옹 경우라면 별도의 합계 계산 코드를 만들어야 한다는 점이다.&lt;/p&gt;

&lt;p&gt;아마도 적지 않은 for 문과 if 문을 시용해서 Category 와 Product 가 함께 들어 있는 맵이나 리스트를 뒤져 카테고리별 합을 계산하는 코드를 만들게 될 것이다.&lt;/p&gt;

&lt;p&gt;Category 내의 Product 가격 합을 계산하는 동일한 로직인데도 SQL을 통해 데이터를 어떻게 가져왔는지에 따라서 이를 처리히는 다른 코드가 만들어지므로, 코드에 중복이 발생한다.&lt;/p&gt;

&lt;p&gt;오브젝트 구조로 정보를 갖고 있으면 어떤 식으로든 활용하기 펀리하다. 자바에서는 ‘.’을 이용해 레퍼런스 변수를 따라가면 관련된 정보를 손쉽게 이용할 수 있다. Product 오브젝트가 하나 주어졌을 때, 해당 Product 의 Category 에는 상품이 모두 몇 개가 있는지 알고 싶다면 다음과 같이 간단한 코드를 사용할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;product&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getCategory&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getProducts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;만약 SQL을 이용해 Product 와 Category 를 조인해서 통째로 가져왔다면, 적지 않은 if 문을 사용해야만 이와 기능이 동일한 코드를 만들 수 있다. 아니면 이런 로직을 JOIN과 count() 펑션을 사용하는 SQL에 담아 새로운 DAO 메소드를 추가해야 한다.&lt;/p&gt;

&lt;p&gt;테스트를 만드는 펀리함 면에서도 큰 차이가 있다.SQL 에 담긴 로직을 테스트하는 건 복잡 하고 불편하다.&lt;/p&gt;

&lt;p&gt;반면에 도메인 오브젝트를 사용하는 코드는 간단히 테스트 값을 담은 도메인 오브젝트를 생성해서 쉽게 검증할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;도메인-오브젝트-사용의-문제점&quot;&gt;도메인 오브젝트 사용의 문제점&lt;/h3&gt;

&lt;p&gt;일관된 의미를 가지고 유연하며 애플리케이션 전반에 공유 가능한 도메인 모델을 따르는 오브젝트로 정보를 다루면 많은 장점이 많다.&lt;/p&gt;

&lt;p&gt;코드는 이해하기 쉽고 로직을 작성하기도 수월하다. 프레젠테이션 영역에서도 이미 정의된 도메인 오브젝트 구조만 알고 있다면 아직 DAO가 작성되지 않았어도뷰를 미리 만들수도 있다. 코드의 재사용성은 높아지고 DAO는 더 작고 효율적으로 만들어질 수 있다.&lt;/p&gt;

&lt;p&gt;하지만 단점도 있다. 최적화된 SQL을 매번 만들어 사용하는 경우에 비해 성능 면에서 조금은 손해를 감수해야 할 수도 있다. DAO는 비즈니스 로직의 사용 방식을 알지 못하므로, 도메인 오브젝트의 모든 필드 값을 다 채워서 전달하는 경우가 대부분이다.&lt;/p&gt;

&lt;p&gt;그런데 하나의 오브젝트에 담긴 필드의 개수가 많아지다 보면 그중에는 드물게 사용되는 필드도 있을 수 있다. 어떤 비즈니스 로직에서 필요한 정보가 몇 개의 펼드뿐이라면 DAO 에서 도메인 오브젝트의 모든 필드 정보를 채워서 전달히는 것은 낭비일 수도 있다. 비즈니스 로직에 따라서 필요한 정보가 달라질 수 있기 때문에 발생하는 문제다.&lt;/p&gt;

&lt;p&gt;오브젝트 관계에도 문제가 있다. 만약 단순히 Product 정보만 필요한 비즈니스 로직이 있다고 해보자. 그런데 DAO가 돌려준 Product 오브젝트에는 관계를 갖고 있는  Category 오브젝트도 함께 담겨 있을 것이다. Category 에 담긴 정보까지 사용될 때도 있겠지만, 어떤 경우에는 Product 에 담긴 정보만 필요할 때도 있다.&lt;/p&gt;

&lt;p&gt;그럼에도 Category 오브젝트까지 다 조회해서 오브젝트로 만들어서 가져오는 것은 상당한 낭비다. 물론 Product 정보를 가져올 때 Category 가 필요한 경우와 그렇지 않은 경우를 구분해서 DAO를 만틀어줄 수 있다. 하지만 문제는 DAO 에서 Product 만 가져오게 하면 Product 의 category 필드에는 null 값이 들어간다는 점이다. 불필요한 오브젝트를 생성하는 일을 피할 수 있어서 좋기는 한데， 자칫 비즈니스 로직 코드를 작성하다가 그런 사실을 깜박하고 product 의 category 필드를 사용할 경우 예상치 못했던 NullPointerException을 만날 수도 있다.&lt;/p&gt;

&lt;p&gt;결국 최적화를 고려해서 DAO를 작성하려면 DAO는 비즈니스 로직에서 각 오브젝트를 어디까지 사용해야 하는지 어느 정도 알고 있어야 한다. 그래서 데이터 중심 접근 방법의 단점이라고 봤던， DAO와 비즈니스 로직코드의 결합도가 높아지는 문제가 발생할 수도 있다.&lt;/p&gt;

&lt;p&gt;프레젠테이션 계층에서도 마찬가지다. Product 오브젝트를 전달받아서 Product 내의 필드값만 사용할 수도 있고 연결된 Category 의 정보까지 출력할 수도 있기 때문이다.&lt;/p&gt;

&lt;p&gt;이런 문제를 해결하는 접근 방법은 여러 가지가 있다. 지연된 로딩 lazy loading 기법을 이용하면 일단 최소한의 오브젝트 정보만 읽어두고 관계하고 있는 오브젝트가 필요한 경우에만 다이내믹하게 DB 에서 다시 읽어올 수 있다.&lt;/p&gt;

&lt;p&gt;물론 도메인 오브젝트를 사용하는 코드는 이런 사실을 전혀 의식하지 않고 처음부터 모든 오브젝트의 정보가 다 제공된다고 생각하고 작성하면 된다.&lt;/p&gt;

&lt;p&gt;필드가 너무 많은 테이블이 있다면 그중에서 자주 시용되는 것을 골라내서 별도의 오브젝트로 정의해두고 필요에 따라 구분해서 사용하게 할 수 있다.&lt;/p&gt;

&lt;p&gt;물론 그에 따라 DAO 메소드가 추가돼야 하고 어느 DAO를 사용할지를 서비스 계층에서 알고 있어야 하기 때문에,  약하긴 하지만 계층 사이의 결합이 발생한다.&lt;/p&gt;

&lt;p&gt;사실 가장 이상적인 방법은 JPA 나 JDO, 하이버네이트， TopLinK와 같은 오브젝트 RDB 매핑 ORM 기술을 사용하는 것이다.&lt;/p&gt;

&lt;p&gt;이런 데이터 액세스 기술은 기본적으로 지연된 로딩 기법 등을 제공해주기 때문에 번거로운 코드를 만들지 않고도 도메인 오브젝트의 생성을 최적화할 수 있다.&lt;/p&gt;

&lt;p&gt;또한 SQL 결과를 가지고 도메인 오브젝트를 만들고 값을 채우는 등의 복잡한 DAO 코드를 만들지 않아도 된다. 내부적으로 최적화된 SQL을 사용 하도록 세밀히 튜닝할 수도 있다. 또 자주 변경되지 않으면서 많은 로직에서 참조하는 레퍼런스 테이블이 있다면 이를 ORM 이 제공하는 오브젝트 캐시에 담아두고 사용할 수도 있다. 코드 테이블처럼 자주 참조되는 것은 오브젝트 캐시로 만들어두면 매번 DB 에서 읽어오지 않고 메모리 캐시에 가져오게 해주기 때문에 DB 의 부하를 줄여줘서 성능 이많이향상된다.&lt;/p&gt;

&lt;p&gt;그래서 도메인 오브젝트를 사용하는 오브젝트 중심 아키텍처에서는 가능하다면 ORM과 같은 오브젝트 중심 데이터 액세스 기술을 사용하는 것을 권장한다. 사용하기 쉽고 직관적이며 코드의 양도 대폭 줄기 때문이다. 다양한 기법을 이용하면 SQL을 직접 만들어 쓰는 경우에 못지않게 성능을 향상시 킬 수 있다.&lt;/p&gt;

&lt;p&gt;ORM 을 사용하지 않고 JDBC를 이용하는 경우라면 지연된 로딩 기법을 제공하는 코드를 추가해주거나, 사용되는 필드의 종류와 사용되는 관련 오브젝트의 범위에 따라서 여러 개의 DAO 메소드를 만들어 사용해야 할 수도 있다. 이 경우 DAO 코드나 도메인 오브젝트 코드의 중복이 일부 발생하고 계층 사이의 결합도도 증가될 수는 있지 만, 데이터 중심 아키텍처에 비하면 미미한 정도다.&lt;/p&gt;

&lt;p&gt;오브젝트 중심의 아키텍처는 도메인 모델을 따르는 오브젝트를 사용해 각 계층 사이에 정보를 전달하고, 이를 이용해 비즈니스 로직이나 프레젠테이션 로직을 작성한다.&lt;/p&gt;

&lt;p&gt;계층 간의 결합도는 낮아지고 일관된 정보 모델을 사용하기 때문에 개발 생산성과 코드의 품질, 테스트 편의성도 향상시킬 수 있다. 그런데 도메인 오브젝트는 자바오브젝트다. 오브젝트는 원래 데이터를 저장하기 위해서만 사용하는 것이 아니다. 내부의 정보를 이용하는 기능도 함께 갖고 있어야 한다. 클래스는 속성(attribute)과 행위(operation) 의 조합이다. 필드와 그에 대한 접근자, 수정자만 갖고 있는 오브젝트는 반쪽짜리다. 물론 도메인 모델을 반영하는 오브젝트 구조에 정보를 담는 것만으로도 많은 장점이 있지만 이 정도에서 도메인 오브젝트의 사용을 제한할 필요는 없다. 가능하다면 이를 더 적극적으로 활용하게 만들어야 한다. 오브젝트 중심 아키텍처는 오브젝트의 활용 방법을 기준으로 다시 구분해볼 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;빈약한-도메인-오브젝트-방식&quot;&gt;빈약한 도메인 오브젝트 방식&lt;/h3&gt;

&lt;p&gt;도메인 오브젝트에 정보만 담겨 있고 정보를 활용하는 아무런 기능도 갖고 있지 않다면 이는 온전한 오브젝트라고 보기 힘들다.&lt;/p&gt;

&lt;p&gt;그래서 이런 오브젝트를 빈약한 오브젝트라고 부른다. 물론 이렇게라도 도메인 모델을 반영한 오므젝트에 정보를 담아 활용하는 편이 도메인 오브젝트를 전혀 사용하지 않는 것보다는 훨씬 낫다.&lt;/p&gt;

&lt;p&gt;계층 사이의 독립성을 확보하기 위해서는 특정 계층에 종속되지 않으면서 애플리케이션 전반에서 사용될 수 있는 정보를 담은 오브젝트가 필요하기 마련이고 그래서 이런 빈약한 도메인 오브젝트 방식도 실제로 많이 시용된다.&lt;/p&gt;

&lt;p&gt;아마도 스프링을 사용하는 개발자가 흔히 시용하는 방식이 이 빈약한 도메인 오브젝트 방식이 아닐까 싶다.&lt;/p&gt;

&lt;p&gt;스프링의 핵심 개발자들이 함께 쓴 스프링 전문 서적인 professioanl Spring-Framework 라는 책이 있다. 이 책과 함께 제공되는 스프링 애플리케이션 예제에서는 바로 이 빈약한 도메인 오브젝트 방식을 사용했다.&lt;/p&gt;

&lt;p&gt;오브젝트 자체는 복잡한 도메인 모델을 따라서 잘 만들어져 있고 이 구조를 그대로 모든 계층이 활용 하도록 하고 있기 때문에 깔끔하고 유연한 코드로 만들어져 있다.&lt;/p&gt;

&lt;p&gt;하지만 도메인 오브젝트는 데이터를 저장해두는 것 외에는 아무런 기능이 없다. 도메인 오브젝트에 넣을 수 있는 기능은 어떤 것일까? 도메인 모델을 반영해서 만들어진 도메인 오브젝트이니 그 기능이라고 하면 도메인의 비즈니스 로직이라고 볼 수 있다. 그렇다면 빈약한 도메인 오브젝트 방식에서는 비즈니스로직이 어디에 존재할까? 바로 서비스 계층이다.&lt;/p&gt;

&lt;p&gt;사실 다루는 정보의 구조가 다를 뿐이지 빈약한 도메인 오브젝트 방식은 데이터 중심 아키텍처의 거대 서비스 계층구조와 비슷하다.&lt;/p&gt;

&lt;p&gt;빈약한 도메인 오브젝트 방식도 거대 서비스 계층 방식의 하나라고 보면 된다. 그림 9-20은 빈약한 도메인 오브젝트 방식의 구조를 보여준다. 도메인 오브젝트는 3 개의 계층에는 독립적으로 존재하면서 일관된 구조의 정보를 담아서 계층 간에 전달하는 데 사용된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/bdfbf984-0adc-4bb4-b16e-4c38ff7eaf2c/Untitled.png&quot; alt=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/bdfbf984-0adc-4bb4-b16e-4c38ff7eaf2c/Untitled.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;빈약한 도메인 오브젝트 방식의 한계는 거대 서비스 계층 방식과 유사하다.&lt;/p&gt;

&lt;p&gt;비록 도메인 오브젝트라는 일관된 오브젝트를 활용하기 때문에 SQL 에 의존적인 데이터 방식보 다는 훨씬 유연하고 간결하지만, 여전히 서비스 계층의 메소드에 대부분의 비즈니스 로직이 들어 있기 때문에 로직의 재사용성이 떨어지고 중복의 문제가 발생하기 쉽다. 하지만 비즈니스 로직이 복잡하지 않다면 가장 만들기 쉽고 3계층 구조의 특정을 잘살려서 개발할 수 있는 유용한 아키텍처다.&lt;/p&gt;

&lt;h3 id=&quot;풍성한-도메인-오브젝트-방식&quot;&gt;풍성한 도메인 오브젝트 방식&lt;/h3&gt;

&lt;p&gt;풍성한 도메인 오브젝트 또는 영리한 도메인 오브젝트 방식은 빈약한 도메인 오브젝트의 단점을 극복하고 도메인 오브젝트의 객체지향적인 특정을 잘 사용할 수 있도록 개선한 것이다.&lt;/p&gt;

&lt;p&gt;어떤 비즈니스 로직은 특정 도메인 오브젝트나 그 관련 오브젝트가 가진 정보와 깊은 관계가 있다. 이런 로직을 서비스 계층의 코드가 아니라 도메인 오브젝트에 넣어주고, 서비스 계층의 비즈니스 로직에서 재사용하게 만드는것이다.&lt;/p&gt;

&lt;p&gt;앞에서 서비스 계층의 코드로 만들었던 calcTotalOfProductPrice() 는 Category라는 오브젝트와 그 관련 Product 의 정보만을 사용하는 간단한 로직이다.&lt;/p&gt;

&lt;p&gt;이것을 굳이 리스트 9-10 처럼 서비스 계층의 메소드에 별도로 만들지 않고 리스트 9-11 과 같이 Category 클래스의 메소드에 넣을 수도 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0192dfc2-cc67-4b66-8541-3eff98f6945f/Untitled.png&quot; alt=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0192dfc2-cc67-4b66-8541-3eff98f6945f/Untitled.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이렇게 도메인 오브젝트 안에 로직을 담아두면 이 로직을 서비스 계층의 메소드에 따로 만드는 경우보다 응집도가 높다.&lt;/p&gt;

&lt;p&gt;데이터와 그것을 사용하는 기능이 한곳에 모여 있기 때문이다. 만약 Category 에 대해 상품 가격을 계산히는 작업이 CategoryService외의 서비스 계층 오브젝트에서 필요하다고 해보자.&lt;/p&gt;

&lt;p&gt;그때마다 Category 오브젝 트를 파라미터로 해서 CategoryService 의 메소드를 호출하는 것은 번거롭다 . CategoryService를 사용하기 위해 Dl도 해줘야 한다. 다른 모률의 비즈니 스 로직을 작성하고 있는 개발자는 CategoryService 안에 그런 기능이 있는지 몰라서 같은 기능을 가진 코드를 스스로 만들어 쓸지 도 모른다. 현재 재고에 대한 비즈니 스 로직을 담고 있는 InventoryService가 있다고 하자.&lt;/p&gt;

&lt;p&gt;여기서 특정 카테고리의 상품에 대한 현재 가격의 합을 계산할 필요가 생겼다. 그리고 혹시 미리 만들어둔 관련 기능이 있는지 CategoryService를 뒤져보고 거기서 calcTotalOfProductPrice(Category c) 메소드를 찾았다고 하자. 그러면 이 기능을 사용하기 위해 InventoryService에 CategoryService를 DI 해줘야 한다. 그렇게 주입받은 CategoryService를 호출해서 그 메소드를 이용해야 한다. 그나마 같은 기능의 코드를 중복하지 않고 최적화해서 이미 만들어진 비즈니 스 로직을 재활용하는 것인데도 제법 번거로울 수 있다. InventoryService 클래스는 리 스트 9-12와 같이 작성된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2be13448-a480-4a42-a720-46a57475fce8/Untitled.png&quot; alt=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2be13448-a480-4a42-a720-46a57475fce8/Untitled.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이런 식으로 여러 개의 도메인 오브젝트에 대한 로직을 사용해야 동}는 복잡한 코드 라면 각 비즈니스 로직을 담고 있는 서비스 오브젝트를 DI 해서 로직을 담은 메소드를 호출해야 한다. 이미 정보를 담고 있는 오브젝트가 있지만 그 정보를 다루는 메소드는 별개의 서비스 오브젝트에 분리되어 있기 때문이다. 그런데 Category 에 대한 계산 로직을 Category 오브젝트 안에 직접 넣어뒀다면 이런 번거로운 작업이 필요 없다. 그냥 Category 오브젝트에게 직접 필요한 계산 작업을 요청하면 되는 것이다.&lt;/p&gt;

&lt;p&gt;CategoryService를 DI 할 필요도 없다. 비슷한 코드가 여기저기 비즈니스 로직에 중복돼서 나타나지도 않는다. 특정 도메인 오브젝트에 종속되는 비즈 니스 로직은 서비스 계층의 오브젝트가 아니라 도메인 오브젝트 안에 넣으면 된다. 이제 InventoryService의 코드는 불필요한 DI 없이 리스트 9-13 과 같이 간결하게 만들수 있다. 리스트 9-12와 리스트 9-13 의 코드를 비교해보고 어떤 코드가 이해하기 쉬운지한번생각해보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0c03a295-e6dd-43c3-bd2c-3826b5d035b0/Untitled.png&quot; alt=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0c03a295-e6dd-43c3-bd2c-3826b5d035b0/Untitled.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;풍성한 도메인 오브젝트 방식은 도메인 오브젝트를 사용한다는 면에서 빈약한 도메인 오브젝트 방식과 비슷하지만, 실제 작성된 코드를 살펴보면 훨씬 간결하고 객체지향적이라는 사실을 알 수 있다. 객체지향 분석과 설계를 통해 만들어진 도메인 모델의 정보를 정적인 구조뿐 아니라동적인 동작방식에도 적극 활용할수 있다.&lt;/p&gt;

&lt;p&gt;물론 도메인 오브젝트에 비즈니스 로직을 넣는다고 해서 비즈니스 로직을 담고 있던 서비스 계층 오브젝트가 필요 없어지는 건 아니다. 여전히 서비스 계층은 필요하며 중요한 역할을 하고 있다.&lt;/p&gt;

&lt;p&gt;도메인 오브젝트 안에 메소드로 들어가는 로직들은 대부분 해당 오브젝트나, 긴밀한 연관관계를 맺고 있는 관련 오브젝트의 정보와 기능만을 활용한다.&lt;/p&gt;

&lt;p&gt;여러 종류의 도메인 오브젝트의 기능을 조합해서 복잡한 비즈니스 로직을 만들었다면 특정 도메인 오브젝트에 넣기는 힘들다. 이런 비즈니스 로직은 서비스 계층의 오브 젝트에 두는 것이 적당하다. 도메인 오브젝트는 직접 데이터 액세스 계층이나 기반 계층 또는 다른 서비스 계층의 오브젝트에 접근할 수 없기 때문에 서비스 계층이 필요하기도 하다. 대개는 비즈니스 로직을 처리하는 중에 DB 에 담긴 정보를 가져와서 활용하거 나 결과를 다시 DB나 외부 시스템에 전송히는 등의 작업이 필요하다.&lt;/p&gt;

&lt;p&gt;그러려면 서비스 계층의 오브젝트와 같이 DAO 오브젝트를 DI 받아서 사용할 수 있어야 한다. 하지만 도메인 오브젝트는 그럴수없다. 왜 도메인 오브젝트는 DAO 오브젝트를 DI 받을 수 없을까? 그것은 도메인 오브젝트는 스프링 컨테이너가 관리히는 오브젝트, 즉 빈이 아니기 때문이다.&lt;/p&gt;

&lt;p&gt;서비스 계층의 오브젝트나 데이터 액세스 계층의 오브젝트는 모두 스프링의 빈으로 등록되기 때문에 필요에 따라 서로 DI 할 수 있다.&lt;/p&gt;

&lt;p&gt;DI를 받으려면 자신도 역시 스프링 컨테이너에서 관리되는 빈이어야 한다. 그런데 도메인 오브젝트는 스프링의 빈이 아니다.&lt;/p&gt;

&lt;p&gt;도메인 오브 젝트는 애플리케이션의 코드 또는 기타 프레임워크나 라이브러리, JDBC 템플릿 등에 의해 필요할 때마다 새롭게 만들어진다.&lt;/p&gt;

&lt;p&gt;따라서 스프링이 생성하거나 관리하는 오브젝트가 아니므로 DJ 를 받을 수 없다. 결국 이런 도메인 오브젝트는 DAO 나 서비스 오브젝트 같은 스프링의 빈의 기능을 사용할 수 없다.&lt;/p&gt;

&lt;p&gt;그래서 수식 계산이나 조건에 따른 데이터의 변경 또는 자신이 가진 정보에 대한 분석 같은 도메인 오브젝트 자신에 국한된 로직은 도메인 오브젝트 안에 추가할 수 있지 만, 그 결과를 DB 에 저장하거나 메일로 발송하거나 DB를 검색해서 원하는 정보를 가져와 활용히는 작업은 도메인 오브젝트에서 불기능하다. 그래서 DAO와 기반계층 오브 젝트를 DJ 받아사용할수 있는 서비스 계층의 코드가 펼요하다. 서비스 계층은 도메인 오브젝트를 DB나 외부 리소스에서 가져오고 변경된 정보나 새로 등록된 정보를 DB 에 반영히는 등의 작업과 함께 도메인 오브젝트가 갖고 있는 기능이 있다면 이를 활용해서 비즈니스 로직을 처리해야 한다.&lt;/p&gt;

&lt;p&gt;그림 9-21 은 풍성한 도메인 오브젝트 방식의 아커텍처를 나타낸다. 스프링의 빈으로 관리되는 3 계층의 오브젝트들은 도메인 오브젝트를 자유롭게 이용할 수 있지만 그 반대는 안 된다는 사실을 주의해야 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/95782490-05e1-491d-91fb-c6f418dbf4c3/Untitled.png&quot; alt=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/95782490-05e1-491d-91fb-c6f418dbf4c3/Untitled.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;풍성한 도메인 오브젝트 방식은 빈약한 도메인 오브젝트 방식보다 서비스 계층의 코드가 간결하다. 비즈니스 로직 코드를 이해하기도 쉽다. 따라서 빈약한 도메인 오브젝트를 피하고 도메인 오브젝트가 스스로 처리 가능한 기능과 도메인 비즈니스 로직을 갖도록 만드는것이 바람직하다.&lt;/p&gt;

&lt;p&gt;물론 빈약한 도메인 오브젝트 방식이 항상 나쁘고 피해야 할 것은 아니다. 도메인 모델링과 기능 분석을 통해 이상적인 도메인 오브젝트 설계를 하고 사전에 내부기능을 충분히 구현해두지 않았다면,&lt;/p&gt;

&lt;p&gt;도메인 오브젝트를 활용해서 비즈니스 로직을 구현해야 하는 개발자는 혼란을느낄 수 있다. 어떤 경우는도메인 오브젝트에 이미 구현된 코드가 있는데도 이를 이용하지 못하고 서비스 계층에 비슷한 기능을 중복해서 만들 수도 있고, 도메인 오브젝트의 코드를 일부 서비스 계층의 개발자가 임의로 변경해서 같은 오브젝트를 사용하는 다른 모률의 작업자가 만든 코드가 제대로 동작하지 못하게 되기 도한다.&lt;/p&gt;

&lt;p&gt;그래서 충실한 도메인 모댈링과 도메인 오브젝트 개발이 선행되고 그 내용이 개발자에게 사전에 충분히 공유되지 않았다면 차라리 데이터 구조만 오브젝트 방식으로 정의 해놓은 빈약한 도메인 오브젝트 방식이 혼란을 피할 수 있고 쉽게 접근할 수 있는 대안이 될 수도 있다.&lt;/p&gt;

&lt;p&gt;하지만 처음은 쉬워도 시간이 지나고 시스템이 복잡해지면 빈약한 도메인 오브젝트 방식의 단점이 드러날 것은 각오해야 한다.&lt;/p&gt;

&lt;h3 id=&quot;도메인계층방식&quot;&gt;도메인계층방식&lt;/h3&gt;

&lt;p&gt;지금까지 살펴본 바로는 도메인 모댈을 따르는 오브젝트를 만들고 이를 활용하는 방법에는 한계가 있다. 도메인 오브젝트에 담을 수 있는 비즈니스 로직은 데이터 액세스 계층에서 가져온 내부 데이터를 분석하거나 조건에 따라 오브젝트 정보를 변경, 생성 하는 정도에 그칠 수 밖에 없다.&lt;/p&gt;

&lt;p&gt;이렇게 변경된 정보가 다시 DB 등에 반영되려면 서비스 계층 오브젝트의 부가적인 작업이 필요하다. 도메인 오브젝트가 스스로 필요한 정보는 DAO를 통해 가져올 수 있고, 생성이나 변경이 일어났을 때 직접 DAO 에게 변경사항을 반영해달라고 요청할 수는 없을까?&lt;/p&gt;

&lt;p&gt;DAO 외에도 다양한 기반계층의 서비스를 이용하도록 할 방법은 없을까? 만약 도메인 오브젝트가 기존 3계층의 오브젝트를 DI 받아서 직접 이용할 수 있게 된다면 어떤 일이 일어날까?&lt;/p&gt;

&lt;p&gt;도메인 계층의 역할과 비중을 극대화하려다 보면 기존의 풍성한 도메인 오브젝트 방식으로는 만족할 수 없다.&lt;/p&gt;

&lt;p&gt;그래서 등장한 것이 바로 도메인 오브젝트가 기존 3계층과 같은 레벨로 격상되어 하나의 계층을 이루게 하는 도메인 계층 방식이다.&lt;/p&gt;

&lt;p&gt;개념은 간단하다. 도메인 오브젝트들이 하나의 독립적인 계층을 이뤄서 서비스 계층과 데이터 액세스 계층의 사이에 존재하게 히는 것이다. 도메인 오브젝트가 독립된 계층을 이뤘기 때문에 기존 방식과는 다른 두 가지 특징을 갖게된다.&lt;/p&gt;

&lt;p&gt;첫째는 도메인에 종속적인 비즈니스 로직의 처리는 서비 스 계층이 아니라 도메인 계층의 오브젝트 안에서 진행된다는 점이다. 서비스 계층에서 사용자가 입력한 정보를 바탕으로 새로운 도메인 오브젝트를 만들었든 데이터 액세스 계층을 통해 도메인 오브젝트를 가져왔든 상관없이 도메인 오브젝트에게 비즈니스 로직의 처리를 요청할 수 있다.&lt;/p&gt;

&lt;p&gt;해당 도메인 오브젝트를 중심으로 만들어진 로직이라면 그 이후의 작업은 도메인 오브 젝트와 그 관련 오브젝트 사이에서 진행된다. 일단 도메인 계층으로 들어가면 서비스 계층의 도움 없이도 비즈니스 로직의 대부분의 작업을 수행할 수 있다는 뜻이다.&lt;/p&gt;

&lt;p&gt;두 번째 특징은 도메인 오브젝트가 기존 데이터 액세스 계층이나 기반 계층의 기능을 직접 활용할 수 있다는 것이다. 그런데 앞에서 도메인 오브젝트는 스프링에 등록돼서 싱글톤으로 관리되는 빈이 아니기 때문에 다른 빈을 DI 받을 수 없다고 했다. 그렇다면 도메인 계층의 도메인 오브젝트들은 어떻게 다른 빈을 이용할수 있을까?&lt;/p&gt;

&lt;p&gt;물론방법은 DI 다. 여전히 도메인 오브젝트는 스프링이 직접 만들고 관리히는 오브젝트 즉 빈이 아니다. 하지만 이런 스프링이 관리하지 않는오브젝트에도 DI를 적용할수 있다. 물론 그에 따른 간단한 설정이 추가돼야 한다.&lt;/p&gt;

&lt;p&gt;스프링이 관리하지 않는 도메인 오브젝트에 DI를 적용하기 위해서는 AOP 가 필요하다. 물론 스프링 AOP는 부가기능을 추가할 수 있는 위치가 메소드 호출 과정으로 한정되고 AOP의 적용 대상도 스프링의 빈 오브젝트뿐이다.&lt;/p&gt;

&lt;p&gt;하지만 스프링 AOP 대신 AspectJ AOP를 사용하면 클래스의 생성자가 호출되면서 오브젝트가 만들어지는 시점을 조인 포인트로 사용할 수 있고 스프링 빈이 아닌 일반 오브젝트에도 AOP 부가기능을 적용할 수 있다.&lt;/p&gt;

&lt;p&gt;이를 이용해서 도메인 오브젝트가 생성되는 시점에 특별한 부가기능을 추가하게 만들어줄 수 있다. 이 부가기능은 오브젝트의 수정자 메소드나 DI용 애노태이션을 참고해서 DI 가능한 대상을 스프링 컨테이너에서 찾아 DI 해주는 기능이다. 스프링이 직접 관리하지 않는 오브젝트에 대한 DI서비스가 일종의 AOP 부가기능 으로 도메인 오브젝트에 적용될 수 있다.&lt;/p&gt;

&lt;p&gt;이 방법을 이용하면 도메인 오브젝트가 만들어질 때 스프링의 빈 오브젝트를 DI 받게 할 수 있다. 결국 도메인 오브젝트가 데이터 액세스 계층이나 기반 계층의 오브젝트를 이용하도록 만들 수 있다. 이 덕분에 도메인 오브젝트 기능의 제약이 사라진다. 물론 도메인 오브젝트에 담긴 기능은 자신과 관련 오브젝트에 대한 작업으로 한정돼야 한다.&lt;/p&gt;

&lt;p&gt;도메인 계층 방식은 이전의 어떤 방식보다 도메인 오브젝트에 많은 비즈니스 로직을 담아낼 수 있다. 그럼에도 서비스 계층의 역할이 완전히 사라지는 건 아니다. 때로는 여러 도메인 오브젝트의 기능을 조합해서 복잡한 작업을 진행해야 하는 경우가 있다. 특정 도메인 오브젝트에 담길 수 없는 이런 작업은 서비스 계층에서 도메인 계층과 협력을 통해 진행히는 것이 바람직하다.&lt;/p&gt;

&lt;p&gt;또는 굳이 도메인 계층을 거치지 않고 바로 데이터 액세스 계층으로부터 정보를 가져와 클라이언트에 제공해야 하는 경우도 있다. 이럴 때도 서비스 계층이 인터페이스 역할을 담당한다.&lt;/p&gt;

&lt;p&gt;또 트랜잭션 경계를 설정하거나 특정 도메인 로직에 포함되지는 않지만 애플리케이션에서 필요로 히는 기반 서비스를 이용 해야 하는 작업을 위해서라도 서비스 계층은 필요하다.&lt;/p&gt;

&lt;p&gt;대신 서비스 계층의 비중과 규모는단순히 도메인 오브젝트를사용하는 방식에 비해 훨씬 작다. 복잡하지 않은 애플리케이션에서는 아예 서비스 계층을 제거하고 모든 비즈니스 로직을 도메인 오브젝트에 담을 수도 있다.&lt;/p&gt;

&lt;p&gt;이때는 트랜잭션 경계가 프레젠태이션 계층에서 최초로 호출되는 도메인 오브젝트의 메소드에 설정돼야 한다. 도메인 오브젝트를 독립적인 계층으로 만들려고 할 때 고려해야 할 중요한 사항이 있다. 도메인 오브젝트가 도메인 계층을 벗어나서도 사용되게 할지 말지 결정해야 한다. 도메인 오브젝트가 계층을 이루기 전에는 모든 계층에 걸쳐 사용되는 일종의 정보 전달 도구 같은 역할을 했다. 하지만 독자적인 계층을 이뤘을 때는 상황이 달라질 수있다. 선택할 수 있는 방법은 두 가지가 있다.&lt;/p&gt;

&lt;p&gt;첫째, 여전히 모든 계층에서 도메인 오브젝트를 사용한다. 도메인 계층은 물론이고 서비스 계층이나 그 앞의 프레젠테이션 계층 화면 출력을 위한 뷰에서도 직접 도메인 오브젝트를 전달받아 사용할 수 있게 하는 것이다. 가장 손쉽고 펀한 방법이다. 도메인 오브젝트를 이용해 도메인 로직을 적용하면 도메인 계층에서 진행되지만, 그 결과를 DB 에 반영할 때나 화면에 출력하거나 페이지 이동을 위한 정보로 활용하기 위해 프레젠테이션 계층에서 참조할 때도 도메인 오브젝트를 사용할 수 있다. 따라서 도메인 모델을 따르는 오브젝트 구조를 활용하는 면에서 오브젝트 중심 아키텍처의 장점을 그대 로누릴수있다. 하지만 주의하지 않으면 심각한 혼란을 초래할 수 있다. 도메인 오브젝트의 메소드는 이제 단순한 값의 조작이나 분석 변환 정도가 아니라 중요한 도메인/비즈니스 로직을 담당하고 있다. 심지어 DB 나 백엔드 시스템에 작업 결과를 반영할 수도 있다. 그런데 이런 막강한 기능을 가진 도메인 오브젝트를 프레젠테이션 계층이나 뷰 등에서 사용하게 해주면 이를 함부로 사용하는 위험이 뒤따를 수 있다. JSP로 뷰를 만드는 개발 자가 도메인 오브젝트가 담은 정보를 가져와 화면을 출력하는 데만 사용하는 것이 아니라, 중요한 비즈니스 로직을 담은 메소드를 함부로 호출한다면 심각한 문제가 일어날 수도 있다. 오브젝트를 넘겨받은 이상 그것을 사용히는 데 제약이 없기 때문에 함부로 조작하거나 기능을 실행해버릴 위험이 있다.&lt;/p&gt;

&lt;p&gt;이런 문제를 피하려면 어떻게 해야 할까? 가장 간단한 방법은 철저한 개발 가이드라인을 만들어두고 이를 강력하게 적용하는 것이다.&lt;/p&gt;

&lt;p&gt;예를 들어 프레젠테이션 계층에서는 도메인 오브젝트를 전달받는 접근자를 사용해서 정보를 가져오는 경우와 폼의 결과를 반영할 새로운 도메인 오브젝트를 만들어 수정자를 호출히는 경우 외에는 다른 메소드를 사용하지 않는다는 개발 정책을 만들어두는 것이다.&lt;/p&gt;

&lt;p&gt;문제는 이런 규정을 어기는 개발자가 있다는 점인데 이런 문제는 코딩 정책의 적용을 분석할 수 있는 툴을 이용해 검증하거나 AspectJ의 정책/표준 제화기능을 사용하면 된다. AspectJ를 이용한 방법은 상당히 편리하다. 간단한 포인트컷 표현식만으로 특정 계층의 오브젝트가 사용할 수 있는 메소드의 범위를 제한 히는 등의 정책 강제화 작업을 간단하게 해낼 수 있다. 이 방법에 대해서는 AspectJ 문서나  AspectJ In ActionJ 책을 참조하자.&lt;/p&gt;

&lt;p&gt;두 번째 방법은 도메인 오브젝트는 도메인 계층을 벗어나지 못하게 하는 것이다. 도메인 계층 밖으로 전달될 때는 별도로 준비된 정보 전달용 오브젝트에 도메인 오브젝트의 내용을 복사해서 넘겨줘야 한다. 이런 오브젝트는 데이터 전달을 위해 사용된다고 해서 DTO(Data Transfer Object) 라고 불린다. DTO는 상태의 변화를 허용하지 않고 읽기전용으로 만들어지기도 한다. 반대로 사용자가 등록한 값이나 외부 시스댐으로부터 전달 받은 정보를 도메인 계층으로 전달히는 경우에도 DTO를 이용할 수 있다.&lt;/p&gt;

&lt;p&gt;DTO는 기능을 갖지 않으므로 사용하기 안전하다. 또 도메인 오브젝트를 외부 계층의 코드로부터 보호해준다. 반면에 도메인 오브젝트와 비슷한 구조를 가진 오브젝트를 따로 만들어야 하고 이를 매번 변환해줘야 하는 번거로움이 있다. 따라서 AOP와 같은 방법을 이용해 변환을 자동으로 해주도록 만들 필요가 있다. 이 두 가지 방법 중 어느 것이 더 낫다고 말하기는 힘들다. 기존에 DTO를 이용한 개발에 익숙해져 있다면 후자의 방법도 괜찮을 것이다. 번거로운 작업은 최소화하고 싶고 대신 표준 개발 정책을 잘 따라서 개발하도록 개발팀을 관리할 수 있다면 전자의 방법이 편리하다. 그림 9-22는 도메인 계층 방식의 구조다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a455d482-b42a-4769-94c7-2a6389a622b7/Untitled.png&quot; alt=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a455d482-b42a-4769-94c7-2a6389a622b7/Untitled.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;도메인 계층은 기존 3 계층과 비슷한 수준에서 독립적인 역할을 담당하고 있긴 하지만그 특성은 확연히 다르다.&lt;/p&gt;

&lt;p&gt;서비스를 제공히는 싱글톤으로 계속 존재하는 다른 계층의 오브젝트와 달리, 도메인 계층의 오브젝트는 매우 짧은 시간 동안만 존재했다가 사라지는 것을 반복한다.&lt;/p&gt;

&lt;p&gt;각 사용자의 요청별로 독립적으로 도메인 계층을 이루는 오브젝트들이 생성됐다가 해당 요청 을 처리하고 나면 버려진다. 때론 하나의 복잡한 작업 흐름을 따라서 오래 존재하는 경우도 있지만 여전히 그 생명주기는 짧다.&lt;/p&gt;

&lt;p&gt;도메인 오브젝트는 사용자별 요청에 대해 독립적인 상태를 유지하고 있어야 하기 때문이다. 상태정보를 담고 있기 때문에 여러 스레드가 공유히는 싱글톤이 될 수가 없다.  또 DAO나 컨트롤러, 또는 스프링 외의 라이브러리를 통해 오브젝트가 만들어지는 경우가 많기 때문에 스프링이 관리하는 빈으로 등록조차 불가능하다.&lt;/p&gt;

&lt;p&gt;그렇기 때문에 특별한 방법으로 DI를 해줘야지만 다른 3계층의 빈들과 협력해서 일을 처리할수있다.&lt;/p&gt;

&lt;p&gt;이런 여러 가지 제약과 불편을 감수하면서라도 이 방식을 택해야 하는 경우는 매우 복잡하고 변경이 잦은 도메인을 가졌을 때다.&lt;/p&gt;

&lt;p&gt;복잡한 도메인의 구조와 로직을 최대한 도메인 계층의 오브젝트에 반영하고, 도메인 모벨과 설계에 변경이 발생했을 때 도메인 계층의 오브젝트도 빠르게 대응해서 변경해주기 위해서다. 도메인 계층은 응집도가 매우 높기 때문에 단위 테스트를 작성하기가 편리하다.&lt;/p&gt;

&lt;p&gt;DAO나 외부서비스 오브젝트와 연동할 때도 도메인 오브젝트 타입을 유지할 수 있기 때문에 목 오브젝트 등을 이용해 단위 테스트로 만들기도 쉽다. 도메인이 가진 복잡함을 객체지향적인 설계의 모든 장점을 동원해서 가장 유연한 방법으로 대응할 수 있다.&lt;/p&gt;

&lt;p&gt;반면에 그만큼 복잡하지 않은 애플리케이션이라면 이런 방식을 선택하는 것 자체가 오히려 과도한 부담을 줄 수도 있다.&lt;/p&gt;

&lt;p&gt;따라서 도메인 계층을 이용히는 방식을 선택할 때는 오브젝트 중심 아키텍처의 기본 두 가지 방법을 충분히 경험해보고 오브젝트 중심의 개발 방식에 익숙해진 뒤에 조심스럽게 접근해야 한다.&lt;/p&gt;

&lt;p&gt;AspectJ AOP를 이용해 도메인 오브젝트에 DI를 적용하는 방법은 Vol. 2 의 5장을 참고하기바란다.&lt;/p&gt;

&lt;h3 id=&quot;dto와-리포트쿼리&quot;&gt;DTO와 리포트쿼리&lt;/h3&gt;

&lt;p&gt;오브젝트 중심 아키텍처는 애플리케이션 내의 모든 정보를 항상 도메인 오브젝트에 담고 다녀야 할까? 꼭 그렇지는 않다. 도메인 계층 방식의 경우 도메인 계층을 벗어난 정보를 DTO 라 불리는 특정 계층에 종속되지 않는 정보 전달의 목적을 가진 단순 오브젝트에 담아 샤용하기도 한다. 그 외의 방법에서도 DTO 의 사용이 꼭 필요할 때가 있다. 대표적인 예는 리포트 쿼리라고 불리는 DB 쿼리의 실행 결과를 담는 경우다. 리포트 쿼리는 리포트를 출력하기 위해 생성하는 쿼리라는 의미인데, 단지 리포트를 위해서라기보다는 보통 종합 분석 리포트처럼 여러 테이블에 걸쳐 존재하는 자료를 분석하고 그에 따른 분석/통계 결괴를 생성하는 쿼리라는 의미다.&lt;/p&gt;

&lt;p&gt;이런 쿼리의 결과는 DB 테이블에 담긴 필드의 내용보다는 그 합계, 평균과 같은 계산 값이거나 아니면 여러 테이블의 필드를 다양한 방식으로 조합해서 만들어진다. 따라서 DB 쿼리의 실행 결과를 담을 만한 적절한 도메인 오브젝트를 찾을 수 없다. 그래서 이런 리포트 쿼리의 결과는 DTO 라고 불리는 단순한 자바빈이나 아니면 키와 값 쌍을 갖는 맵에 담아서 전달 해야한다.&lt;/p&gt;

&lt;p&gt;때론 DB 의 쿼리 하나로 최종 결과를 만들어내기 힘들기 때문에 코드를 통해 데이터를 분석하고 가공히는 작업이 필요하다. 이런 경우에도 최종 결괴는 DTO나 맵， 컬렉션에 담겨서 전달돼야한다. 때론 웹 서비스 등의 시스템과 자료를 주고받을 때 전송 규약에 맞춰서 도메인 오브 젝트에 담긴 정보를 가공해야 할 때가 있다. 이런 경우도 DTO나 맵을 이용해 해당 형식에 맞도록 변경히는 작업이 필요하다.&lt;/p&gt;

&lt;h2 id=&quot;934-스프링-애플리케이션을-위한-아키텍처-설계&quot;&gt;9.3.4 스프링 애플리케이션을 위한 아키텍처 설계&lt;/h2&gt;

&lt;p&gt;지금까지 3단계로 역할을 분리하는 계충형 아키텍처와 정보를 다루는 방법에 따른 아키 텍처의 종류를 알아봤다. 그 외에도 다양한 기술 조합과 업무조건, 시스템 환경에 따른 많은 결정요소와 변수가 있다.&lt;/p&gt;

&lt;p&gt;그중에서 계층구조를 어떻게 나눌 것인가와 애플리케이션 정보를 어떻게 다룰지를 결정하는 것이 기본이 된다.&lt;/p&gt;

&lt;p&gt;그리고 그 위에 각 계층에 사용될 구체적인 기술의 종류와 수직 추상화 계층의 도입 세세한 기술적인 조건을 결정하는 일이 남았다.&lt;/p&gt;

&lt;h3 id=&quot;계층형아키텍처&quot;&gt;계층형아키텍처&lt;/h3&gt;

&lt;p&gt;3계층 구조는 스프링을 사용하는 엔터프라이즈 애플리케이션에서 가장 많이 사용되는 구조다. 스프링의 주요 모듈과 기술을 살펴보면 3계층 구조에 적합하도록 설계되어 있다는 사실만 봐도 알 수 있다.&lt;/p&gt;

&lt;p&gt;단 3계층이라는 것은 논리적이고 개념적인 구분이지 쪽오브젝트 단위로 딱 끊어져서 만들어지는 게 아님을 염두에 둬야 한다. 때로는 하나의 계층이 다시 수평으로 세분화될 수도 있다. 반대로 3 계층에서 두 개의 계층이 통합돼서 하나의 오브젝트에 담기는 일도 얼마든지 가능하다.&lt;/p&gt;

&lt;p&gt;예를들어 서비스 계층을굳이 도입하지 않아도 될 만큼 비즈니스 로직이 단순한 애플리케이션이라면 서비스 계층과 데이터 액세스 계층을 통합할 수도 있다. 스프링의 데이터 액세스 기술을 사용하면 복잡하고 지저분하게 반복되는 코드가 대부분 제거되고 핵심 데이터 액세스 로직만 남은 간략한 코드를 가진 DAO를 만들 수 있다. 정보의 등록， 조회， 수정 삭제에 간단한 조건을 이용한 검색만으로 대부분의 기능을 수행할 수 있는 복잡하지 않은 애플리케이션이라면 서비스 계층을 데이터 액세스 계층에 통합히는 것도 나쁘지 않다.&lt;/p&gt;

&lt;p&gt;이때는 트랜잭션 경계설정 위치를 DAO 메소드로 삼으면 된다. 간략한 로직은 DAO 코드에 넣어도 좋다. 반대로 프레젠태이션 계층에 서비스 계층을 통합히는 방법도 가능하다.DAO는 순수한 DB 인터페이스 역할을 하는 데이터 액세스 기능만 갖게 하고 조건에 따른 간단한 로직의 적용은 프레젠테이션 계층의 컨트롤러에 넣는 것이다. 이 방법이 불기능하진 않지만 스프링에서는 그리 권장되지 않는다. 스프링 AOP를 이용해 트랜잭션의 경계를 설정하기가 애매하기 때문이다.&lt;/p&gt;

&lt;p&gt;DAO 가 트랜잭션 경계가 되는 경우에는 트랜잭션 전파 기법을 이용해 여러 개의 DAO 처리를 하나의 트랜잭션으로 조합해서 간단히 묶을수 있다.&lt;/p&gt;

&lt;p&gt;반면에 프레젠테이션 계층의 오브젝트는 트랙잭션 단위로 삼기에는 너무 크고 트랜잭션 전파를 통해 조합하기가 애매하다.&lt;/p&gt;

&lt;p&gt;그래서 굳이 이런 방식을 써야 한다면 TransactionTemplate을 이용해 코드에 의한 트랜잭션 경계설정을 해야 하는데 이는 너무번거롭다.&lt;/p&gt;

&lt;p&gt;따라서 3계층을 단순화해서 2계층으로 만든다면 서비스 계층과 데이터 액세스 계층을 통합하는 편이 낫다.&lt;/p&gt;

&lt;p&gt;물론 이때도 논리적으로는 서비스 계층과 데이터 액세스 계층의 경계를 분명하게 하는 게 좋다. 같은 오브젝트에 담겨 있다고 할지라도 비즈니스 로직을 적용한다면 각각 독립적으로 메소드를 분리해두는 것이 바람직하다.&lt;/p&gt;

&lt;p&gt;프레젠테이션 계층은 보통 MVC 라는 이름으로 잘 알려진 패턴 또는 아키텍처를 주로 사용한다. 스프링의 대표적인 프레젠태이션 기술도 SpringMVC 라는 이름을 갖고 있고, 이름처럼 MVC 패턴을지원하게 되어 있다.&lt;/p&gt;

&lt;p&gt;SpringMVC를다루는 Vol.2 의 3 장과 4장에서 자세히 살펴보겠지만, 스프링은 이 MVC 중 가장 부담을 많이 지고 있는 컨트롤러(C) 에 해당하는 부분을 또 다시 세분화해서 여러 단계의 오브젝트로 만들 수 있도록 설계되어 있다.&lt;/p&gt;

&lt;p&gt;이런 식으로 계층 내의 역할을 좀 더 세분화히는 경우도 있다. 프레젠태이션 계층은 특히 그 경계를 애플리케이션이 배치된 서버를 떠나서 클라이언트까지 확장하기도 한다.&lt;/p&gt;

&lt;p&gt;SOFEA (Service Oriented Front End Architecture)라고 불리는 아키텍처는 프레젠테이션 계층의 코드가 서버에서 클라이언트로 다운로드돼서 클라이언트 장치안에서 동작하면서 서버에 존재하는 서비스 계층 또는 부분 프레젠태이션 계층과 통신하는 구조로 만들어진다. 브라우저 안에서 동작하는 자바스크립트나 플래시 기반의 애플리케이션을 포함해서 JVM 나 클라이언트 OS 에서 독립적으로 동작하는 기술도 계속 발전하고 있다. 이때는 프레젠테이션 계층이 가졌던 사용자와의 인터페이스， 화면 흐름에 대한 제어, 서비스 계층과의 통신, 상태정보의 유지 등을 클라이언트에 다운로드된 코드에서 대부분 담당하게 된다. 그림 9-2 에 나와 있는 SOFEA는 전통적인 MVC 기반의 모델2 아키텍처의 위치를 위협할 만큼 빠르게 성장하고 있다. 스프링 또한 이런 기술의 변화에 맞춰서 다양한 지원을 늘리고 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5ea4e7cc-2ee6-4ccf-b370-197286e412eb/Untitled.png&quot; alt=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5ea4e7cc-2ee6-4ccf-b370-197286e412eb/Untitled.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;스프링을 처음 학습하고 도입히는 입장이라면 일단은 가장 전통적인 서버 기반의 3계층 구조에 먼저 익숙해지는 것이 좋다. 프레젠테이션 계층은 SpringMVC를 이용하고 서비스 계층은 POJO로 구현하면서 트랜잭션 AOP를 적용하고, 데이터 액세스 계층은 JDBC를 비롯해서 스프링의 데이터 액세스 전략이 적용된 JPA. 하이버네이트. JDO 등을 활용하도록 돕는 것이다. 처음에는 이 3계층 방식의 아키텍처 위에서 스프링의 철학과 가치를 따라서 코드를 만드는 데 익숙해진 디음 차차 다양한 방식으로 계층구조의 통합과 분산을 시도해보자.&lt;/p&gt;

&lt;h3 id=&quot;정보전송-아키텍처&quot;&gt;정보전송 아키텍처&lt;/h3&gt;

&lt;p&gt;스프링의 기본 기술에 가장 잘 들어맞고 쉽게 적용해볼 수 있는 것은 오브젝트 중심 아키텍처의 도메인 오브젝트 방식이다. 일단은 빈약한 도메인 오브젝트 방식으로 시작하는 게 가장 쉽다. 도메인 오브젝트를 계층 간의 정보 전송을 위해 사용하고， 이를 각 계층의 코드에서 활용한다. DAO는 그 기술이 어떤 것이든 상관없이 서비스 계층에서 요청을 받거나 결과를 돌려줄 때 도메인 오브젝트 형태를 유지하게 만든다. 서비스 계층의 비즈니스 로직 또한 도메인 오브젝트를 이용해 작성한다. 가능하다면 도메인 오브젝트에 단순한 기능이라도 추가하도록 노력해보는 것이 좋다.&lt;/p&gt;

&lt;p&gt;프레젠테이션 계층에서도 이 도메인 오브젝트를 직접 활용하도록 만든다. 프레젠테이션 계층의 MVC 아키텍처 에서도 모델은 도메인 오브젝트를 그대로 사용한다. 뷰에 전달하는 정보도 물론 도메인 오브젝트를 사용하는 모델이고, 사용자가 입력하는 폼의 정보도 도메인 오브젝트로 변환해서 사용한다. 이렇게 도메인 오브젝트를 사용해 애플리케이션의 정보를 일관된 형태로 유지하는게 스프링에 가장 잘 들어맞는 방식이다. 스프링에 포함된 예제나, 스프링 개발자들이 저술한 책에 나오는 샘플 애플리케이션 그리고 스프링의 각 기술의 API 사용 방법을 살펴보면 거의 대부분이 방식을사용하고 있다.&lt;/p&gt;

&lt;p&gt;DB와 SQL 에 많은 비즈니스 로직을 담고 있는 레거시 시스템을 스프링으로 전환하는 경우라면, 일단 데이터 중심의 아키텍처를 시용해도 무방하다.&lt;/p&gt;

&lt;p&gt;3계층의 기본 구조로 잘 분리할 수만 있다면 DB 중심의 접근 방법을 사용해서 기존에 만들어 사용해봤던 SQL을 재사용한다.&lt;/p&gt;

&lt;p&gt;그리고 전환 작업을 마치고 검증이 끝난 후에 단계적으로 로직을 DB 에서 애플리케이션으로 가져오고, 오브젝트 중심으로 전환하는 시도를 하면 된다. 레거시 시스템의 기능은 가져오되 구현은 새롭게 처음부터 시작할 수 있다면 스프링의 철학과 개념에 가장 잘 들어맞는 도메인 오브젝트 중심의 아키텍처에 도전해보는 편이 나을것이다.&lt;/p&gt;

&lt;p&gt;객체지향적인 도메인 분석과 모델링에 자신이 있고 도메인 오브젝트 설계와 구현, 독립적인 태 스트를 자유롭게 적용할 수 있다면 과감하게 도메인 계층 방식을 도입할수도 있다. 다만 도메인 계층에 DI 를 적용하기 위해 스프링의 고급 기술을 활용해야 하고 여러 가지 고려할 점이 많으므로 충분한 사전 학습과 검증이 먼저 진행돼야 한다.&lt;/p&gt;

&lt;h3 id=&quot;상태관리와-빈-스코프&quot;&gt;상태관리와 빈 스코프&lt;/h3&gt;

&lt;p&gt;아키텍처 설계에서 한 가지 더 신경 써야 할 사항은 상태 관리다. 크게는 사용자 로그인 세션 관리부터, 작게는 하나의 단위 작업이지만 여러 페이지에 걸쳐 진행되는 위저드 기능까지 애플리케이션은 하나의 HTTP 요청의 범위를 넘어서 유지해야 하는 상태정보 가있다. 엔터프라이즈 애플리케이션은 특정 사용자가 독점해서 배타적으로 사용되지 않는 다. 하나의 애플리케이션이 동시에 수많은 사용자의 요청을 처리하게 하기 위해 매번 간단한 요청을 받아서 그 결과를 돌려주는 방식으로 동작한다. 따라서 서버의 자원이 특정 사용자에게 일정하게 할당되지 않는다. 그래서 서버 기반의 애플리케이션은 원래 지속적으로 유지되는 상태를 갖지 않는다는 특정이 있다. 클라이언트로부터의 요청을 처리히는 매우 짧은 시간 동안만 도메인 오브젝트와 같은 정보저장소에 현재 상태정보가 보관되지만, 이는 요청 결과를 클라이언트에 돌려주고 나면 바로 폐기된다.&lt;/p&gt;

&lt;p&gt;그 덕분에 수많은 동시 사용자의 요청을 제한된 서버리소스를 가지고 처리할 수 있다. 하지만 어떤 식으로든 애플리케이션의 상태와 장시간 진행되는 작업정보는 유지돼야 한다. 이를 위해서 웹 클라이언트에 URL, 파리미터, 폼 히든 필드, 쿠키 등을 이용해 상태정보 또는 서버에 저장된 상태정보에 키 값 등을 전달해야 한다.&lt;/p&gt;

&lt;p&gt;클라이언트와 서버 사이에서 많은 양의 정보를 계속해서 주고받을 수는 없으므로 중요한 상태정보는 파일 시스템, 데이터그리드 DB 등에 저장되기도 한다.&lt;/p&gt;

&lt;p&gt;또는 제약이 있기는 하지만 HTTP 세션과 같은 서블릿 컨테이너가 제공하는 저장공간을 활용하기도 한다. 이렇게 상태를 저장， 유지하는 데 어떤 방식을 시용할지 결정히는 일은 매우 중요하다.&lt;/p&gt;

&lt;p&gt;스프링은 기본적으로 상태가 유지되지 않는 빈과 오브젝트를 사용하는 것을 권장한다. 웹의 생리에 가장 잘 들어맞고 개발하기 쉽기 때문이다. 또, 서버를 여러 대로확장 하기가 매우 쉽다.&lt;/p&gt;

&lt;p&gt;반면에 웹 클라이언트에 폼 정보를 출력하고 이를 수정하는 등의 작업을 위해서는 HTTP 세션을 적극 활용하기도 한다.&lt;/p&gt;

&lt;p&gt;대부분의 폼 등록, 수정 작업은 한 페이지짜리 폼이라도 여러 번의 HTTP 요청에 걸쳐 일어나기 때문에 작업 중인 폼의 내용을 짧은 동안에라도 서버에 저장해둘 필요가 있다. 상태는 클라이언트, 백엔드에 저장해두거나 서블릿의 HTTP 세션 정도에 일시적으로 저장해두는 것이 대부분이지만 경우에 따라서는 장기간 유지되며 중첩될 수 있는 상태를 다루는 고급 상태 관리 기법을 이용할 수도 있다.&lt;/p&gt;

&lt;p&gt;애플리케이션의 특정에 따라서 스프링을 이용해서 상태유지 stateful 스타일의 애플리케이션을 얼마든지 만들 수 있다.&lt;/p&gt;

&lt;p&gt;스프링에서는 싱글톤 외에도 다른 스코프를 갖는 빈을 간단히 만들 수 있다. 빈의 스코프를 잘 활용하면 스프링이 관리하는 빈이면서 사용자별로 또는 단위 작업별로 독립 적으로 생성되고 유지되는 오브젝트를 만들어 상태를 저장하고 이를 DI를 통해 서비스 빈에서 사용하게 만들 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;서드파티-프레임워크-라이브러리-적용&quot;&gt;서드파티 프레임워크， 라이브러리 적용&lt;/h3&gt;

&lt;p&gt;스프링은 거의 대부분의 자바 표준 기술과 함께 사용될 수 있다.&lt;/p&gt;

&lt;p&gt;기본적으로는 J2EE 1.4와 JavaEE 5.0을 지원한다. 따라서 스프링으로 만든 애플리케이션은 lSP, lSF , EJB , JNDI , JTA , lCA , lAX-WS , lMS , lavaMail , lPA와 같은 JavaEE 의 세부 기술과 함께 사용될 수 있다.&lt;/p&gt;

&lt;p&gt;스프링 애플리케이션은 기본적으로 서블릿을 기반으로 하는 독립 웹 모듈로 만들어진다. 스프링이 제공하는 많은 APl 는 이러한 표준 javaEE 의 인터페이스를 사용할 수 있도록 설계되어 있다. 최근에 등장한 JavaEE 6 의 표준 일부도 지원하고있다.&lt;/p&gt;

&lt;p&gt;표준 기술 외에도 많이 사용되는 오픈소스 프레임워크 라이브러리나 상용 제품도 스프링과 함께 시용할 수 있다. 이런 기술을 스프링과 함께 사용할 때는 먼저 스프링이 공식적으로 지원하는 기술인지 확인해본다.&lt;/p&gt;

&lt;p&gt;스프링이 직접 지원하는 오픈소스 ORM 의대표 제품으로는 하이버네이트와 iBatis 그리고 EclipseLi 뼈, OpenJPA와 같은 오픈소스 JPA 가 있고, 웹 프레임워크로는 스트렷츠 1/2, WebWork, Tapestry , Tiles 등을 꼽을수 있다. 그 외에도 다양한 ORM 라이브러리를 지원하고,  메시징 서버와 웹 서비스 기술 등을 지원한다. 스프링의 의존 라이브러리로 등록된 100 여 개의 각종 라이브러리를 살펴보면 스프링이 직접 API 나 추상화 서비스 등을 통해 지원하는 표준 또는 오픈소스, 상용 기술에는 어떤 것이 있는지 알수 있다. 그렇다면 스프링이 지원하는 기술이란 무슨 의미일까?&lt;/p&gt;

&lt;h3 id=&quot;첫째-해당-기술을-스프링의-di때턴을-따라-사용할-수-있다&quot;&gt;첫째， 해당 기술을 스프링의 DI때턴을 따라 사용할 수 있다&lt;/h3&gt;

&lt;p&gt;프레임워크나 라이브러리의 핵심 클래스를 빈으로 등록할 수 있게 지원해주는 것이 라고 생각해도 좋다. 코드를 이용해 초기화해야만 사용할 수 있는 기능을 빈을 등록 히는 것만으로 바로 사용할 수 있다. 프레임워크의 핵심 오브젝트를 빈의 형태로 등록해둘 수 있다변 프로퍼티를 이용해 세부 설정을 조정할 수도 있고， DI를 통해 다른 오브젝트에서 손쉽게 활용할 수도 있다. 또 스프링이 제공하는 추상화 서비스를 통해 다른 리소스에 투명하게 접근할 수도 있다.&lt;/p&gt;

&lt;p&gt;예를 들어 하이버네이트의 기능을 사용하려면 SessionFactory 오브젝트가 먼저 만들어져야 한다. SessionFactory 가 만들어지려면 설정파일에 대한 정보, 설정 값을 담은 프로퍼티와 DB 연결에 대한 정보가 필요하다. SessionFactory를 만들기 위해서는 먼저 설정을 담은 Configuration 오브젝트를 만들고 이를 이용해 다시 SessionFactory를 만드는 등의 작업이 펼요하다.&lt;/p&gt;

&lt;p&gt;스프링에서는 하이버네이트의 SessionFactory를 스프링이 제공하는 빈을 등록하는 것만으로 간단히 생성할 수 있게 해주는 LocalSessionFactoryBean 이라는 클래스를 제공한다. LocalSessionFactoryBean 클래스를 빈으로 등록하고 적절한 프로퍼티 설정을 해주면 간단히 SessionFactory 오브젝트가 만들어져 빈으로 등록된다.&lt;/p&gt;

&lt;p&gt;이름에서 알 수 있듯이 LocalSessionFactoryBean은 빈 오브젝트를 생성하고 초기화하는 기능을 가진 팩토리 빈이다. 이 클래스를 빈으로 등록하면 싱글톤 빈으로 존재하는 하이버네이트 SessionFactory 가 만들어지고 하이버네이트의 SessionFactory 가필요한 모든 빈에서 간단히 DI를 통해 가져다 사용할 수 있다. 또， DataSource와 같이 SessionFactory 가 펼요로 하는 리소스는 스프링의 빈으로 등록된 DataSource를 DI받아 사용하도록 만들어주기도 한다.&lt;/p&gt;

&lt;p&gt;리스트 9-14는 LocalSessionFactoryBean 을 이용해 SessionFactory 빈을 정의한 예다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6b37b4a3-33f0-4916-b52d-5dc6cbe49d0e/Untitled.png&quot; alt=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6b37b4a3-33f0-4916-b52d-5dc6cbe49d0e/Untitled.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/884374e7-3e06-461d-a7e4-34193cce0c06/Untitled.png&quot; alt=&quot;https://s3-us-west-2.amazonaws.com/secure.notion-static.com/884374e7-3e06-461d-a7e4-34193cce0c06/Untitled.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이처럼 스프링 외의 기술을 접목할 때는 가장 먼저 스프링의 빈으로 등록해서 DI방식을 통해 사용 가능한지 살펴봐야 한다. 만약 빈으로 등록해서 바로 사용할 수 있는 구조로 핵심 API 나 클래스가 만들어져 있지 않은 경우라면, 위의 예처럼 스프링 빈으로 등록돼서 사용하기에 적합하도록 만들어주는 팩토리 빈을 도입해야 한다.&lt;/p&gt;

&lt;p&gt;스프링이 지원하는 프레임워크나 라이브러리는 대부분 이와 같이 스프링 빈의 설정만 으로 등록하고 사용 가능하도록 팩토리 빈 클래스가 제공된다. myDataSource 빈에 사용한 DBCP 의 BasicDataSource 같은 경우는 그 자체로 바로빈으로등록하고프로퍼티 설정해서 사용할수있는구조로되어 있다. 따라서 별도의 스프링 지원 없이도 손쉽게 스프링 애플리케이션에서 사용이 가능하다.&lt;/p&gt;

&lt;h3 id=&quot;둘째-스프링의-서비스-추상화가-적용됐다&quot;&gt;둘째， 스프링의 서비스 추상화가 적용됐다&lt;/h3&gt;

&lt;p&gt;이미 트랜잭션이나 OXM(Object-XML Mapping) 등의 예에서 다양한 오픈소스 프레임워크 또는 표준 기술에 대한스프링의 서비스추상화 기술을 살펴봤다. 첫 번째 방법은사용할 기술을 스프링의 빈으로 등록하고 설정 가능하도록 지원해췄을 뿐이고, 사용기술의 API는 애플리케이션에 그대로 노출한다.&lt;/p&gt;

&lt;p&gt;서비스 추상화를 적용하는 경우는 이보다 한 발 더나아가서 비슷한 기능을 제공하는 기술에 대한 일관된 접근 방법을 정의해준다.&lt;/p&gt;

&lt;p&gt;이를 통해 서드파티 프레임워크를 적용할 수 있을 뿐만 아니라 필요에 따라 호환 가능한 기술로 손쉽게 교체해서 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;자바의 표준 기술이란 JCP를 통해 제정된 표준 스펙일 뿐이다. 다양한 벤더와 프로젝트 그룹이 이 스펙을 따라서 실제 구현을 만든다. 표준 스펙에 정의된 API를 이용해 개발하기만 하면 실제 기술의 구현 제품은 교환해서 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;이와 비슷한 원리를 다양한 비표준 기술과 영역에 확장해서 적용한 것이 바로 스프링의 서비스 추상화라고 볼 수 있다. 상세한 스펙을 따라서 엄밀하게 적용되는 표준과는 다르지만, 개발자에게는 표준 기술을 사용하듯이 일관된 방법으로 코드를 작성하게 해준다는 것은 중요한 의미가 있다. 스프링이 제공하는 서비스 추상화가 표준 기술 스펙과 다른 것은 서비스 추상화는 이미 존재히는 다양한 기술의 공통점을 분석해서 추상화를 했다는 점이다.&lt;/p&gt;

&lt;p&gt;따라서 추상 서비스 인터페이스를 구현해서 각기술과 연동하게 해주는 어댑터 클래스가 필요하다. 서비스 추상화 인터페이스를 구현한 클래스들은 모두 스프링의 빈으로 등록되도록 만들어졌고，&lt;/p&gt;

&lt;p&gt;세부 기술의 특성에 맞는 설정이 손쉽게 가능하도록 다양한 프로퍼티를 제공하고 있다.&lt;/p&gt;

&lt;h3 id=&quot;셋째-스프링이-지지하는-프로그래밍-모델을-적용했다&quot;&gt;셋째， 스프링이 지지하는 프로그래밍 모델을 적용했다&lt;/h3&gt;

&lt;p&gt;스프링이 지지히는 프로그래밍 모델이 적용된 대표적인 예는 스프링의 데이터 액세스 기술에 대한 일관된 예외 적용이다.&lt;/p&gt;

&lt;p&gt;스프링의 데이터 액세스 지원 기능을 사용하면 데이터 액세스 기술의 종류에 상관없이 일관된 예외 계층구조를 따라서 예외가 던져진다. 여기에는 기술에 독립적인 DAO를 만들 수 있도록 데이터 액세스 예외를 추상화하고, 불필요하게 예외를 처리히는 코드를 피하도록 런타임 위주의 예외를 사용한다는 스프링의 개발철학이 적용된 것이다. 이를 통해, 서비스 계층의 비즈니스 로직을 담은 코드가 데이터 액세스 계층의 기술에 종속되지 않도록 만들어준다.&lt;/p&gt;

&lt;h3 id=&quot;넷째-템폴릿콜백이-지원된다&quot;&gt;넷째， 템폴릿/콜백이 지원된다&lt;/h3&gt;

&lt;p&gt;스프링은 JDBC , JMS, JCA를 비롯한 20여 가지 기술을 지원히는 템플릿/콜백을 제공한다. 이런 기술은 그대로 사용하면 반복적으로 등장하는는 판에 박힌 코드 때문에 전체 코드가 지저분해지고 이해하기 힘틀고 추상화하기도 어려운 구조가 돼 버린다. 스프링은 이런 기술을 간편하게 사용할 수 있도록 템플릿/콜백 기능을 제공한다. 대부분의 템플릿 클래스는 빈으로 등록해서 필요한 빈에서 DI 받아 사용할 수 있다.&lt;/p&gt;

&lt;p&gt;스프링이 어떤 기술을 지원한다는 건 결국 스프링이 지지히는 개발철학과 프로그래밍 모델을 따르면서 해당 기술을 사용할 수 있다는 의미다.&lt;/p&gt;

&lt;p&gt;물론 이런 방법을 따르지 않고도 스프링에서 여타 프레임워크를 사용하거나 라이브러리를 이용할 수는 있다. 그 대신 스프링의 장점을 포기해야 하고 일관된 구조의 유연하고 확장 가능한 코드를 만들기가 힘들수있다.&lt;/p&gt;

&lt;p&gt;물론 스프링이 세상에 나와 있는 모든 기술과 프레임워크를 지원하진 않는다. 지원할 수도 없다. 스프링이 직접 지원히는 수십여 가지의 표준, 오픈소스, 상용 기술은 엔터프라이즈 애플리케이션 개발에 보편적으로 사용되는 유명한 것들로 제한된다.&lt;/p&gt;

&lt;p&gt;대신 스프링의 기술 지원 방법은 스프링의 핵심 기술과 프로그래밍 모델만 잘 이용하면 어떤 기술에든지 손쉽게 적용이 가능하다. 따라서 스프링이 직접 지원하는 기술이 아니라도 앞에서 소개한 네 가지 방법을 따라서 사용하도록 만들 수 있다.&lt;/p&gt;

&lt;p&gt;스프링 익스텐션 (http ://www . springsource. org/extensions)은 스프링이 직접 지원하지 않지만 나름 유용한 기술에 대해 스프링 스타일의 지원 기능을 만들어둔 대표적인 프로젝트다.&lt;/p&gt;

&lt;p&gt;스프링 개발팀 이 나 스프링 커뮤니티에서 지원기능을 제공하지 않더라도 서드파티 기술이나 프레임워크가 자체적으로 스프링 에 서 손쉽게 사용될 수 있도록 관련 기능을 제공하는 경우도 적지 않다. 오라클의 TopLink 같은 상용 ORM 솔루션부터 아파치의 Strut5 2 같은 최신 웹 프레임워크， JB055 의 Seam 같은 애플리케이션 프레입워크에 이르기까지 다양한 제품이 스프링 내에서 손쉽게 사용할 수 있는 스프링 지원 기능을 직접제공해주고있다.&lt;/p&gt;

&lt;p&gt;개발팀이나 기업에서 자체적으로 만든 사내 기술이나 스프링 지원 기능이 제공되지 않는 새로운 서드파티 기술을 사용해야 한다면 어떻게 해야 할까? 가장 쉽지만 가장 나쁜 방법은 해당 기술을 사용히는 코드는 전혀 스프링답지 않게 만드는 것이다.&lt;/p&gt;

&lt;p&gt;빈으로 등록되도록 만들지도 않고 펼요할 때마다 여기저기서 오브젝트를 직접 만들고 초기화 하는 코드를 넣어서 사용한다거나 다른 기술로 대체될 가능성이 충분히 있음에도 추상회를 적용하지 않고 특정 기술에 종속되는 코드에서 직접 사용한다거나， try / catch/ finally 블록으로 범벅된 코드를 마구 중복해가며 사용하는 것이다. 당장 기능은 돌아 가겠지만 기껏 스프링을 사용하면서 깔끔하고 유연하게 만들었던 코드가 금새 지저분 해지고 코드의 일관성도 없어지며 유연성도 떨어질 것이 분명하다. 제법 스프링을 잘안다고 자신하고 스프링을 적용한 개발 경험이 많다는 개발자도 이런 식으로 접근하는 경우가적지않다. 적어도 스프링을 사용해 애플리케이션을 개발하겠다고 마음먹었다면 사용하려는 모든 기술에 스프링다운 방식으로 접근해야 하지 않을까? 스프링에 새로운 기술을 연동하려면 이 책에서 설명했던 스프링의 프로그래밍 모댈과 지지하는 개발철학을 따르면서 앞에서 설명한 네 가지 방법을 이용하면 된다.&lt;/p&gt;

&lt;p&gt;가장 기초는 스프링의 빈으로 해당 기술의 핵심 오브젝트가 등록되도록 만드는 것이다. 필요에 따라 팩토리 빈을 사용해서 오브젝트 생성과 초기화 작업 프로퍼티 노출 등을 해줘야 한다. 애플리케이션 내의 빈들이 새로운 기술에 대해 빈을 DI 히는 방법으로 접근할수 있게 하는 것이다. 반대로 기존 빈 오브젝트를 새로 추가할 기술에서 사용할 수 있게 해줄 필요도 있다. 어떤 경우든 코드에 의한 초기화 작업이 필요하므로 팩토리 빈을 만들어 사용하면 편리하다. 때로는 서비스 추상화를 시도할 경우도 있다. 어떤 경우는 스프링이 이미 제공히는 추상 인터페이스의 새로운 구현으로 만들어질 수 있고 아예 새로운 추상화 인터페이스를 정의해서 적용할 수도 있다. 특히 JavaMail처럼 태스트가 매우 까다롭게 설계된 기술이고 DI 해서 사용하기 불편하다면 유연한 설정과 더불어 테스트를 위해서라도 새로운 인터 페이스를 추가할 필요가 있다.&lt;/p&gt;

&lt;p&gt;네트워크 접근이나 파일 IO 처럼 실패할 가능성이 있는 시도를 하는 기술이라면 템플릿/콜백 방식의 적용도 적극 고려해보자. 기술을 사용할 때마다 반복적으로 try/catch/ finally 블록이 필요한 기술이라면 템플릿/콜백이 제격이다.&lt;/p&gt;

&lt;p&gt;때로는 AOP 나 예외 전환을 적용할 수도 있다. 보통 외부에서 가져와서 사용히는 기술은 내부 구현 방식에 손을 대기 쉽지 않다. 소스코드가 공개되고 수정이 가능한 오픈 소스라고 할지라도 코드를 한번 손대기 시작하면 이후 버전과 호환성이 떨어지기 때문에 함부로 수정해서 사용하기는 힘들다.&lt;/p&gt;

&lt;p&gt;따라서 가능하면 외부 기술의 코드에는 손을 대지 않고 사용방법을 개선하는 작업이 필요하다. 예외 변환은 종종 AOP를통해 많이 이뤄진다. 특정 예외가 던져졌을 때에 대한 포인트컷을 만들어두고 어드바이스에서 예외를 추상화된 런타임 예외로 바꿔서 다시 던져주면 된다. 그러면 해당 API 를 샤용하는 코드를 전혀 손대지 않고도 손쉽게 예외 변환이 가능하다&lt;/p&gt;

&lt;p&gt;2권의 2장에서 소개히는 스프링의 하이버네이트나 jPA 지원 기능 중에서 예외 전환을 위해 AOP를 이용하는 예를 참고해보면 도움이 될 것이다.&lt;/p&gt;

&lt;p&gt;스프링이 직접 지원 기능을 제공해주지 않으면 무엇인가 시도해볼 생각도 없이 스프링 이전의 방식대로 코드를 만들어서 외부 기술을 사용하는 건 부끄러운 일이다. 스프링을 사용하려면 스프링의 프로그래밍 모댈과 그에 담긴 개발 철학을 따르는 일관된 코드를 만드는 데 많은 관심을 기울여야 한다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>seongtaekkim</name>
        
        
      </author>

      

      
        <category term="spring" />
      

      
        <summary type="html">– 토비의스프링 1권 정리 토비의스프링1권 8장 토비의스프링1권 9장</summary>
      

      
      
    </entry>
  
</feed>
