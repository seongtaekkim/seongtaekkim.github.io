<!DOCTYPE html>
<html>
<head>

    <!-- Document Settings -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- Base Meta -->
    <!-- dynamically fixing the title for tag/author pages -->



    <title>토비의스프링2권 2장</title>
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- Styles'n'Scripts -->
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.edited.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/syntax.css" />

    <!--custom.css -->
    <link rel="stylesheet" type="text/css" href="/assets/built/custom.css" />

    <!--web font-->
    <link rel="stylesheet" href="https://fonts.googleapis.com/earlyaccess/nanumgothic.css">

    <!--font Awesome-->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

    <!--syntax.css 추가-->
    <link rel="stylesheet" type="text/css" href="/assets/built/syntax.css" />

    <!-- highlight.js -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">
    <style>.hljs { background: none; }</style>

    <!--[if IE]>
        <style>
            p, ol, ul{
                width: 100%;
            }
            blockquote{
                width: 100%;
            }
        </style>
    <![endif]-->
    
    <!-- This tag outputs SEO meta+structured data and other important settings -->
    <meta name="description" content="IT" />
    <link rel="shortcut icon" href="https://seongtaekkim.github.io/assets/built/images/favicon.jpg" type="image/png" />
    <link rel="canonical" href="https://seongtaekkim.github.io/spring-toby2_2" />
    <meta name="referrer" content="no-referrer-when-downgrade" />

     <!--title below is coming from _includes/dynamic_title-->
    <meta property="og:site_name" content="웹개발자" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="토비의스프링2권 2장" />
    <meta property="og:description" content="– 토비의스프링 2권 정리 – 토비의스프링2권 2장 트랜잭션 스프링이 처음 등장했을 때의 모토는 “객체지향 원칙에 충실한 POJO 에 엔터프라이즈 서비스를 제공한다”였다. 엔터프라이즈 서비스가 제공되는 컴포넌트를 지향하던 당시의 EJB는 특정 클래스의 상속과 인터페이스 구현을 강제하고 툴의 지원 없이는 작성이 거의 불가할 정도로 복잡한 XML 설정파일과 고가의 서버와 컨테이너 등을 필요로 했다." />
    <meta property="og:url" content="https://seongtaekkim.github.io/spring-toby2_2" />
    <meta property="og:image" content="https://seongtaekkim.github.io/assets/built/images/bus.jpg" />
    <meta property="article:publisher" content="https://www.facebook.com/" />
    <meta property="article:author" content="https://www.facebook.com/" />
    <meta property="article:published_time" content="2021-08-19T19:36:01+09:00" />
    <meta property="article:modified_time" content="2021-08-19T19:36:01+09:00" />
    <meta property="article:tag" content="Spring" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="토비의스프링2권 2장" />
    <meta name="twitter:description" content="– 토비의스프링 2권 정리 – 토비의스프링2권 2장 트랜잭션 스프링이 처음 등장했을 때의 모토는 “객체지향 원칙에 충실한 POJO 에 엔터프라이즈 서비스를 제공한다”였다. 엔터프라이즈 서비스가 제공되는 컴포넌트를 지향하던 당시의 EJB는 특정 클래스의 상속과 인터페이스 구현을 강제하고 툴의 지원 없이는 작성이 거의 불가할 정도로 복잡한 XML 설정파일과 고가의 서버와 컨테이너 등을 필요로 했다." />
    <meta name="twitter:url" content="https://seongtaekkim.github.io/" />
    <meta name="twitter:image" content="https://seongtaekkim.github.io/assets/built/images/bus.jpg" />
    <meta name="twitter:label1" content="Written by" />
    <meta name="twitter:data1" content="웹개발자" />
    <meta name="twitter:label2" content="Filed under" />
    <meta name="twitter:data2" content="Spring" />
    <meta name="twitter:site" content="@" />
    <meta name="twitter:creator" content="@" />
    <meta property="og:image:width" content="1400" />
    <meta property="og:image:height" content="933" />

    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Website",
    "publisher": {
        "@type": "Organization",
        "name": "웹개발자",
        "logo": "https://seongtaekkim.github.io/"
    },
    "url": "https://seongtaekkim.github.io/spring-toby2_2",
    "image": {
        "@type": "ImageObject",
        "url": "https://seongtaekkim.github.io/assets/built/images/bus.jpg",
        "width": 2000,
        "height": 666
    },
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://seongtaekkim.github.io/spring-toby2_2"
    },
    "description": "– 토비의스프링 2권 정리 – 토비의스프링2권 2장 트랜잭션 스프링이 처음 등장했을 때의 모토는 “객체지향 원칙에 충실한 POJO 에 엔터프라이즈 서비스를 제공한다”였다. 엔터프라이즈 서비스가 제공되는 컴포넌트를 지향하던 당시의 EJB는 특정 클래스의 상속과 인터페이스 구현을 강제하고 툴의 지원 없이는 작성이 거의 불가할 정도로 복잡한 XML 설정파일과 고가의 서버와 컨테이너 등을 필요로 했다."
}
    </script>

    <!-- <script type="text/javascript" src="https://demo.ghost.io/public/ghost-sdk.min.js?v=724281a32e"></script>
    <script type="text/javascript">
    ghost.init({
    	clientId: "ghost-frontend",
    	clientSecret: "f84a07a72b17"
    });
    </script> -->

    <meta name="generator" content="Jekyll 3.6.2" />
    <link rel="alternate" type="application/rss+xml" title="토비의스프링2권 2장" href="/feed.xml" />


</head>
<body class="post-template">

    <div class="site-wrapper">
        <!-- All the main content gets inserted here, index.hbs, post.hbs, etc -->
        <!-- default -->

<!-- The tag above means: insert everything in this file
into the {body} of the default.hbs template -->

<header class="site-header outer">
    <div class="inner">
        <nav class="site-nav">
    <div class="site-nav-left">
        
            
                <a class="site-nav-logo" href="https://seongtaekkim.github.io/">웹개발자</a>
            
        
        
            <ul class="nav" role="menu">
    <li class="nav-home" role="menuitem"><a href="/">Home</a></li>
    <li class="nav-about" role="menuitem"><a href="/about/">About</a></li>
    <li class="nav-spring" role="menuitem"><a href="/tag/spring/">spring</a></li>
    <li class="nav-python" role="menuitem"><a href="/tag/java/">java</a></li>
    <li class="nav-archive" role="menuitem">
        <a href="/archive.html">All Posts</a>
    </li>
    <li class="nav-archive" role="menuitem">
        <a href="/author_archive.html">Tag별 Posts</a>
    </li>
</ul>
        
    </div>
    <div class="site-nav-right">
        <div class="social-links">
            
            
        </div>
        
            <a class="subscribe-button" href="#subscribe">Search</a>
        
    </div>
</nav>

    </div>
</header>

<!-- Everything inside the #post tags pulls data from the post -->
<!-- #post -->

<main id="site-main" class="site-main outer" role="main">
    <div class="inner">

        <article class="post-full  tag-spring post tag-spring ">

            <header class="post-full-header">
                <section class="post-full-meta">
                    <time class="post-full-meta-date" datetime="19 August 2021">19 August 2021</time>
                    
                        <span class="date-divider">/</span>
                        
                            
                               <a href='/tag/spring/'>SPRING</a>
                            
                        
                    
                </section>
                <h1 class="post-full-title">토비의스프링2권 2장</h1>
            </header>

<!-- 블로그 글 입장 시 커버이미지 표시
           
            <figure class="post-full-image" style="background-image: url(/assets/built/images/bus.jpg)">
            </figure>
            -->

            <section class="post-full-content">
                <div class="kg-card-markdown">
                    <p><span class="table-of-contents-list">– 토비의스프링 2권 정리 –</span></p>
<ul class="table-of-contents-list">
    <li><a href="./spring-toby2_2">토비의스프링2권 2장</a></li>
</ul>

<h1 id="트랜잭션">트랜잭션</h1>

<p>스프링이 처음 등장했을 때의 모토는 “객체지향 원칙에 충실한 POJO 에 엔터프라이즈 서비스를 제공한다”였다. 엔터프라이즈 서비스가 제공되는 컴포넌트를 지향하던 당시의 EJB는 특정 클래스의 상속과 인터페이스 구현을 강제하고 툴의 지원 없이는 작성이 거의 불가할 정도로 복잡한 XML 설정파일과 고가의 서버와 컨테이너 등을 필요로 했다.</p>

<p><strong>EJB 가 제공했던 엔터프라이즈 서비스에서 가장 매력적인 것은 바로 선언적 트랜잭션이다.</strong> <strong>선언적 트랜잭션 경계설정 기능을 이용하면 코드 내에서 직접 트랜잭션을 관리 하고 트랜잭션 정보를 파라미터로 넘겨서 사용하지 않아도 된다. 선언적 트랜잭션의 가장 큰 장점은 트랜잭션 스크립트 방식의 코드를 탈피할 수 있다는 것이다.</strong>
트랜잭션 스크립트란 하나의 트랜잭션 안에서 동작해야 하는 코드를 한 군데 모아서 만드는 방식이다. 보통 트랜잭션마다 하나의 메소드로 구성된다. 메소드의 앞부분에서 DB를 연결하고 트랜잭션을 시작히는 코드가 나오고， 이렇게 만들어진 트랜잭션 안에서 DB를 액세스히는 코드와 그 결과를 가지고 비즈니스 로직을 적용하는 코드가 뒤엉켜서 등장한다. 물론 트랜잭션 내의 일부 작업은 메소드를 분리해서 만들 수는 있지만， 그래도 같은 트랜잭션 안에서 동작함을 보장하려면 Connection과 같은 트랜잭션 정보가 담긴 파라미터를 계속 물고 다녀야 한다. 트랜잭션 스크립트 방식의 코드에는 중복이 자주 발생한다. 지주 사용되는 DB 액세스 로직이 여러 트랜잭션 스크립트 안에 중복돼서 등장하기 쉽기 때문이다. <strong>비즈니스 로직과 데이터 액세스 로직이 한데 코드에 섞여 있는 문제는 말할 것도 없다.</strong>
트랜잭션 스크립트 코드에 DAO 패턴을 적용해서 데이터 액세스 로직을 분리하는 시도를 해볼 수 있겠지만， 트랜잭션을 명시적으로 시작하고 종료하는 경계 설정코드가 비즈니스 로직 코드에 함께 등장하는 것과 매번 트랜잭션 정보를 메소드 따라미터로 넘기는 불편은 여전히 남아 있다.
<strong>하지만 선언적 트랜잭션 경계설정을 사용하면 이런 문제를 모두 해결할 수 있다. 트랜잭션이 시작되고 종료되는 지점은 별도의 설정을 통해 결정된다.</strong> 또 작은 단위로 분리되어 있는 데이터 액세스 로직과 비즈니 스 로직 컴포넌트와 메소드를 조합해서 하나의 트랜잭션에서 동작하게 만드는 것도 간단하다. 선언적 트랜잭션이 제공히는 트랜 잭션 전파 기능 덕분이다. 의미 있는 작은 단위로 만들어진 오브젝트와 메소드를 적절한 순서대로 조합해서 호출하기만 하면 코드의 중복 없이 다양한 트랜잭션 안에서 동작 하는 코드를 만들 수 있다. A, B, C 라는 세 개의 오브젝트 또는 메소드가 있다고 하자.</p>

<p>A나 B 나 C 가 그 자체로 독립적인 트랜잭션으로 동작하게 하려면 A, B, C를 각각 트랜 잭션 경계로 지정해주면 된다 A가 시작될 때 트랜잭션이 시작되고 A의 메소드를 종료할 때 트랜잭션이 함께 종료된다. 그런데 A-B, A-C, B-C ， A-B-C와 같은 구성으로 트랜잭션을 만들고 싶을 수도 있다. 이때도 A-B 의 코드를 하나로 묶어서 새로운 트랜잭션 스크립트를 만들 필요는 없다.<strong>A 에서 B 의 코드를 호출하게 하고 각각의 트랜잭션 전파 속성을 ‘트랜잭션 필요(REQUIRED)’로 해주면 된다</strong>. 이렇게 해두면 A 에서 시작된 트랜잭션에 B 의 코드가 자동으로 참여하게 된다. 어떤 조합으로 만들어도 상관없다.</p>

<p>선언적 트랜잭션 경계설정을 사용하면， 결국 코드의 중복을 제거하고 작은 단위의 컴포넌트로 쪼개서 개발한 후에 이를 조합해서 쓸 수 있다. 다 다양한 로직이 복잡하게 결합돼서 하나의 업무를 처리하는 엔터프라이즈 시스뱀의 요구조건을 가장 잘 충족시켜줄 기술이다.
EJB 의 이런 선언적 트랜잭션 기능을 복잡한 환경이나 구현조건 없이 평범한 POJO로 만든 코드에 적용하게 해주는 것이 바로 스프링이다. 스프링은 EJB 등에서나 제공 되던 엔터프라이즈 서비스를 POJO 의 장점을 유지한 채로 사용할 수 있게 만들어준다.
DI 로 대표되는， 스프링의 객체지향 설계 원칙에 충실한 핵심 기술이 이를 가능하게 만들어준다.
<strong>스프링의 선언적 트랜잭션은 매우 매력적인 기능이다. JavaEE 서버에서 동작히는 엔티티빈이나 JPA로 만든 컴포넌트에 JTA를 이용한 글로벌 트랜잭션을 적용해야만 가능했던 고급 기능을 간단한 톰켓 서버에서 동작히는 가벼운 애플리케이션에도 적용해 주기 때문이다.</strong> <strong>또한 JDBC. JPA 하이버네이트 iBatis. JDO 등 스프링이 지원하는 대부분의 데이터 액세스 기술과 JMS 메시징 서비스， CCI 처럼 트랜잭션 개념을 지원한 서비스에도 적용할 수 있다. 원한다면 언제든지 WAS 가 제공하는 JTA와 연결해서 글로벌 트랜잭션 서비스의 혜택을 받을 수도 있다.</strong>
스프링을 처음 사용히는 개발자가 가장 매력을 느끼는 기능이 이 선언적 트랙잭션 기능이라고 한다. 스프링의 그 밖의 장점은 잘 모르더라도 선언적 트랜잭션 기능이 절실히 펼요해서 스프링을 계속 사용하겠다는 개발자도 적지 않다. 그만큼 효과적인 엔터 프라이즈 개발애 목 필요한 중요한 기능이다.
이 절에서는 스프링이 제공동}는 선언적 트랜잭션 경계설정의 방법과 종류를 자세히 알아보겠다. 트랜잭션 예제 코드는 springbook.learningtest.spring.tx 패키지에서 찾을수있다.</p>

<h2 id="261-트랜잭션-추상화와-동기화">2.6.1 트랜잭션 추상화와 동기화</h2>

<p>스프링이 제공히는 트랜잭션 서비스는 트랜잭션 추상화와 트랜잭션 동기화 두 가지로 생각해볼수있다.
트랜잭션 서비스의 종류는 데이터 액세스 기술보다 더 다양하다. <strong>트랜잭션 서비스는 데이터 액세스 기술은 변하지 않더라도 환경에 따라 바뀔 수 있기 때 문이다.</strong> 또， 스프링 없이 선언적 트랜잭션을 이용하려면 특정 기술과 서버 플랫폼， 특정 트랜잭션 서비스에 종속될 수밖에 없다. 스프링은 데이터 액세스 기술과 트랜잭션 서비스 사이의 종속성을 제거하고 스프링이 제공하는 트랜잭션 추상 계층을 이용해서 트랜잭션 기능을 활용하 도록 만들어준다. 이를 통해 트랜잭션 서비스의 종류나 환경이 바뀌더라도 트랜잭션을 사용하는 코드는 그대로 유지할 수 있는 유연성을 얻을 수 있다.
스프링의 트랜잭션 동기화는 트랜잭션을 일정 범위 안에서 유지해주고， 어디서든 자유롭게 접근할 수 있게 만들어준다. 트랜잭션 동기화는 트랜잭션 추상화， 데이터 액세스 기술을 위한 랩플릿과 더불어 선언적 트랜잭션을 가능하게 해주는 핵심기능이다.
스프링의 서비스추상화와동기회에 관한동작원리와특정은 Vol.l 에서 자세히 다뤘 으므로， 여<strong>기서는 데이터 액세스 기술에 따라 사용할 수 있는 트랜잭션 추상화 클래스의 종류와 사용 방법을 알아보겠다.</strong></p>

<h3 id="platformtransactionmanager">PlatformTransactionManager</h3>

<p>스프링 트랜잭션 추상화의 핵심 인터페이스는 PlatformTransactionManager 다. 모든 스프링의 트랜잭션 기능과 코드는 이 인터페이스를 통해서 로우레벨의 트랜잭션 서비스를 이용할 수 있다. PlatformTransactionManager 인터페이스는 리스트 2-42와 같이세 개의 메소드를 갖고 있다.</p>

<p>​</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">PlatformTransactionManager</span> <span class="o">{</span> 
    <span class="nc">TransactionStatus</span> <span class="nf">getTransaction</span><span class="o">(</span><span class="nc">TransactionDefinition</span> <span class="n">definition</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">TransactionException</span><span class="o">;</span>
	<span class="kt">void</span> <span class="nf">commit</span><span class="o">(</span><span class="nc">TransactionStatus</span> <span class="n">status</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">TransactionException</span><span class="o">;</span>
	<span class="kt">void</span> <span class="nf">rollback</span><span class="o">(</span><span class="nc">TransactionStatus</span> <span class="n">status</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">TransactionException</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>리스트 2-42 PlatformTransactionManager 인터페이스</p>

<p>PlatformTransactionManager는 트랜잭션 경계를 지정히는 데 사용한다. 트랜잭션이 어디서 시작하고 종료하는지 종료할 때 정상 종료(커밋) 인지 비정상 종료(롤백) 인지를 결정히는 것이다. 스프링에서는 시작과 종료를 트랜잭션 전파 기법을 이용해 자유롭게 조합하고 확장할 수 있다. 그래서 트랜잭션을 시작한다는 의미의 begin() 과 같은 메소드 대신 적절한 트랜잭션을 가져온다는 의미의 getTransaction( ) 메소드를 사용한다.
<strong>getTransaction() 은 트랜잭션 속성에 따라서 새로 시작하거나 진행 중인 트랜잭션에 참여하거나， 진행 중인 트랜잭션을 무시하고 새로운 트랜잭션을 만드는 식으로 상황에 따라다르게동작한다.</strong>
TransactionDefinition 은 트랜잭션의 네 가지 속성을 나타내는 인터페이스다.
<strong>TransactionStatus 는 현재 참여하고 있는 트랜잭션의 ID와 구분정보를 담고 있다. 커빗 또는 롤백 시에 이 TransactionStatus 를 사용한다.</strong>
<strong>선언적 트랜잭션 방식을 시용할 것이라면 사실 PlatformTransactionManager 인터 페이스의 시용 방법은 몰라도 상관없다</strong>. 다만 이 추상화된 인터페이스를 구현한 트랜 잭션 서비스 클래스의 종류를 알고 적절한 것을 선택해서 빈으로 둥록하는 방법만 알고 있으면 된다. 가끔 태스트에서 트랜잭션을 제어해가면서 태스트 코드를 만들어야 할 경우가 있는데， 그때는 PlatformTransactionManager를 직접 이용해야 할 수도 있다.</p>

<h3 id="트랜잭션매니저의종류">트랜잭션매니저의종류</h3>

<p>스프링이 제공하는 PlatformTransactionManager 구현 클래스를 살펴보자.</p>

<ul>
  <li>
    <p>DataSourceTransactionManager</p>

    <p><strong>Connection 의 트랜잭션 API를 이용해서 트랜잭션을 관리해주는 트랜잭션 매니저다.</strong></p>

    <p><strong>이 트랜잭션 매니저를 사용하려면 트랜잭션을 적용할 DataSource 가 스프링의 빈으로 등록돼야 한다.</strong></p>

    <p>JDBC API를 이용해서 트랜잭션을 관리하는 데이터 액세스 기술인 JDBC와 iBatis SqlMap으로 만든 DAO 에 적용할 수 있다.
<strong>DataSourceTransactionManager를 빈으로 등록할 때는 리스트 2-43 과 같이 트랜잭션을 적용할 DAO 가 사용하는 것과 통일한 DataSource를 빈으로 제공해줘야 한다.</strong></p>
  </li>
</ul>

<p>리스트 2-43 DataSourceTransactionManager 빈 등록</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"memberDao"</span> <span class="na">class=</span><span class="s">" . .. MemberJdbcDao"</span><span class="nt">&gt;</span> <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"dataSource"</span> <span class="na">ref=</span><span class="s">'dataSource'</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/bean&gt;</span>
<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"dataSource"</span> <span class="na">class=</span><span class="s">"org . .. SimpleDriverDataSource"</span> <span class="nt">&gt;</span>
<span class="nt">&lt;/bean&gt;</span>
<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"transactionManager"</span> <span class="na">class=</span><span class="s">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span><span class="nt">&gt;</span>
<span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"dataSource"</span> <span class="na">ref=</span><span class="s">"dataSource"</span><span class="nt">&gt;&lt;/property&gt;</span>
<span class="nt">&lt;/bean&gt;</span>
</code></pre></div></div>

<p>DataSourceTransactionManager 가 사용할 DataSource는 getConnection() 이 호출될 때마다 매번 새로운 Connection을 돌려줘야 한다. ThreadLocal 등을 이용해 트랜잭션을 저장해두고 돌려주는 특별한 기능을 가진 DataSource를 사용하면 안 된다.</p>

<p>애플리케이션 코드에서 트랜잭션 매니저가 관리하는 Connection 을 가져오려면 DataSource의 getConnection() 대신 스프링 <strong>DataSourceUtils 클래스의 스태틱 메소드인 getConnection(DataSource) 를 사용해야 한다.</strong></p>

<p>JdbcTemplate의 내부 에서 트랜잭션 매니저로부터 현재 진행 중인 트랜잭션을 가져올 때 바로 이 메소 드를 사용한다. 대개는 JdbcTemplate을 이용해서 DAO를 작성하면 되기 때문에 DataSourceUtils.getConnection() 으로 Connection을 직접 가져와 사용할 일은 많지 않다.</p>

<p>JdbcTemplate을 사용할 수 없는 코드이거나 DAO 밖에서 현재 Connection을 가져와 참조해야 할 때만 주의해서 사용하자.
JdbcTemplate을 사용하지 않는 레거시 DAO 코드를 스프링의 트랜잭션 매니저와 연동해서 동작하게 하려면 어떻게 해야 할까?</p>

<p>두 가지 방법이 있다.</p>

<ul>
  <li>
    <p>첫 번째 방법은 레거시 DAO 코드의 Connection을 가져오는 코드를 모두 DataSourceUtils.getConnection() 으로 변경하는 것이다.
두 번째 방법은 레거시 코드가 DataSource 의 getConnection() 을 직접 호출해서 Connection을 가져오는 경우에 적용할 수 있다.</p>

    <p>리스트 2-44와 같이 DAO와 DataSource 사이에 TransactionAwareDataSourceProxy를 넣어서 레거시 DAO 코드에서 getConnection() 을 호출해도 매번 새로운 Connection 이 생성되지 않게 할수 있다.</p>

    <p>대신 현재 트랜잭션 매니저가 관리하고 있는, 진행 중인 트랜잭션이 담긴 Connection 을 돌려주게 만들 수 있다.</p>

    <p><strong>DAO 에서는 마치 매번 새로운 Connection을 DataSource 에서 가져오는 것 같지만 실제로는 트랜잭션이 진행 중인 동안에는 매번 같은 Connection을 받게 된다.</strong></p>

    <p>자세한 내용은 TransactionAwareDataSourceProxy 의API 문서를 참고하자.</p>
  </li>
</ul>

<p>리스트 2-44 레거시 DAO를 위한  빈</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"dataSource"</span> <span class="na">class=</span> <span class="s">"org.springframework.jdbc.datasource.TransactionAwareDataSourceProxy"</span><span class="err">)</span> <span class="err">(property</span> <span class="na">name=</span><span class="s">"targetDataSource"</span> <span class="na">ref=</span><span class="s">"targetDataSource"</span> <span class="nt">/&gt;</span> 
<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"targetDataSource"</span> <span class="na">class=</span><span class="s">org</span> <span class="err">...</span> <span class="err">SimpleDriverDataSource</span><span class="nt">&gt;</span>
<span class="nt">&lt;/bean&gt;</span>
</code></pre></div></div>

<p>이렇게 DataSourceTransactionManager를 시용하는 여러 가지 방법이 있지만， JdbcTemplate 이나 SqlMapClientTemplate 처럼 내부에서 Connection과 트랜잭션 작업을 알아서 처리해주는 댐플릿을 시용하는 방법이 제일 좋다.
서버가 제공하는 DataSource와 트랜잭션 서비스를 JNDI로 접근해 사용해야 한다면 DataSourceTransactionManager는 사용할 수 없다. 그때는 JTA를 지원하는 스프 링의 트랜잭션 매니저를 사용해야 한다. 하나 이상의 DB 에 대한 작업을 트랜잭션으로 묶어야 동f는 경우에도 DataSourceTransactionManager를 시용하는 대신 JTA를 써야한다 .</p>

<ul>
  <li>
    <p>JpaTransactionManager</p>

    <p>jPA를 이용하는 DAO 에는 JpaTransactionManager를 사용한다. 물론 JTA로 트랜 잭션 서비스를 이용하는 경우에는 JpaTransactionManager 가 필요 없다.
리스트 2 -45 에서 볼 수 있듯이 JpaTransactionManager 에는 LocalContainerEntityManagerFactoryBean 타입의 빈을 프로퍼티로 등록해줘야 한다.</p>
  </li>
</ul>

<p>리스트 2-45 JpaTransactionManager 설정</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"dataSource1"</span> <span class="na">class=</span><span class="s">""</span><span class="nt">&gt;</span>..<span class="nt">&lt;/bean&gt;</span>
<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"dataSource2"</span> <span class="na">class=</span><span class="s">""</span><span class="nt">&gt;</span>..<span class="nt">&lt;/bean&gt;</span>
<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"memberDao1"</span> <span class="na">class=</span><span class="s">"...MemberDao"</span><span class="nt">&gt;</span>
<span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"dataSource"</span> <span class="na">ref=</span><span class="s">"dataSource1"</span><span class="nt">&gt;&lt;/property&gt;</span>
<span class="nt">&lt;/bean&gt;</span>
<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"memberDao2"</span> <span class="na">class=</span><span class="s">"...MemberDao"</span><span class="nt">&gt;</span>
<span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"dataSource"</span> <span class="na">ref=</span><span class="s">"dataSource2"</span><span class="nt">&gt;&lt;/property&gt;</span>
<span class="nt">&lt;/bean&gt;</span>

<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"transactionManager1"</span> <span class="na">class=</span><span class="s">"...DataSourceTransactionManager"</span><span class="nt">&gt;</span>
<span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"dataSource"</span> <span class="na">ref=</span><span class="s">"dataSource1"</span>
<span class="err">&lt;/bean</span><span class="nt">&gt;</span>
    <span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"transactionManager2"</span> <span class="na">class=</span><span class="s">"...DataSourceTransactionManager"</span><span class="nt">&gt;</span>
<span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"dataSource"</span> <span class="na">ref=</span><span class="s">"dataSource2"</span>
<span class="err">&lt;/bean</span><span class="nt">&gt;</span>
</code></pre></div></div>

<p>JpaTransactionManager 를 사용할 때는 JPA 의 persistence. xml 파일의<persistence-unit> 태그 내의 transaction-type을 JTA로 설정해두지 않도록 한다.</persistence-unit></p>

<p>스프링이 제공하는 JpaTransactionManager를 사용할 것이므로 transactiontype 애트리뷰트는 생략한다.
JpaTransactionManager 는 DataSourceTransactionManager 가 제공 하는 DataSource 레벨의 트랜잭션 관리 기능을 동시에 제공한다. 따라서 JpaTransactionManager를 사용하면서 동시에 트랜잭션이 적용된 JDBC DAO를 사용할수도있다.</p>

<ul>
  <li>
    <p>HibernateTransactionManager</p>

    <p>하이버네이트 DAO 에는 HibernateTransactionManager 를 사용한다. 리스트 2-46 과 같이 SessionFactory 타입의 빈을 프로퍼티로 넣어주면 된다.
JpaTransactionManager와 마찬가지로 DataSource 레벨의 트랜잭션 기능도 동시에 제공한다.</p>
  </li>
</ul>

<p>리스트 2-46 하이버네이트 트랜잭션 매니저</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"sessionFactory"</span> <span class="na">class=</span> <span class="s">"org.springframework.orm.hibernate3.annotation.AnnotationSessionFactoryBean"</span><span class="nt">&gt;&lt;/bean&gt;</span>
<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">'transactionManager'</span> <span class="na">class=</span><span class="s">'org .springframework.orm.hibernate3.HibernateTransactionManager'</span><span class="nt">&gt;</span>
<span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">sessionFactory.</span> <span class="na">ref=</span><span class="s">'sessionFactory'</span> <span class="nt">/&gt;</span> 
<span class="nt">&lt;/bean&gt;</span>
</code></pre></div></div>

<ul>
  <li>
    <p>JmsTransactionManager, CciTransactionManager</p>

    <p>스프링은 DB뿐 아니라 트랜잭션이 지원되는 JMS 와 CCI를 위해서도 트랜잭션 매니저를 제공한다. JMS와 CCI 에 대해서는 이 책에서 다루지 않는다. 관심이 있다면 스프링 레퍼런스 문서와 API 문서를 참고해보기 바란다.</p>
  </li>
  <li>
    <p>JtaTransactionManager</p>

    <p>하나 이상의 DB 또는 트랜잭션 리소스가 참여하는 글로벌 트랜잭션을 적용하려면 JTA를 이용해야 한다. JTA는 여러 개의 트랜잭션 리소스(DB. JMS 등)에 대한 작업을 하나의 트랜잭션으로 묶을 수 있고， 여러 대의 서버에 분산되어 진행되는 작업을 트랜잭션으로 연결해주기도 한다.</p>

    <p>JTA 트랜잭션을 이용하려면 트랜잭션 서비스를 제공하는 WAS를 이용하거나 독립 JTA 서비스를 제공해주는 프레임워크를 사용해야 한다.
서버가 제공하는 JTA 트랜잭션 매니저를 스프링에서 이용히는 방법은 간단하다.
디음과 같이 JtaTransactionManager를 등록해주기만 하면 된다.</p>

    <div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"transactionManager"</span> <span class="na">class=</span><span class="s">"org.springframework.transaction.jta.JtaTransactionManager"</span><span class="nt">&gt;</span>
<span class="nt">&lt;/bean&gt;</span>
</code></pre></div>    </div>
  </li>
</ul>

<p>프로퍼티 설정 없이 JtaTransactionManager를 등록하면 디폴트로 등록된 JNDI 이름을 통해 서버의 TransactionManager와 UserTransaction을 찾는다.
디폴트로 사용하는 UserTransaction 의 JNDI 이름은 java:comp/UserTransaction 이고 
TransactionManager는 java :comp/TransactionManager,java :appserver / TransactionManager, java: pm / TransactionManager, java: / TransactionManager 네 가지다.
만약 디폴트 이름과 다르게 서버에 설정되어 있다면 transactionManagerName과 userTransactionName 프로퍼티 를 통해 이름을 지정해주면 된다.
JtaTransactionManager 를 사용할 때는 DataSource 도 서버에 등록된 XA DataSource를 사용해야 한다.</p>

<p>JNDI를 이용해 서버의 XA DataSource를 다음과 같이 빈으로 등록하고 DAO 나 EntityManagerFactory, SessionFactory 등에서 사용 하게해야한다.</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;jee:jndi-lookup</span> <span class="na">id=</span><span class="s">"dataSource"</span> <span class="na">jndi-name=</span><span class="s">"jdbc/myXADataSource"</span><span class="nt">/&gt;</span>
</code></pre></div></div>

<p>DB 가 하나라면 트랜잭션 매니저 또한 하나만 등록돼야 한다. DB 가 여러 개라도 JTA를 이용해 글로벌 트랜잭션을 적용할 것이라면 JtaTransactionManager 하나만 등록돼야 한다. 
단， 두 개 이상의 DB를 완전히 독립적으로 사용히는 경우라면 두 개 이상의 트랜잭션 매니저를 등록할 수는 있다. 
DB 가 두 개라면 DataSource도 두 개가 등록 돼야 한다. 또한 DataSource를 사용히는 DAO도 두 개가 등록돼야 한다.
DAO는 어떤 식으로든 DataSource 빈과 연결되기 때문이다. 만약 테이블 구조가 같은 두 개의 DB를 중복해서 사용하는 경우라면 DAO 코드가 달라지지 않을 것이다. 
이때는 DAO 클래스는 하나만 만들고 DAO 빈 두 개를 등록하면 된다.</p>

<p>리스트 2-47은 두 개의 DB 에 대해 같은 기능을 가진 DAO를 독립적으로 등록한 설정의 예다 .DAO는 하나의 클래스를 가지고 두 개의 다른 빈으로 등록해서 사용할수 있지만 DataSource와 PlatformTransactionManager는 DB 별로 하나씩 등록해줘야 한다.</p>

<p>리스트 2-47 두 개의 DB에 모두 사용되는 DAO 등록 방법</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"dataSource1"</span> <span class="na">class=</span><span class="s">""</span><span class="nt">&gt;</span>..<span class="nt">&lt;/bean&gt;</span>
<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"dataSource2"</span> <span class="na">class=</span><span class="s">""</span><span class="nt">&gt;</span>..<span class="nt">&lt;/bean&gt;</span>
<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"memberDao1"</span> <span class="na">class=</span><span class="s">"...MemberDao"</span><span class="nt">&gt;</span>
<span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"dataSource"</span> <span class="na">ref=</span><span class="s">"dataSource1"</span><span class="nt">&gt;&lt;/property&gt;</span>
<span class="nt">&lt;/bean&gt;</span>
<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"memberDao2"</span> <span class="na">class=</span><span class="s">"...MemberDao"</span><span class="nt">&gt;</span>
<span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"dataSource"</span> <span class="na">ref=</span><span class="s">"dataSource2"</span><span class="nt">&gt;&lt;/property&gt;</span>
<span class="nt">&lt;/bean&gt;</span>

<span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"transactionManager1"</span> <span class="na">class=</span><span class="s">"...DataSourceTransactionManager"</span><span class="nt">&gt;</span>
<span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"dataSource"</span> <span class="na">ref=</span><span class="s">"dataSource1"</span>
<span class="err">&lt;/bean</span><span class="nt">&gt;</span>
    <span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"transactionManager2"</span> <span class="na">class=</span><span class="s">"...DataSourceTransactionManager"</span><span class="nt">&gt;</span>
<span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"dataSource"</span> <span class="na">ref=</span><span class="s">"dataSource2"</span>
<span class="err">&lt;/bean</span><span class="nt">&gt;</span>
</code></pre></div></div>

<h2 id="262-트랜잭션-경계설정-전략">2.6.2 트랜잭션 경계설정 전략</h2>

<p>트랜잭션 매니저를 빈으로 등록하고 JdbcTemplate 이나 스프링 트랜잭션과 연동되는 EntityManager 또는 Session을 사용하도록 DAO 코드를 작성했다면 다음은 트랜잭션의 경계를 설정하는 작업을 할 차례다.
트랜잭션의 시작과 종료가 되는 경계는 보통 서비스 계층 오브젝트의 메소드다. 
비즈니스 로직이 거의 없어서 서비스 계층과 데이터 액세스 계층을 통합했다면, 통합된 계층의 메소드가 트랜잭션 경계가 될 것이다.</p>

<p><strong>트랜잭션 경계를 설정하는 방법은 코드에 의한 프로그램적인 방법과， AOP를 이용한 선언적인 방법으로 구분할 수 있다.</strong> 
<strong>전자는 트랜잭션을 다루는 코드를 직접 만들고， 후자는 AOP를 이용해 기존 코드에 트랜잭션 경계설정 기능을 부여해준다.</strong></p>

<h3 id="코드에-의한-트랜잭션-경계설정">코드에 의한 트랜잭션 경계설정</h3>

<p>스프링의 트랜잭션 매니저는 모두 PlatformTransactionManager를 구현하고 있다. 따라서 이 인터페이스로 현재 등록되어 있는 트랜잭션 매니저 빈을 가져올 수 있다면 트랜잭션 매니저의 종류에 상관없이 동일한 방식으로 트랜잭션을 제어하는 코드를 만들수 있다.</p>

<p>트랜잭션을 처리하기 위해 PlatformTransactionManager 의 메소드를 직접 사용해도 되지만 try/catch 블록을 써야 히는 번거로움이 발생한다.</p>

<p>트랜잭션 안에서 작업 중에 예외가 발생한 경우에는 트랜잭션을 롤백해주도록 만들어야 하기 때문이다. 
그래서 PlatformTransactionManager 의 메소드를 직접 시용하는 대신 댐플릿/콜백 방식의 TransactionTemplate을 이용하면 편리하다.</p>

<p>리스트 2-48 은 코드에 의해 관리되는 트랜잭션 을 적용한 예다.</p>

<p>MemberDao 는JDBC , iBatis , lPA , 하이버네이트 중 어떤 것을 이용해도 된다. 또， 트랜잭션 매니저 빈도 DAO 에서 사용한 기술과 호환만 된다면 DataSourceTransactionManager, JpaTransactionManager, HibernateTransactionManager, JtaTransactionManager 중어떤 것을 사용해도 된다. 
<strong>스프링 의 트랜잭션 서비스 추상화와 동기화 기법 덕분에 기술에서 독립적인 트랜잭션 코드를 만들 수 있다.</strong></p>

<p>리스트 2-48 코드를 이용한 트랜잭션 경계설정 방법</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MemberService</span> <span class="o">{</span>
    <span class="nd">@Autowired</span> <span class="kd">private</span> <span class="nc">MemberDao</span> <span class="n">memberDao</span><span class="o">;</span>
	<span class="kd">private</span> <span class="nc">TransactionTemplate</span> <span class="n">transactionTemplate</span><span class="o">;</span>

	<span class="nd">@Autowired</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">init</span> <span class="o">(</span><span class="nc">PlatformTransactionManager</span> <span class="n">transac</span> <span class="n">tionManager</span> <span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span> <span class="o">.</span><span class="na">transactionTemplate</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TransactionTemplate</span> <span class="o">(</span><span class="n">transactionManager</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addMembers</span><span class="o">(</span><span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">members</span><span class="o">)</span> <span class="o">{</span> 
        <span class="k">this</span><span class="o">.</span><span class="na">transactionTemplate</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="k">new</span> <span class="nc">TransactionCallback</span> <span class="o">{</span> 
            <span class="kd">public</span> <span class="nc">Object</span> <span class="nf">dolnTransaction</span><span class="o">(</span><span class="nc">TransactionStatus</span> <span class="n">status</span><span class="o">)</span> <span class="o">{</span>
	            <span class="k">for</span><span class="o">(</span><span class="nc">Member</span> <span class="n">m</span> <span class="n">members</span><span class="o">)</span> <span class="o">{</span>
	                 <span class="n">memberDao</span> <span class="o">.</span><span class="na">addMember</span><span class="o">(</span><span class="n">m</span><span class="o">);</span>
                <span class="o">}</span>
				<span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
		<span class="o">}</span>
	<span class="o">)};</span>
<span class="o">)</span>
</code></pre></div></div>

<p>트랜잭션의 기본 속성을 변경하려면 TransactionTemplate 을 만들 때
TransactionDefinition 오브젝트를 만들어서 파라미터로 제공해주면 된다. 기본 속성을 사용한다면 위의 코드처럼 한 번 만들어두고 재사용할 수도 있다.
코드에 의한 트랜잭션 경계설정은 실제로는 많이 사용되지 않는다.</p>

<p>대개는 선언적 트랜잭션 방식으로 충분하기 때문이다. 
반면에 테스트 코드에서 의도적으로 트랜잭션을 만들고 종료시키거나 여러 번 트랜잭션을 거치는 상황을 만들어야 하는 경우에는 유용하다.
<strong>코드에 의한 트랜잭션 경계설정 방식을 애플리케이션 코드에 사용하지 않더라도 PlatformTransactionManager를 통한 트랜잭션 추상화에 대해서는 잘 이해하고 있어야 한다.</strong></p>

<p><strong>선언적 트랜잭션은 트랜잭션이 시작되고 적용되는 코드가 눈에 보이지 않기 때문에 자칫 실수하면 트랜잭션 적용과 관련된 찾기 힘든 버그를 만날 수 있다.</strong></p>

<p><strong>이때 트랜 잭션을 직접 코드에서 가져와 확인해보고 제어 해가면서 트랜잭션 적용 상태를 분석해 보면 어렵지 않게 문제의 원인을 찾을 수 있다.</strong></p>

<p><strong>어디서든 PlatformTransactionManager 를 DI 받아서 getTransaction() 해보면 현재 진행 중인 트랜잭션을 확인할 수 있다.</strong>
<strong>getTransaction() 이 돌려주는 TransactionStatus 오브젝트를 이용하면 현재 트랜잭션이 새로 시작된 것인지 기존 트랜잭션에 참여한 것인지 또는 트랜잭션이 종료된 것인지 확인할 수 있다.</strong></p>

<p>두 개의 DAO 또는 서비스 계층 코드가 같은 트랜잭션 안에서 동작 하고 있는지도 확인해볼 수 있다.</p>

<h3 id="선언적-트랜잭션-경계설정">선언적 트랜잭션 경계설정</h3>

<p>선언적 트랜잭션을 이용하면 코드에는 전혀 영향을 주지 않으면서 특정 메소드 실행 전후에 트랜잭션이 시작되고 종료되거나 기존 트랜잭션에 참여하도록 만들 수 있다. 
<strong>이를 위해서는 Vol.1 에서 살펴본 것처럼 데코레이터 패턴을 적용한 트랜잭션 프록시 빈을 사용해야 한다. 선언적 트랜잭션 경계설정은 트랜잭션 프록시 빈 덕분에 가능한 것이다.</strong>
<strong>트랜잭션은 대부분 성격이 비슷하기 때문에 적용 대상마다 일일이 선언해주기보다는 일괄적으로 선언히는 것이 펀리하다. 그래서 간단한 설정으로 특정 부가기능을 임의의 타깃 오브젝트에 부여해줄 수 있는 프록시 AOP를 주로 활용한다.</strong>
스프링에서 AOP를 적용하는 방법은 매우 다양하다. 굳이 선언적 트랜잭션의 동작 원리와 AOP를 자세히 알고 싶은 게 아니라면， 트랜잭션에 사용되는 AOP는 AOP 라기 보다는고유한트랜잭션설정 기능으로기억하고사용하는것이 편하다.</p>

<p><strong>AOP를 이용해 트랜잭션 기능을 부여하는 방법은 다양하지만 보통 다음의 두 가지 방법이 가장 많이 사용된다.</strong> 
<strong>이 두 가지 중 하나를 선택해서 사용하면 된다.</strong></p>

<ul>
  <li>
    <p>aop와 tx네임스페이스</p>

    <p><strong>스프링은 AOP 기능과 트랜잭션 설정을 위해 편리하게 사용할 수 있는 전용 태그를 제공한다. aop 스키마의 태그와 tx 스키마의 태그를 사용할 수 있다.</strong>
트랜잭션 경계설정이라는 부가기능을 AOP를 이용해 빈에게 적용하려면 두 가지 정보가 필요하다. AOP는 부가기능을 빈 오브젝트에게 적용하는 방법이다. <strong>따라서 어떤 부가기능을 사용할지 결정해야 한다. AOP 용어로 하자면 어드바이스가 있어야 한다.</strong></p>

    <p>트랜잭션 경계설정 부가기능이므로 트랜잭션 어드바이스가 필요하다. 그리고 어떤 대상에게 이 부가기능을 부여할지를 선정해야 한다. 
선정 대상을 결정하는 기준이 필요하다. <strong>어드바이스가 적용될 대상을 선정하는 것을 AOP 용어로 포인트컷이라고 한다.</strong> 따라서 트랜잭션 어드바이스와 포인트컷을 결합해서 하나의 AOP 모듈을 정의한다. 
<strong>하나의 AOP 모듈을 스프링에서는 어드바이저라고 부른다.</strong></p>

    <p>리스트 2-49 의 설정은 tx 스키마의 advice 태그를 이용해서 트랜잭션 부가기 능을 담은 트랜잭션 어드바이스를 정의한 것이다. 트랜잭션 속성은 원한다면 메소드 단위로 다르게 지정할 수 있다. 
여기서는 모든 메소드에 대해 기본 트랜잭션 속성을 지정하게 했다. 트랜잭션을 적용하려면 트랜잭션 매니저가 필요하다. 따라서
transaction-manager 애트리뷰트에 사용할 트랜잭션 매니저 빈의 아이디를 넣어줘야 한다. 
이 애트리뷰트의 디폴트 값은 transactionManager 이므로 트랜잭션 매니저 빈의 이름을 transactionManager로 선언했다면 생략할 수 있다.</p>
  </li>
</ul>

<p>리스트 2-49 트랜잭션 어드바이스</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;tx:advice</span> <span class="na">id=</span><span class="s">"txAdvice"</span> <span class="na">transaction-manager=</span><span class="s">"transactionManager"</span><span class="nt">&gt;</span> 
    <span class="nt">&lt;tx:attributes&gt;</span> <span class="nt">&lt;tx:method</span> <span class="na">name=</span><span class="s">"*"</span> <span class="nt">/&gt;</span> <span class="nt">&lt;/tx:attributes&gt;</span> 
<span class="nt">&lt;/tx:advice&gt;</span>
</code></pre></div></div>

<p>어드바이스가 준비됐으니 다음은 포인트컷을 정의할 차례다. 포인트컷은 AspectJ 표현식을 이용하는 것이 가장 간편하다.
aop 스키마의 pointcut 태그를 사용하면 다음과 같이 트랜잭션을 적용할 대상을 선정하는 포인트컷을 정의할 수 있다. 
이 포인트컷 표현식은 어떤 패키지에 있든 상관없이 이름이 MemberDao 인 인터페이스의 모든 메소드를 선정해준다. 
AOP 의 어드바이스가 적용되는 위치인 조인 포인트는 메소드 임을 기억하자. 
<strong>포인트컷은 원한다면 메소드 단위까지 상세하게 지정할 수 있다.</strong></p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;aop:pointcut</span> <span class="na">id=</span><span class="s">"txPointcut"</span> <span class="na">expression=</span> <span class="s">execution(</span> <span class="err">*</span> <span class="err">*</span> <span class="err">.</span> <span class="err">.</span> <span class="err">MemberDao</span> <span class="err">.</span> <span class="err">*(</span> <span class="err">..</span> <span class="err">))"</span> <span class="nt">/&gt;</span>
</code></pre></div></div>

<p><strong>또 포인트컷은 기본적으로 인터페이스에 적용된다는 사실도 기억해두자.</strong> 
<strong>스프링 AOP 의 동작원리인 JDK 다이내믹 프록시는 인터페이스를 이용해 프록시를 만들기 때문이다. 그런데 인터페이스 없이 클래스만으로 프록시를 만들 수도 있다.</strong> 
인터페이스 없이 등록된 빈에도 AOP를 적용할 수 있다. 하지만 트랜잭션 AOP 의 타깃은 가능한 한 인터페이스를 사용할 것을 권장한다.
리스트 2-50은 MemberDao 인터페이스의 예다. DAO를 사용하는 클라이언트가 이용할 수 있는 메소드만 정의되어 있다. 당연히 모든 메소드에 트랜잭션이 적용돼 야한다.</p>

<p>리스트 2-50 MemberDao 인터페이스</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">MemberDao</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="nc">Member</span> <span class="n">m</span><span class="o">);</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">members</span><span class="o">);</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">deleteAll</span><span class="o">();</span>
	<span class="kd">public</span> <span class="kt">long</span> <span class="nf">count</span><span class="o">();</span>
<span class="o">}</span>	
</code></pre></div></div>

<p>반면에 리스트 2-51 의 MemberDaolmpl 클래스를살펴보자.</p>

<p>리스트 2-51 MemberDao 구현 클래스</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MemberDaolmpl</span> <span class="kd">implements</span> <span class="nc">MemberDao</span> <span class="o">{</span>
    <span class="nc">SimpleJdbclnsert</span> <span class="n">insert</span><span class="o">;</span>
	<span class="nc">SimpleJdbcTemplate</span> <span class="n">jdbcTemplate</span><span class="o">;</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">setDataSource</span><span class="o">(</span><span class="nc">DataSource</span> <span class="n">dataSource</span><span class="o">)</span> <span class="o">(</span> 
        <span class="n">jdbcTemplate</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SimpleJdbcTemplate</span><span class="o">(</span><span class="n">dataSource</span><span class="o">);</span>
		<span class="n">insert</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SimpleJdbclnsert</span><span class="o">(</span><span class="n">dataSource</span><span class="o">()).</span><span class="na">withTableName</span><span class="o">(</span><span class="s">"member"</span><span class="o">);</span>	
	<span class="o">}</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="nc">Member</span> <span class="n">m</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span> <span class="kd">public</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="n">members</span><span class="o">)</span> <span class="o">{</span> <span class="o">.</span> <span class="o">..</span> <span class="o">}</span> 
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">deleteAll</span><span class="o">()</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span> <span class="kd">public</span> <span class="kt">long</span> <span class="nf">count</span><span class="o">()</span> <span class="o">{</span> <span class="o">.</span> <span class="o">.</span> <span class="o">.</span> <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><strong>특별한 방법을 써서 인터페이스 없이 이 클래스에 직접 트랜잭션 AOP 를 적용했다고 해보자.</strong> 
포인트컷에서는 *를 이용해 모든 메소드를 선정하게 했다. 문제는 add() , deleteAll() , count() 와 같은 트랜잭션이 필요한 메소드뿐 아니라 setDataSource() 처럼 트랜잭션과 전혀 상관없는 메소드도 포인트컷의 선정 대상에 들어간다는 점이다.</p>

<p>포인트컷 표현식은 이름 패턴을 이용해 대상을 선정하기 때문에 add() , deleteAll() , count() 는 포함시키고 setDataSource() 는 제외시키도록 표현 식을 만들 수 없다. 
<strong>따라서 트랜잭션이 필요한 DAO 의 공개된 메소드뿐 아니라 불필요한 수정자나 기타 DAO 내부에서 사용할 메소드까지 모두 트랜잭션이 적용되는 문제가 발생한다.</strong></p>

<p>물론 setDataSource() 가 호출되는 동안 트랜잭션이 시작됐다가 아무 일 없이 종료해도 기능에는 별문제 없을 것이다. 하지만 쓸데없는 트랜잭션 경계설정 작업을 수행하느라 그만큼 시간과 리소스를 소모하게 된다. 따라서 트랜잭션 AOP를 적용할 때는 가능한 한 인터페이스를 사용하자.</p>

<p>앞에서 예로 든 포인트컷은 DAO를 직접 트랜잭션 경계로 만들었는데， 사실 이방식은 비즈니스 로직이 특별히 없어서 서비스 계층을 생략하거나 DAO 에 통합해서 만드는 단순한 애플리케이션에서나 쓸 수 있는 방법이다. 일반적으로는 데이터 액세스 계층보다는 서비스 계층의 메소드가 트랜잭션 경계가 되는 것이 자연스럽다. 하나의 단위 비즈니스 로직은 하나의 트랜잭션 안에서 동작해야 하기 때문이다.</p>

<p>포인트컷까지 정의했다면 다음은 어드바이저를 정의할 차례다. 
어드바이저는 포인트컷과 어드바이스를 조합해서 하나의 AOP 모ebf을 정의해주는 것이다. 
어드바이저는 <aop:advisor>를 사용한다. 단  <aop:advisor> 나 <aop:pointcut>은 모두</aop:pointcut></aop:advisor></aop:advisor></p>
<aop:config> 의 내부에 정의해야 한다는 점에 주의하자. 따라서 포인트컷과 어드바 이저는 리스트 2-52와같이 <aop:config> 안에 넣어줘야한다.



리스트 2-52 어드바이저 정의

~~~xml
<aop:config>
    &lt;aop :pointcut id="txPointcut" expression="execution( * * . . MemberDao . *(. . ))" /&gt;
    <aop:advisor advice-ref="txAdvice" pointcut-ref="txPointcut" />
&lt;/aop:config)
~~~

어드바이저는 다른 빈이나 설정에서 참조할 일이 없으므로 id를 넣지 않는다.
&lt;tx:advice.로 정의한 어드바이스의 아이디와 <aop:pointcut>으로 정의한 포인트컷 아이디를 참조 애트리뷰트에 넣어줘야 한다.
**포인트컷이나 어드바이스가 아이디가 있다는 건 어드바이저를 여러 개 만들어서 다양한조합을할수도 있다뜻이다.** 동일한포인트컷 대상에 여러 종류의 어드바 이스를 적용한다거나 같은 어드바이스를 여러 포인트컷을 이용해서 다양한 대상에 적용할수가있다.

포인트컷이 하나의 어드바이저에만 쓰 인다면，리스트 2-53 과 같이 포인트컷 표현식을 아예 (aop:advisor&gt; 에 넣고 포인트컷 정의를 생략할 수 있다. 이때는 pointcut- ref 대신 pointcut을 시용한다.



리스트 2-53 포인트컷을 내장한 어드바이저

~~~xml
&lt;aop: config&gt;
    <aop:advisor advice-ref="txAdvice" pointcut="execution( * * .. MemberDao. *(. . )) " /> 
 &lt;/aop: config&gt;
~~~

AOP 설정 방법에 대한 자세한 내용은 5 장을 참고하자 .







- @Transactional

  트랜잭션 AOP를 적용하는 두 번째 방법은 @Transactional 애노태이션을 이용하는 것이다. 이 접근 방법에선 설정파일 에 명시적으로 포인트컷과 어드바이스를 정의하지 않는다. 
  
  **대신 트랜잭션이 적용될 타깃 인터페이스나 클래스，메소드 등에**
  **@Transactional 애노태이션을 부여해서 트랜잭션 대상으로 지정하고 트랜잭션의 속성을제공한다.**
  @Transactional 을 사용할 때 필요한 설정은 다음 한 줄뿐이다. &lt;tx: annotationdriven&gt; 태그는 등록된 빈 중에서 @Transactional 이 붙은 클래스나 인터페이스 또는 메소드를 찾아 트랜잭션 어드바이스를 적용해준다.
  
  리스트 2-54는 @Transactional 이 적용된 MemberDao 인터페이스의 예다.



리스트 2-54 @Transactional이 적용된 인터페이스

~~~java
@Transactional public interface MemberDao { 
    public void add(Member m);
	public void add(List<Member> members);
	public void deleteAll ();
	@Transactional(readOnly=true) public long count();
}
~~~

MemberDao 인터페이스를 구현한 클래스로 선언된 빈은 인터페이스 메소드에 한해서 트랜잭션이 적용된다. 
인터페이스에 붙은 @Transactional 선언은 인터페이스 내의 모든 메소드에 적용된다. 동시에 메소드 레벨에도 @Transactional 을 지정할 수있다. 
**이때는 메소드의 선언이 인터페이스의 선언에 우선한다.**
또는 리스트 2-55 와 같이 빈의 클래스에 직접 @Transactional 을 적용할 수도 있다.





리스트 2-55 @Transactional이 적용된 클래스

~~~java
@Transactional public class MemberDaolmpl extends JdbcDaoSupport implements MemberDao (
	public void add(Member m) { ... } 
    public void add(List&lt;Member) members) { ... }
	public void deleteAll() { .. . } @Transactional(readOnly=true) 
	public long count() { ... }
}
~~~

**메소드에 @Transactional 이 있으면 클래스 레벨의 @Transactional 선언보다 우선해서 적용된다.**

 클래스에 @Transactional 을 부여했을 때 트랜잭션이 적용되는 메소드는 프록시 방식과 인터페이스의 여부에 따라서 조금 달라진다.
 클래스의 @Transactional 은 인터페이스의 @Transactional 선언보다 우선한다. 
**따라서 @Transactional 을 적용하는 우선순위는 클래스의 메소드， 클래스， 인터페이스의 메소드， 인터페이스순이다.**
MemberDao 의 메소드별 트랜잭션 속성을 생각해보자. 인터페이스 레벨에 부여된 @Transactional 은 디폴트 트랜잭션 속성을 갖는다. 따라서 읽기전용 속성은 false다. 이 속성은 모든 인터페이스의 메소드에 적용된다. 하지만 count() 메소드는 메소드 레벨의 @Transactional 애노테이션을 가졌고 읽기전용 속성이 true로 되어 었으 므로， 인터페이스 레벨의 선언보다 우선해서 적용된다. 따라서 count() 메소드만 읽기전용이고， 그 밖의 메소드는 트랜잭션이 적용되기는 하나 읽기와 쓰기가 모두 가능한 트랜잭션으로 설정된다.

**@Transaction 적용 대상은 미리 결정하고 애플리케이션 안에서 통일하는 게 좋다.**

**타입 레벨과 메소드 레벨에 동시에 @Transactional 이 적용되는 경우는 종종 있다.**
**반면에 인터페이스와 클래스 양쪽에 불규칙하게 @Transactional 이 혼용되는 건 바람직하지못하다.**



**트랜잭션 경계설정 방법 두 가지는 각기 장단점이 있다. aop와 tx 스키마의 태그를 이용하는 방식은 선언이 조금 복잡해 보이지만 코드에는 전혀 영향을 주지 않고 일괄적 으로 트랜잭션을 적용하거나 변경할 수 었다는 장점이 있다. @Transactional 을 일일이 대상 인터페이스나 클래스 메소드에 부여하는 건 상대적으로 번거로운 작업이다. 반면에 @Transactional 은 aop와 tx 스키마의 태그를 사용하는 경우보다 훨씬 세밀한 설정 이가능하다.**
리스트 2-56은 get으로 시작하는 메소드에만 읽기전용 속성을 부여하고 나머지는 모두 디폴트 트랜잭션 속성을 사용하게 하는 트랜잭션 어드바이스 선언이다.



리스트 2-56 tx 스키마의 태그를 이용한 트랜잭션 속성 정의

~~~xml
<tx:advice id="txAdvice"> 
    <tx:attributes> <tx:method name="get*" read-only="true" />
        <tx:method name="*" /> 
    </tx:attributes> 
</tx:advice>
~~~

이 방법의 장점은 트랜잭션을 적용할 대상이 아무리 늘어나도 매번 번거롭게 트랜잭션 관련 설정을 변경해주거나 추가할 필요가 없다는 것이다. 추가할 클래스와 메소드가 포인트컷에 선정 대상이 되게만 하면 된다.
@Transactional 을 사용해서 위의 <tx:attributes>와 동일한 트랜잭션 선언을 하려면 리스트 2-57과 같이 많은 애노테이션이 필요하다. **@Transactional 으로는 간단히 get 으로 시작하는 메소드를 모두 읽기전용으로 만들 수 있는 방법이 없다.** 
get 으로 시작 히는 모든 메소드에 일일이 @Transactional 을 부여하고 속성을 넣어서 인터페이스 레벨에 부여된 @Transactional 속성보다 우선되게 해야 한다. 그러다 보니 애노테이션이 지저분하게 반복돼서 나오는 경우가 많아진다. 
물론 모든 트랜잭션 속성을 동일하게 디폴트로 가져가면 클래스나 인터페이스에 @Transactional 하나만 붙여주변 되니 간단해 진다.
하지만 본격적인 엔터프라이즈 시스템이라면 적어도 조회전용 메소드에 읽기전용 트랜잭션 속성을 부여해서 성능을 최적화하는것이     기본이다. 그렇다면 리스트 2-57과 같이 @Transactional 이 잔뜩 붙은 인터페이스나 클래스를 피할 수 없을 것이다.	



리스트 2-'51 @Transactional을 이용한 트랜잭션 속성 정의

~~~java
@Transactional public interface IssueDao {
    public void add(Issue i);
	public void add(List&lt;Issue) members);
	public void deleteAll();
	@Transactional(readOnly=true) public Issue get(int id);
	@Transactional(readOnly=true) public Issue getAll();
	@Transactional(readOnly=true) public Issue findIssuesByName(String name);
}
~~~



**이런 불편함에도 불구하고 @Transactional 은 매우 세밀하게 트랜잭션 속성을 부여 해야 할 경우라면 포인트컷과 트랜잭션 어드바이스로 한 번에 속성을 일괄 적용하는 것보다 유리하다.** 
특정 메소드만 격리수준을 변경한다거나 제한시간을 두는 등의 필요가 생겼을 때 aop와 tx 의 태그를 이용하려면 매우 복잡해진다. 단 하나의 메소드에 다른 트랜잭션 속성을 부여하기 위해 새로운 포인트컷 어드바이스 어드바이저를 지정하고 해당 메소드를 다른 포인트컷에서는 제외시켜야 하는 등의 복잡한 방법을 시용해야 한다.
**반면에 @Transactional 을 사용하면 간단히 해당 메소드의 @Transactional 애노테이션에 원하는속성을추가해주기만하면된다.**
**이 두 가지 방법은 각기 장단점이 있으므로 개발하려는 시스템의 트랜잭션 적용 전략과 필요에 잘 맞는 방법을 적절히 선택해서 사용하자.**







### 프록시 모드: 인터페이스와 클래스

스프링의 AOP는 기본적으로 다이내믹 프록시 기법을 이용해 동작한다. 다이내믹 프록시를 적용하려변 인터페이스가 있어야 한다. 인터페이스의 사용은 DI 에서도 가장 기본 원칙인 만큼문제 될 것은 없다. 
**하지만 특별한경우에 인터페이스 를구현하지 않은 클래스에 트랜잭션을 적용해야 할 수 있다.** 
인터페이스가 없는 레거시 클래스 코드를 그대로 가져다가 사용히는데 수정은 불가능하고 대신 스프링의 트랜잭션의 경계설정 대상 으로 만들고 싶다면 어떻게 해야 할까?

**이때는 스프링이 지원히는 클래스 프록시 모드를 사용하면 된다.** 
**스프링에서는 JDK 다이내믹 프록시 외에도 CGLib 라이브러리가 제공해주는 클래스 레벨의 프록시도 사용할수있다.**
**클래스 프록시는 aop/tx 스키마를 사용히는 경우와 @Transactional 을 사용하는 경우 모두 이용할수있**다.

- aop/tx 스키마 태그의 클래스 프록시 설정

  &lt;aop: c on fig&gt; 에는 디폴트로 false 값을 가진 proxy-target-class 애트리뷰트가 있다. 인터페이스 없이 클래스에 직접 프록시를 적용하려면 이 애트리뷰트를 true로 바꿔주변 된다. 리스트 2-58은 클래스 프록시를 이용한 트랜잭션 AOP 설정의 예다.
  
  

리스트 2• 58  스키마 태그에 설정한 클래스 프록시

~~~xml
<aop:config proxy-target-class="true">
       &lt;aop:pointcut id="txPointcut" expression=execution( * * . . MemberDaolmpl. *(. . ))" /&gt;
	<aop:advisor advice-ref="txAdvice" pointcut-ref="txPointcut" />
  &lt;/aop:config/&gt;
~~~

이때 포인트컷의 선정 대상도 클래스여야 한다. 이렇게 해주면 인터페이스 없이도 클래스에 직접 적용된다.



- @Transactional의 클래스 프록시 설정

  @Transactional 을 사용하는 경우에도 다음과 같이 proxy-target-class 애트리뷰트를 true로 바꿔주변 된다.

  <tx:annotation-driven proxy-target-class="true" />

  

- @Transactional은 클래스에 부여해야 한다.

  클래스 프록시는 일반적으로 인터페이스를 구현하지 않는 클래스에 주로 사용된다.
  하지만 원한다면 인터페이스가 있는 클래스에 클래스 프록시를 강제로 적용할 수도

  있다. 이때는 반드시 클래스에 @Transactional 을 부여해줘야 한다. 인터페이스에 붙인 @Transactional 애노태이션은 구현 클래스로 그 정보가 전달되지 않는다. 따라서 인터페이스에만 @Transactional 을 부여하고 클래스 프록시 모드로 바꾸면 트랜잭션이적용되지않는다.

  @Transactional 을 클래스에 부여하다고 해서 클래스 프록시가 적용되는 것은 아니다. **@Transactional 이 클래스에 있어도 타깃에 인터페이스가 있고 proxy-target-class 를 디폴트 값으로 그대로 뒀다면 인터페이스에 다이내믹 프록시가 적용되니 흔동하지 않도록 주의하자.**

  

- 클래스 프록시의 제약사항을 알아야 한다

  **클래스 프록시는 final 클래스에는 적용할 수 없다.** 클래스 프록시는 타깃 클래스를 상속해서 프록시를 만드는 방법을 시용하기 때문에 상속이 불기능한 final 클래스에 는적용되지않는다.
  **클래스 프록시를 적용하면 클래스의 생성자가 두 번 호출된다**. 상속을 통해 프록 시를 만들기 때문에 발생하는 현상인데 이 때문에 생성자에서 리소스를 할당하는것 같은 중요한 작업은 피하도록 해야 한다.

  

- 불필요한 메소드에 트랜잭션이 적용할 수 있다

  클래스 프록시 방식을 사용하면 클래스의 모든 public 메소드에 트랜잭션이 적용된다. 
  인터페이스를 이용히는 경우에는 인터페이스에 정의된 메소드로 트랜잭션 적용이 제한되지만 클래스에는그런 구분을 둘수 없다.
  
  **따라서 수정자 같은， 클라이언트가 사용하지는 않지만 public 으로 정의히는 메소드에도 트랜잭션이 적용되는 문제가 발생한다.** 
  물론 아무런 DB 작업이 없으므로 그냥 빈 트랜잭션이 시작됐다가 종료 되겠지만， 그만람 시간과 리소스에 낭비가 발생한다.
  
  

**클래스 프록시는 코드를 함부로 손댈 수 없는 레거시 코드나， 여타 제한 때문에 인터 페이스를 사용하지 못했을 경우에만 사용해야 한다.**
 **인터페이스를 만들기가 귀찮다고 클래스 프록시를 시용하는 것은 스프링의 개발철학에 맞지 않는다**. 
인터페이스를 사용 히는 이유는 단지 트랜잭션 AOP를 적용히는 것이 전부가 아니다.
 비록 스프링이 런타임 바이트코드 생성 기법을 지원히는 라이브러리를 이용해서 클래스에도 프록시를 적용하도록 해주고는 있지만 이 방법을 남용히는 건 바람직하지 않다.







### AOP 방식: 프록시와 AspectJ

스프링의 AOP는 기본적으로 프록시 방식이다. 
인터페이스를 이용핸 JDK 다이내믹 프록시든 클래스에 바로 프록시를 만드는 CGLib 이든, 모두 프록시 오브젝트를 타깃 오브젝트 앞에 두고 호출 과정을 가로채서 트랜잭션과 같은 부가적인 작업을 진행해준다.

스프링의 프록시 AOP 대신 AOP 전용 프레임워크인 AspectJ의 AOP를 시용할 수있다. 
AspectJ AOP는 스프링과 달리 프록시를 타깃 오브젝트 앞에 두지 않는다. 대신 타깃 오브젝트 자체를 조작해서 부가기능을 직접 넣는 방식이다. 마치 처음부터 타깃 오브젝트의 클래스에 부가기능을 가진 소스코드가 있었던 것처럼 만들어준다. 

AspectJ AOP는 그래서 매우 강력하다. 메소드 실행 지점만 조인 포인트로 사용할 수 있는 프록시 방식의 스프링 AOP 에서는 불가능한 다양한 조인 포인트와 고급 기능을 이용할 수있다. 
대신 별도의 빌드 과정이나 바이트코드 조작을 위한 로드타임 위버 설정과 같은 부가적인작업이 필요하다.

트랜잭션 AOP를 적용하기 위해 굳이 번거롭게 AspectJ를 사용할 필요는 없다.
AspectJ AOP를 스프링과 함께 애플리케이션 전반에 걸쳐서 사용하고 있는 경우라면 물론 고려해볼 수는 있다. 
또는 다음과 같은 프록시 AOP 의 제약사항을 극복하기 위해 서라면 도입을 검토해볼 필요가 있다.

Vo l. l 에서 자세히 살펴본 것처럼 프록시는 기능을 사용하려는 오브젝트인 클라이언트와 서비스를 제공하는 오브젝트인 타깃 오브젝트 사이에 데코레이터 패턴을 써서 투명하게 추가된다. 투명하다는 건 프록시가 추가되더라도 클라이언트와 타깃 오브젝트의 코드를 수정할 필요도 없고 기본 기능에도 영향을 주지 않는다는 뜻이다. 

그림 2-2 는 프록시가 적용되기 전과 후를 보여주고 있다. 프록시는 스프링 DI 의 도움을 받아서 클라이언트와 타깃 오브젝트 사이에 추가되고， 어드바이스가 제공해주는 부가적인 기능을 타깃 오브젝트의 메소드 호출 전후에 실행해준다.



''

![image-20210820231539343](C:\Users\ST\AppData\Roaming\Typora\typora-user-images\image-20210820231539343.png)

프록시가 적용되면 클라이언트는 프록시를 타깃 오브젝트라고 생각하고 프록시의 메소드를 호출한다. 프록시는 클라이언트로부터 요청을 받으면 타깃 오브젝트의 메소드로 위임해준다. 타깃 오브젝트에 위임히는 과정에서 부가작업을 추가할 수 있다. 
트랜잭션 AOP 에 의해 추가된 프록시라면 타깃 오브젝트 메소드 호출 전에 트랜잭션을 시작하고 호출 후에 트랜잭션을 커밋하거나 롤백해줄 것이다.

여기서 프록시는 클라이언트가 타깃 오브젝를 를 호출하는 과정에서만 동작한다는 점을 주목하자. 
**타깃 오브젝트의 메소드가 자기 자신의 다른 메 소드를 호출할 때 는 어떻게 될까? 이때 도 프록시가 동작할까? 그렇지 않다.**
이미 프록시를 거쳐서 타깃 오브 젝트까지 작업 이 진행됐으므로 타깃 오브젝트에 서 자신의 메 소드를 호출할 때 는 프록 시를 거치지 않는다. 
그림 2 -3 의 @은 클라이언트에서 프록시를 통해 들어온 호출이 다. 이때는 당연히 프록시의 기능이 동작한다. 하지만 @의 경우는 타깃 오브젝트 안에 서의 호출이 므로 프록시를 통하지 않고 직접 타깃 오브젝트의 메 소드로 호출이 일어 난다.

![2](C:\Users\ST\Downloads\2.PNG)

리스트 2-5 9는 트랜잭션 AOP가 적용된 서 비 스 계층 클래스의 코드다. add () 메 소드는 트랜잭션 전파 속성이 항상 새로운 트랜잭션을 만들어 시작하도록 REQUIRES_NEW로 되어 있다. 

따라서 다른 서비스 계층 오브젝트에서 트랜잭션이 시작된 후에 MemberService의 add () 메 소드가 호출되면 기존 트랜잭션은 잠시 중단되고 새로운 트랜잭션을 시작한다. MemberService 외의 오브젝트에 서 MemberS ervi ce 의 메 소드를 호출할 때는 항상 트랜잭션 프록시를 거쳐서 들어오기 때문에 메 소드에 설정해둔 트랜책션 속성이 정확히 적용된다.



리스트 2• 59 자신을 호출하는 타깃 오브젝트

~~~JAVA
@Transact ional public class MemberService {
    @Transactional(propagation=Propagation.REQUIRES_NEW) 
    public void add(Member m) { ... }
    
	public void complexWork() (
		this.add(new Member( .. . )) ;
	}
~~~

이번엔 클라이언트로부터 complexWork () 메 소드가 호출된 경우를 생각해 보자.

complexWork() 은 클래스 레벨 @Transactional 의 적용을 받으므로 complexWork() 이 호출되기 전에 프록시에서 트랜잭션을 시작할 것이다. 

**문제는 complexWork() 에서 add( )메소드를 호출할 때다.**

- 이때는 프록시를 지나서 이미 MemberService 빈의 오브젝트로 들어왔으므로 트랜잭션 프록시를 다시 거치지 않고 add () 메소드가 바로 실행된다.
- 그래서 이때는 add( ) 메소드의 트랜잭션 속성이 반영되지 못한다. add() 를 호출했음에도 새로운 트랜잭션이 생성되는 대신 complexWork() 에서 시작된 트랜잭션에 그냥 참여하게 될 뿐이다. 

결국 add( ) 메 소드에 별도의 트랜잭션 속성을 정의해놓아도 어떤 경로를 거쳐서 이 메소드가 호출되느냐에 따라서 해당 속성이 적용될 수도 있고 안 될 수도 있다.
 만약 complexWork() 이 트랜잭션이 아예 시작되지 않도록 설정된 메소드라면 add()가 호출되어도 트랜잭션이 시작되지 않은 채로 진행될 수밖에 없다.



타깃 오브젝트의 자기 호출에는 AOP 가 적용되지 않는다는 점이 프록시 AOP 의 한계다.
**이 문제를 해결해서 complexWork() 에서 같은 오브젝트의 add() 를 호출할 때도 트랜 잭션 프록시를 거치게 하고 싶다면 두 가지 방법을 고려해볼 수 있다.**

- AopContext.currentProxy()

  프록시 설정에서 현재 진행 중인 프록시를 노출하도록 설정해두면 스프링 API를 이용해서 현재 진행 중인 프록시를 가져올 수 있다. 이 기능을 이용하면 complexWork() **메소드에서 add() 를 바로 호출하는 대신 프록시를 통해 add() 메소드를 호출할 수있다. 사용 방법도 단순하고 효과적이지만 시용을 권장할 수는 없다.** 
  **스프링 A PI 가비즈니스 로직을 가진 POJO 클래스 코드에 등장한다는 문제와 더불어， 프록시를 통하지 않고는 아예 동작하지 않는 한심한 코드가 되기 때문이다.** 이 방법을 자세히 알고 싶다면 AopContext 클래스의 currentProxy() 메소드 API 문서를 참고하라.

- AspectJ AOP

  프록시 AOP 대신 AspectJ AOP를 사용하는 방법도 있다. 
  **AspectJ는 프록시 대신 클래스 바이트코드를 직접 변경해서 부가기능을 추가하기 때문에 타깃 오브젝트의 자기 호출 중에도 트랜잭션 부가기능이 잘 적용된다**. 
  굳이 자신의 메소드를 호출하는 경우에도 트랜잭션 속성이 정확히 적용되기를 원한다면 Aspec tJ를 사용하는 편이 좋다. 스프링에서 Aspec tJ를 사용하는 데 필요한 자세한 설정 방법은 5 장을 참고 하자.

@Transactional을 시용하는 경우에는 XML 설정에 다음 코드를 넣어주면 프록시 대신 AspectJ를 시용해 트랜잭션을 적용하게 할 수 있다. <tx:annotation-driven> 의 mode 애트리뷰트는 디폴트 값으로 proxy를 갖고 있다. 이 값을 apsectJ 로 변경해주면 된다.

&lt;tx :annotation-driven mode=‘ aspectj'/)

Aspec tJ를 시용해 트랜잭션을 적용할 때는 앞에서 설명한 것처 럼 @Transctional 을클래스 레벨과 클래스 메소드 레벨에 부여해야 한다는 점을 주의하자. AspectJ코드를 사‘용하면서 인터페이스에만 @Transactional 을 부여하면 트랜잭션이 적용되지 않는 다.

 그래서 트랜잭션 코드가 변경될 수 있다는 점을 고려한다면 @Transactional 은 안전하게 클래스에만 붙여두는 게 좋다고 볼 수도 있다. 물론 이때도 인터페이스를 정의 하고 클라이언트는 인터페이스를 통해서만 접근하도록 만들어야 한다는 원칙은 지켜 야한다.





## 2.6.3 트랜잭션속성

모든 트랜잭션이 같은 방식으로 동작히는 건 아니다. 
전체가 같이 실패하거나 성공히는 하나의 작업으로 묶인다면 점에서는 다를 바 없겠지만， 세밀히 따져보면 몇 가지 차이점이 있다. 
스프링은 트랜잭션의 경계를 설정할 때 네 가지 트랜잭션 속성을 지정할 수있다. 또, 선언적 트랜잭션에서는 롤백과 커밋의 기준을 변경하기 위해 두 가지 추가 속성을 지정할 수 있다. 선언적 트랜잭션 기준으로 보자면 모든 트랜잭션 경계는 여섯 가지 속성을갖고 있는셈이다.
트랜잭션 속성의 지정은 tx/aop 스키마의 태그를 이용히눈 경우에는 리스트 2-60과 같이 <tx:method> 태그의 애트리뷰트로 지정할수 있다. &lt;tx: method&gt; 의 애트리뷰트는 메소드 이름 패턴을 담은 name 애트리뷰트를 제외하면 모두 디폴트 값이 정의되어 있으 므로생략가능하다.



리스트 2-30 &lt;tx:method〉를 이용한 트랜잭션 속성 지정

~~~xml
<tx:attributes>
<tx:method name="">
&lt;read-only=""&gt;&lt;/read-only&gt;
&lt;isolation="" &gt;&lt;/read-only&gt;
&lt;propagation= ""&gt;&lt;/propagation&gt; 
&lt;timeout= ""&gt;
&lt;rollback-for=""&gt;&lt;/rollback-for&gt;
&lt;no-rollback-for=""/&gt;
                  
&lt;/tx:attributes&gt;
~~~

@Transactional을 이용했을 때는 리스트 2-61 과 같이 애노테이션의 엘리먼트로 트랜잭션 속성을 지정할 수 있다.

리스트 2--61 @Transactional율 이용한 트랜잭션 속성 지정

~~~java
@Transactional(readOnly=.
isolation= .. . ,
propagat lOn= .
tlmeout= ... ,
rollbackFor= . .. , rollbackForClassName= . .. ,
noRollbackFor= ... , noRollbackForClassName= ... )
~~~

모든 엘리먼트는 디폴트 값이 정의되어 있으므로 생략 기능하다. 이제 트랜잭션 속성에 대해 자세히 알아보자.





### 트랜잭션 전파: propagation

이제 트랜잭션을 시작하거나 기존 트랜잭션에 참여히는 방법을 결정하는 속성이다. 선언적 트랜잭션 경계설정 방식의 장점은 여러 트랜잭션 적용 범위를 묶어서 커다란 트랜잭션 경계를 만들 수 있다는 점이다. 
트랜잭션 경계의 시작 지점에서 트랜잭션 전파 속성을 참조해서 해당 범위의 트랜잭션을 어떤 식으로 진행시킬지 결정할 수 있다.
스프링이 지원히는 트랜잭션 전파 속성은 다음 여섯 가지가 있다. 모든 속성이 모든 종류의 트랜잭션 매니저와 데이터 액세스 기술에서 다 지원되진 않음을 주의해야 한다.
각 트랜잭션 매니저의 API 문서에는 사용 가능한 트랜잭션 전파 속성이 설명되어 있으니 사용하기 전에 쪽 참고해봐야 한다.
<tx:method> 에서는 propagation 애트리뷰트 값으로 @Transactional 에서는 propagationn 엘리먼트로 지정한다. propagation 엘리먼트의 이늄 값은 org.springframework.transaction.annotation.Propgation 에 정의된 것을 시용한다.

- REQUIRED

  디폴트 속성이다. 모든 트랜잭션 매니저가 지원하며 대개 이 속성이면 충분하다.
  미리 시작된 트랜잭션이 있으면 참여하고 없으면 새로 시작한다. 자연스럽고 간단한 트랜잭션 전파 방식이지만 사용해보면 매우 강력하고 유용하다는 사실을 알 수 있다. 하나의 트랜잭션이 시작된 후에 다른 트랜잭션 경계가 설정된 메소드를 호출하면 자연스럽게 같은 트랜잭션으로 묶인다.

  

- SUPPORTS

  이미 시작된 트랜잭션이 있으면 참여하고 그렇지 않으면 트랜잭션 없이 진행하게 만든다. 트랜잭션이 없긴 하지만 해당 경계 안에서 Connection 이나 하이버네이트 Session 등을공유할수 있다.

  

- MANDATORY

  REQUIRED와 비슷하게 이미 시작된 트랜잭션이 있으면 참여한다. 반면에 트랜잭션이 시작된 것이 없으면 새로 시작하는 대신 예외를 발생시킨다. 혼자서는 독립적으로 트랜잭션을 진행하면 안 되는 경우에 사용한다.

  

- REQUIRES NEW

  항상 새로운 트랜잭션을 시작한다. 이미 진행 중인 트랜잭션이 있으면 트랜잭션을 잠시 보류시킨다. JTA 트랜잭션 매니저를 사용한다면 서버의 트랜잭션 매니저에 트랜잭션 보류가 가능하도록 설정되어 있어야한다

  

- NOT SUPPORTED

  트랜잭션을 사용하지 않게 한다. 이미 진행 중인 트랜잭션이 있으면 보류시킨다.

  

- NEVER

  트랜잭션을 사용하지 않도록 강제한다. 이미 진행 중인 트랜잭션도 존재하면 안 된다. 있다면 예외를 발생시킨다.



- NESTED

  이미 진행 중인 트랜잭션이 있으면 중첩 트랜잭션을 시작한다. 중첩 트랜잭션은 트랜잭션 안에 다시 트랜잭션을 만드는 것이다. 
  
  하지만 독립적인 트랜잭션을 만드는 REQUIRES_NEW와는 다르다.
  **중첩된 트랜잭션은 먼저 시작된 부모 트랜잭션의 커밋과 롤백에는 영향을 받지만 자신의 커밋과 롤백은 부모트랜잭션에게 영향을주지 않는다.** 
  예를들어 어떤중요한 작업을 진행히는 중에 작업 로그를 DB 에 저장해야 한다고 해보자. 그런데 로그를 저장하는 작업이 실패하더라도 메인 작업의 트랜잭션까지 롤백해서는 안 되는 경우가 있다. 힘들게 처리한 시급한 작업을 단지 로그를 남기는 작업에 문제가 있다고 모두 실패로 만들 수는 없기 때문이다. 
  반면에 로그를 남긴 후에 핵심 작업에서 예외가 발생한다면 이때는 저장한 로그도 제거해야 한다. 
  바로 이럴 때 로그 작업을 메인 트랜잭션에서 분리해서 중첩 트랜잭션으로 만들어두면 된다. 
  **메인 트랜잭션이 롤백되면 중첩된 로그 트랜잭션도 같이 롤백되지만， 반대로 중첩된 로그 트랜잭션이 롤백 돼도 메인 작업에 이상이 없다면 메인 트랜잭션은 정상적으로 커빗된다.**
  중첩 트랜잭션은 JDBC 3.0 스펙의 저장포인트savepoint를 지원핸 드라이버와 DataSourceTransactionManager를 이용할 경우에 적용 가능하다. 
  **또는 중첩 트랜잭션을 지원하는 일부 WAS 의 JTA 트랜잭션 매니 저를 이용할 때도 적용할 수 있다. 유용한 트랜잭션 전파 방식이지만 모든 트랜잭션 매니저에 다 적용 가능한 건 아니므로，적용하려면 사용할 트랜잭션 매니저와 드라이버. WAS 의 문서를 참조해보고 미리 학습 테스트를 만들어서 검증해봐야한다.**





### 트랜잭션 격리수준: isolation

트랜잭션 격리수준은 동시에 여러 트랜잭션이 진행될 때에 트랜잭션의 작업 결과를 여타 트랜잭션에게 어떻게 노출할 것인지를 결정히는 기준이다. 
스프링은 다음 다섯 가지 격리수준속성을지원한다. 격리수준은 (tx:method) 의 isolation 애트리뷰트와 @Transactional 의 isolation
엘리먼트로지정할수있다 .

- DEFAULT

  사용하는데이터 액세스기술또는 DB 드라이버의 디폴트설정을따른다. 보통 드라이버의 격리수준은 DB 의 격리수준을 따르는 게 일반적이다. 
  대부분의 DB는 READ_COMMITTED를 기본 격리수준으로 갖는다. 하지만 일부 DB는 디폴트 값이 다른 경우도 있으므로 DEFAULT를 사용할 경우에는 드라이버와 DB 의 문서를 참고해서 디폴트 격리수준을확인해야한다 .

  

- READ UNCOMMITTED

  가장 낮은 격리수준이다. 하나의 트랜잭션이 커밋되기 전에 그 변화가 다른 트랜잭션에 그대로 노출되는 문제가 있다. 하지만 가장 빠르기 때문에 데이터의 일관성이 조금 떨어지더라도 성능을 극대화할 때 의도적으로 사용하기도 한다.

  

- READ COMMITTED

  실제로 가장 많이 사용되는 격리수준이다. 물론 스프링에서는 DEFAULT로 설정해둬도 DB 의 기본 격리수준을 따라서 READ_COMMITTED로 동작히는 경우가 대부분이므로 명시적으로 설정하지 않기도 한다. **READ_UNCOMMITTED와 달리 다른 트랜잭션이 커밋하지 않은 정보는 읽을 수 없다.** **대신 하나의 트랜잭션이 읽은 로우를 다른 트랜잭션이 수정할 수 있다.** **이 때문에 처음 트랜잭션이 같은 로우를 다시 읽을 경우 다른 내용이 발견될수있다 .**

  

- REPEA TABLE READ

  **하나의 트랜잭션이 읽은 로우를 다른 트랜잭션이 수정하는 것을 막아준다.** **하지만 새로운 로우를 추가하는 것은 제한하지 않는다.** 따라서 SELECT로 조건에 맞는 로우를 전부 가져오는 경우 트랜잭션이 끝나기 전에 추가된 로우가 발견될 수 있다.

  

- SERIALlZABLE

  가장 강력한 트랜잭션 격리수준이다. **이름 그대로 트랜잭션을 순차적으로 진행시켜 주기 때문에 여러 트랜잭션이 동시에 같은 테이블의 정보를 액세스하지 못한다.** 가장 안전한 격리수준이지만 가장 성능이 떨어지기 때문에 극단적으로 안전한 작업이 펼요한 경우가 아니라면 자주 사용되지 않는다.



### 트랜잭션 제한시간: timeout

이 속성을 이용하면 트랜잭션에 제한시간을 지정할 수 있다. 값은 초 단위로 지정한다.
디폴트는 트랜잭션 시스템의 제한시간을 따르는 것이다. 트랜잭션 제한시간을 직접 지정하는 경우 이 기능을 지원하지 못하는 일부 트랜잭션 매니저는 예외를 발생시킬 수있다.
XML에서는 &lt;tx:method) 의 timeout 애트리뷰트를 이용하고 @Transactional 애노 테이션에서는 timeout 엘리먼트로 지정할 수 있다.



### 읽기전용 트랜잭션: read-only. readOnly

트랜잭션을 읽기전용으로 설정할 수 있다. 성능을 최적화하기 위해 사용할 수도 있고 특정 트랜잭션 작업 안에서 쓰기 작업이 일어나는 것을 의도적으로 방지하기 위해 사용할 수도 있다. 트랜잭션을 준비하면서 읽기전용 속성이 트랜잭션 매니저에게 전달된다.
그에 따라 트랜잭션 매니저가 적절한 작업을 수행한다. 그런데 일부 트랜잭션 매니저의 경우 읽기전용 속성을 무시하고 쓰기 작업을 허용할 수도 있기 때문에 주의해야 한다.

일반적으로는 읽기전용 트랜잭션이 시작된 이후 INSERT, UPDATE , DELETE 같은 쓰기 작업이 진행되면 예외가 발생한다.
aop/tx 스키마로 트랜잭션 선언을 할 때는 이름 패턴을 이용해 읽기전용 속성으로 만드는 경우가 많다. 보통 get 이나 find 같은 이름의 메소드를 모두 읽기전용으로 만들어 시용하면 편리하다. @Transactional 의 경우는 각 메소드에 일일이 읽기전용 지정을 해줘야한다.
read-only 애트리뷰트 또는 readOnly 엘리먼트로 지정한다.



### 트랜잭션 롤백 예외: rollback-for, rollbackFor, rollbackForClassName

**선언적 트랜잭션에서는 런타임 예외가 발생하면 롤백한다.** 
**반면에 예외가 전혀 발생하지 않거나 체크 예외가 발생하면 커밋한다.**
체크 예외를 커밋 대상으로 삼은 이유는 체크 예외가 예외적인 상황에서 사용되기보다는 리턴 값을 대신해서 비즈니스적인 의미를 담은 결과를 돌려주는 용도로 많이 사용되기 때문이다. 
스프링에서는 데이터 액세스 기술의 예외는 런타임 예외로 전환돼서 던져지므로 런타임 예외만 롤백 대상으로 삼은 것이다.
하지만 원한다면 기본 동작방식을 바꿀 수 있다. 
**체크 예외지만 롤백 대상으로 삼아야 히는 것이 있다면 XML의 rollback-for 애트리뷰트나 애노태이션의 rollbackFor 또는 rollbackForClassName 엘리먼트를 이용해서 예외를 지정하면 된다.**

rollback-for 나 rollbackForClassName은 예외 이름을 넣으면 되고, rollbackFor는 예외 클래스를 직접 넣는다.
<tx:method> 라연 다음과 같이 지정하면 된다.
&lt;tx:method name="get*“ read-only="true" rollback-for="NoSuchllemberException"/&gt;
@Transactional 에서는 다음과 같이 클래스 이름 대신 클래스를 직접 사용해도 된다.
@Transactional(readOnly=true , rollbackFor쾌oSuchllemberException.class)



### 트랜잭션 커밋 예외: no-rollback-for, noRollbackFor, noRollbackForClassName

rollback-for 속성과는 반대로 기본적으로는 롤백 대상인 런타임 예외를 트랜잭션 커밋 대상으로 지정해준다.
사용 방법은 rollback-for와 동일하다.







**이 여섯 가지 트랜잭션 속성은 모든 트랜잭션 경계설정 속성에 사용할 수 있다. 하지만 모든 트랜잭션마다 일일이 트랜잭션 속성을 지정하는 건 매우 번거롭고 불편한 일이다.** 
세밀하게 튜닝해야 하는 시스템이 아니라면 메소드 이름 패턴을 이용해서 트랜잭션 속성을 한 번에 지정하는 aop/tx 스키마 태그 방식이 편리하다. 보통은 read-only 속성 정도만 사용하고 나머지는 디폴트로 지정하는 경우가 많다. 세밀한 속성은 DB나 WAS 의 트랜잭션 매니저의 설정을 이용해도 되기 때문이다.
**세밀한 트랜잭션 속성 지정이 필요한 경우에는 @Transactional 을 사용히는 편이 좋다. 대신 트랜잭션 속성이 전체적으로 어떻게 지정되어 있는지 한눈에 보기 힘들다는 단점이 있고， 개발자가 코드를 만들 때 트랜잭션 속성을 실수로 잘못 지정히는 등의 위험이 있기 때문에 사전에 트랜잭션 속성 지정에 관한 정책이나 가이드라인을 잘 만들어 둬야한다.**













## 2.6.4 데이터 액세스 기술 트랜잭션의 통합

스프링은 자바의 다양한 데이터 액세스 기술을 위한 트랜잭션 매니저를 제공해준다. 트랜잭션 매니저를 빈으로 등록하고 선언적인 방식의 트랜잭션 관리 기능에서 사용하게 한다. 
트랜잭션 매니저 빈의 이름은 관례적으로 transactionManager를 사용한다. 트랜잭션 매니저 를 참조하는 전용 태그에서는 참조 애트리뷰트에  이름이 디폴트로 선언 되어 있기 때문에 생략할수도 있다. 
여러 개의 DB를 독립적으로사용하지 않는한 트랜잭션 매니저는 한 개만 사용할수 있다.
**그런데 DB는 하나이지만 두 가지 이상의 데이터 액세스 기술을 동시에 사용하는 경우는 어떨까?** 
예를 들면 각각 JDBC와 iBatis로 만든 DAO를 동시에 사용한다거나, jPA와 JDBC 또는 하이버네이트와 iBatis를 함께 사용하는 경우는 어떨까? 
여기서 함께 시용한다는 건， 두 개 이상의 기술을 사용해서 만든 DAO를 하나의 트랜잭션 안에서 사용한다는 뜻이다. 
예를 들면 jPA DAO로 일부 엔티티-테이블을 업데이트히는 것과 JDBC DAO로는 복잡한 DB 전용 쿼리를 사용해 데이터를 가져오는 것을 하나의 트랜 잭션 안에서 진행시키고 싶을 수 있다.

**물론 가능하면 애플리케이션의 데이터 액세스 기술과 방식은 한 가지로 통일하는 게좋다. 하지만 때로는 두 가지 이상의 데이터 액세스 기술을 혼합해서 사용해야 할 경우도 없지 않다.** 
현재 사용히는 데이터 액세스 기술과는 다른 기술을 시용하는 다른 시스 탱에서 개발된 DAO를 가져와 시용하고 싶을 수도 있고 jPA 나 하이버네이트를 기본 적으로 사용하지만 DB 전용 네이티브 SQL을 시용하고 싶은 경우도 있다. 

물론 jPA나 하이버네이트에서도 일반 SQL을 사용해 쿼리를 작성할 수 있다. 하지만 SQL을 본격 적으로 사용하려고 하면 iBatis 나 스프링 JDBC를 사용하는 것이 편리하다.
스프링은 두 개 이상의 데이터 액세스 기술로 만든 DAO를 하나의 트랜잭션으로 묶어서 사용하는 방법을 제공한다. 물론 이때도 DB 당 트랜잭션 매니 저는 하나만 사용한 다는 원칙은 바뀌지 않는다. 대신 하나의 트랜잭션 매니저가 여러 개의 데이터 액세스 기술의 트랜잭션 기능을 지원해주도록 만드는 것이다.









### 트랜잭션 매니저별 조합 가능 기술

트랜잭션 통합이 가능한 데이터 액세스 기술의 조합을 살펴보자. 
트랜잭션 매니저는 하나만 사용되므로 각 트랜잭션 매니저별로 사용 가능한 기술을 알고 있으면 적절한 기술과 트랜잭션 매니저의 선택이 가능할 것이다.

- DataSourceTransactionManager

  DataSourceTransactionManager를 트랜잭션 매니저로 등록하면 JDBC와 iBatis 두가지 기술을 함께 사용할 수 있다. 
  트랜잭션을 통합하려면 항상 동일한 DataSource를 사용해야 한다는 점을 잊지 말자.
  그림 2-4는 두 가지 기술이 적용된 빈과 DataSource 트랜잭션 매니저의 의존관계다. JDBC DAO와 iBatis DAO 가 같은 DataSource를 사용하도록 만들어주기만 하면 된다. **DataSourceTransactionManager는 DataSource로부터 Connection 정보를 가져와 같은 DataSource를 사용하는 JDBC DAO와 iBatis DAO 작업에 트랜잭션 동기화 기능을 제공한다.**

![3](C:\Users\ST\Downloads\3.PNG)







- JpaTransactionManager

  JPA 의 트랜잭션은 JPA API를 이용해 처리된다. 따라서 기본적으로는 JPA 단독으로 트랜잭션을 관리하게 된다. 그런데 스프링에서는 JPA 의 EntityManagerFactory가 스프링의 빈으로 등록된 DataSource를 사용할 수 있다. 
  그리고 이 DataSource를 JDBC DAO 나 iBatis DAO 에서도 시용할 수 있다. 
  **이렇게 같은 DataSource를 공유하게 해 주변 JPA 의 트랜잭션을 담당하는 JpaTransactionManager 에 의해 세 가지 기술을 이용하는 DAO 작업을 하나의 트랜잭션으로 관리해줄 수 있다.**
  JpaTransactionManager를 통해 JPA 가 사용하는 트랜잭션을 같은 DataSource를 의존하고 있는 JDBC DAO와 iBatis DAO 에 동기화해주는 것이다.
  그림 2-5 는 JpaTransactionManager를 사용할 때 세 가지 기술의 DAO 가 하나의 트랜잭션으로 통기화되는 구조를 나타낸다. **JpaTransactionManager 는 직접 DataSource 를 의존하고 있지는 않지만 EntityManagerFactory 가 사용하는 DataSource를 이용해 트랜잭션 동기화를 해준다. 이 덕분에 같은 DataSource를 사용하는 JDBC , iBatis DAO와도 트랜잭션을 통합할 수 있는 것이다.**

![4](C:\Users\ST\Downloads\4.PNG)

- HibernateTransactionManager

  하이버네이트 DAO를 사용한다면 HibernateTransactionManager를 트랜잭션 매니저로 등록해야 한다. HibernateTransactionManager도 JpaTransactionManager
  와 통일한 방식을 이용해서 SessionFactory와 같은 DataSource를 공유하는 JDBC , iBatis DAO와 트랜잭션을 공유하게 해준다. 따라서 하이버네이트 JDBC, iBatis 세 가지 기술의 DAO를 통합해서 사용할 수 있다.
  그림 2-5 에서 EntityManagerFactory 대신 SessionFactory 를，
  JpaTranasctionManager 대신 HibernateTransactionManager를 대입하면 그 구조와 의존관계를 파악할 수 있을 것이다



- JtaTransactionManager

  서버가 제공히는트랜잭션 서비스를 JTA를통해 이용하면 모든종류의 데이터 액세스 기술의 DAO 가 같은 트랜잭션 안에서 동작하게 만들 수 있다. 
  JTA는 같은 DB 에대해 다른 기술을 시용할 때뿐 아니라 다른 DB를 사용하는 DAO도 하나의 트랜잭 션으로 묶어줄 수 있다. 
  가장 강력하고 펀리한 기능이지만 JTA 서버환경을 구성해야 하고 서버의 트랜잭션 매니저와 XA를 지원하는 특별한 DataSource를 구성하는 등의 부가적인 준비 작업이 필요하다.
  단지 하나의 DB 를 사용하는 여러 가지 기술의 트랜잭션을 통합하려고 한다면 JTA를 사용해야 할 이유는 없다. 반면에 하나 이상의 DB 또는 JMS와 같은 트랜잭션이 지원되는 서비스를 통합해서 하나의 트랜잭션으로 관리하려고 할 때는 JTA 가반드시필요하다.





### ORM과 비 ORM DAO를 함께 사용할 때의 주의사항

JPA나 하이버네이트 같은 엔티티 기반의 ORM 기술과 JDBC , iBatis 같은 SQL 기반의 비 ORM 기술을 함께 시용하고 하나의 트랜잭션으로 묶어서 시용하는 것은 기술적 으로 볼 때 아무런 문제가 없다. 
하지만 각 기술의 특정을 잘 이해하지 않으면 예상치 못한 오류를 만날 수 있다.
JPA와 JDBC를 사용해서 만든 리스트 2-62 와 리스트 2-63 같은 두 개의 DAO 가있다고해보자.

리스트 2-62 JPA DAO

~~~JAVA
public class MemberJpaDao (
 @PersistenceContext EntityManager entityManager;
public void add(Member m) {
    entityManager.persist(m);
}
}
~~~

리스트 2-63 JDBC DAO

~~~JAVA
public class MemberJdbcDao extends JdbcDaoSupport {
    
SimpleJdbclnsert insert;
protected void initTemplateConfig() {
    insert = new SimpleJdbclnsert(getDataSource()).withTableName( "TEST" );
public void add(Member m) {
	insert.execute(new BeanPropertySqlParameterSource(m));
}
public long count() {
    return getJdbcTemplate().queryForObject("select count(*) from member" , Long.class).longValue();}
}
~~~



각기 다른 기술을 사용하는 이 두 개의 DAO가 하나의 트랜잭션 안에서 동작하도록 설정해준다. 
그리고 리스트 2-64와 같은 코드를 트랜잭션 안에서 실행하면 어떤 결과가 나올지예측해보자.

리스트 2-34 두 개의 DAO를 사용하는 코드

~~~java
jdbcDao.add(new Member(l , "Spring" , 1.2));
jpaDao.add(new Member(2, "Jpa" , 1.2));
int count = jdbcDao .count();
~~~

먼저 JDBC DAO를 시용해서 Member 하나를 추가하고 다음은 JPA DAO를 이용해서 또 다른 Member를 추가했다. 그러고 나서 Member 태이블의 로우의 개수를 가져오는 쿼리를 이용해서 등록된 Member 의 개수를 가져왔다. Member를 두 번 추가했으니 처음에 테이블이 비어 있었다면 당연히 count 는 2 가 돼야 한다. 

**하지만 이 코드를 실행해보면 count 에 1이 들어 있음을 알게 된다.** 
같은 트랜잭션 안에서 동작하게 했고 각각 INSERT 문장을 실행히는 메소드를 호출했는데 왜 두 번 추가한 Member 의 개수가 1 이라고 나오는것일까?
그 이유는 JPA와 같은 ORM과 JDBC API를 직접 사용하는 비 ORM 의 특성이 다르기 때문이다.
JPA 나 하이버네이트는 단순히 JDBC API 를 간접적으로 실행해주는 방식이 아니다.
물론 jPA 나 하이버네이트에서 새로 만든 오브젝트에 영속성을 부여해주변 결국 INSERT 문이 생성돼서 DB로 전달되기는 할 것이다. 
하지만 영속성을 부여하는 persist() 나 save( ) 같은 메소드를 호출한다고 바로 DB 에 INSERT SQL이 전달되는 것이 아니다.
JPA 나 하이버네이트는 새로 등록된 오브젝트를 일단 엔티티 매니저나 세션에만 저장해 둔다. 

**엔티티 매니저나 세션을 1 차 캐시라고도 부르기 때문에 이렇게 저장해두는 것을 캐싱caching한다고 말하기도 한다. 캐싱을 한다는 의미는 DB 에 INSERT하는 것을 최대한 지연시킨다는 뜻이다.**

일단 persist() 로 등록했지만 트랜잭션이 끝나기 전에 다시 변경될 수도 있기 때문이다. 따라서 DB 에 동기화가 필요한 시점, 예를 들어 트랜잭션이 종료되거나 등록된 엔티티가 반영돼야만 정상적인 결과가 나올 수 있는 쿼리가 실행될 때까지는 실제 DB로 등록하는 것을 지연시키는 기법을 사용한다. 간단한 캐시이긴 하지만, 나름 성능 향상을 가져올 수 있고 코드를 유연하게 만들 수 있는 유용한 방법이다.
문제는 이 때문에 MemberJpaDao 의 add() 에서 entityManager.persist() 를 실행했다고 해도 바로 DB 에는 INSERT 문이 전달되지 않는다는 점이다. 
**단지 메모리의 캐시에 저장되어 있을 뿐이다. JPA 입장에서는 작업이 모두 끝나고 트랜잭션이 커밋되는 순간**
**INSERT 문을 만들어 DB 에 저장을 시도할 것이다.**
그런데 JDBC 에서는 lPA 의 그런 사정을 알지 못한다. 따라서 JDBC는 count() 메소드가 실행되면 그 순간 DB 에 바로 조회용 SQL을 보내서 현재 테이블에 등록된 로우의 개수를 가져온다. 따라서 lPA 의 캐시에만 있고 DB 에는 반영되지 않은 두 번째 add() 의 결과는 나타나지 않는 것이다.
원래 lPA 나 하이버네이트는 JDBC 등과 함께 사용하도록 설계된 게 아니기 때문에 이런 문제가 발생한다. 따라서 ORM과 비 ORM 기술을 함께 사용할 때 상당히 주의를 기울여야 한다. DAO를 이용하는 서비스 계층의 코드는 사실 DAO 가 어떤 기술로 만들어졌는지를 알지 못한다. 따라서 별 의심 없이 위와 같은 코드를 그냥 작성해버리기 쉽다.

그렇다면 이 문제를 어떻게 풀어야 할까?
해결 방법은 한 가지뿐이다. lPA나 하이버네이트의 I 차 캐시에 저장됐지만 DB 에는 아직 반영되지 않은 엔티티가 있다면 관련 테이블을 참조하는 JDBC DAO나 iBatis DAO를 바로 이용하면 안 된다. 따라서 JDBC DAO의 쿼리를 사용하려면 JPA나 하이버네이트의 1차 캐시의 내용을 먼저 DB 에 반영해야 한다.
**가장 단순한 해결책은 lPA 의 저장이나 수정 작업을 한 후에는 강제로 캐시의 내용을 DB로 보내주는 EntityManager나 Session 의 flush() 메소드를 사용하는 것이다. 리스트 2-65 에서는 MemberJpaDao 의 메소드를 이 방식으로 동작하도록 수정했다.**



리스트 2-35 flush() 사용

~~~java
public void add(Member m) {
    entityManager.persist(m);
	entityManager.flush();
}
~~~

**flush( ) 메소드는 현재 캐시의 내용을 즉시 DB 에 반영한다.** 
따라서 JDBC DAO 의 add( ) 메소드를 실행했을 때처럼 바로 INSERT 문이 DB로 전달되어 새로운 레코드가 추가된다. 
**이렇게 해두면 이후에 JDBC DAO에서 Member 테이블에 count() 쿼리를 실행 해도 JPA 에서 진행한 작업까지 모두 반영된 결과를 가져올 수 있다.**

이렇게 add() 나 merge( ) 등에서 항상 flush( )를 사용하도록 만들면 간단히 문제를 해결할 수 있긴 하지만, 
**반면에 jPA나 하이버네이트 입장에서는 1차 캐시의 장점을 희생해야 한다.** 
**JDBC DAO를 함께 사용하지 않고 jPA만 사용히는 비즈니스 로직에서도 항상 flush( )를 쓴다는 것은 손해다.** 
또， JPA나 하이버네이트에서는 persist() 나 merge( )를 명시적으로 호출하지 않아도 DB 에서 가져온 엔티티 오브젝트는 필드를 수정하는 것만으로도 UPDATE 가 일어나는 수정이 된다는 문제가 있다. 

이런 경우에도 의도 적으로 flush() 를 수행해줘야 한다. 따라서 코드가 지저분해질 뿐만 아니라， DAO의 시용 기술을 의식해서 서비스 계층의 코드를 만들어야 한다는 문제점도 있다.
**또 다른 접근 방법은 JDBC 의 DAO 가 호출될 때 JPA 나 하이버네이트의 캐시를 flush( ) 하도록 만들어주는 것이다.** 

AOP를 이용하면 lPA/하이버네이트 캐시의 flush( )를 호출해주는 부가기능을 JDBC DAO 에 간단히 추가해줄 수 있다. 이렇게 해두면 **JDBC DAO를 시용하지 않고 JPA DAO만 이용하는 경우에는 jPA 캐시를 효과 적으로 활용할 수 있고， JDBC DAO를 함께 사용할 때도 데이터의 정확성을 보장해줄 수있다.**





## 2.6.5 JTA를 이용한 글로벌/분산 트랜잭션

한 개 이상의 DB 나 JMS 의 작업을 하나의 트랜잭션 안에서 동작하게 하려면 서버가 제공히는 트랜잭션 매니저를 JTA를 통해 사용해야 한다. 
스프링에서는 서버에 설정해둔 XA DataSource와 트랜잭션 매니저 그리고 UserTransaction 등을 JNDI를 통해 가져와 모든 데이터 액세스 기술에서 사용할 수 있다. 
JTA와 분산/글로벌 트랜잭션을 사용하기 위한 설정은 자바서버마다 다르므로 해당 서버의 매뉴얼을 참고해서 등록하는 방법을 알아둬야한다.

리스트 2-66 JTA를 적용한 설정

~~~xml
&lt;jee: jndi -lookup id="dataSource1" jndi-name="jdbc/xaDS1" /&gt;
<bean id="memberDao" class=" ... MemberDao"> 
	<property name="dataSource" ref="dataSource1" />
</bean>

<jee:jndi-lookup id="dataSource2" jndi-name="jdbc/xaDS2" /> 
	<bean id="usageDao" 뎌="" c="" lass=" ....UsageDao.. ">
		<property name="dataSource" ref="dataSource2" /> 
	</bean>


<bean id="txManager" class="org. springframework.transaction.jta.JtaTransactionManager" />
~~~



이 설정에는 두 개의 DataSource 타입 빈이 등장한다. **이 두 개의 DataSource 빈은 스프링 안에서 만들어지는 게 아니라 서버에서 제공해주는 DataSource를 JNDI로 가져온 것이다**. 
**서버에는 분산 트랜잭션을 위한 XA 프로토콜을 지원하는 XA DataSource 두 개가 jdbc/xaDSl 과 jdbc/xaDS2 라는 JNDI 이름으로 둥록되어 있어야 한다.** 

이 두개의 DataSource를 사용하는 DAO도 각각 등록해준다. DAO 의 데이터 액세스 기술은 어떤것이든상관없다.
마지막으로 JtaTransactionManager를 빈으로 등록한다. 
JtaTransactionManager는 여타 트랜잭션 매니저와는 다르게 프로퍼티로 DataSource 나 SessionFactory 등의 빈을 참조하지 않는다. 

대신 서버에 등록된 트랜잭션 매니저를 가져와 JTA를 이용해서 트랜잭션을 관리해줄 뿐이다. 이미 서버의 JTA 서비스에는 JNDI로 가져온 두 개의 XA DataSource 가 등록되어 있을 것이다. JTA는 서버에서 미리 설정해두기만 하면 스프링 에서 사용하는 것은 어떤 트랜잭션 매니저보다 간단하다.

**JtaTransactionManager는 JNDI 를 통해 JTA TransactionManager 와 JTAUserTransaction을 찾아온다.** 
이때 사용하는 JNDI 이름은 WAS 에서 자주 사용되는 기본적인 이름을 이용한다.
UserTransaction은 "java:comp/UserTransaction" 을 사용하고， 
TransactionManager는 "java:comp/TransactionManager" , "java:appserver/TransactionManager" ’"java:pm/TransactionManager" ’ "java: /TransactionManager" 네 가지 이름을 시도해서 가장 먼저 발견되는 것을 사용한다.
기본 이름이 아닌 JNDI 이름으로 UserTransaction 이나 TransactionManager 가 등록되어 있다면 JtaTransactionManager 의 transactionManagerName 과 userTransactionName 프로퍼티를 이용해서 JNDI 이름을 지정해줘야 한다.





### 독립형 JTA 트랜잭션 매니저

JTA는 WAS 가 제공하는 서비스를 이용하는 경우가 일반적이지만, 원한다면 서버의 지원 없이도 애플리케이션 안에 JTA 서비스 기능을 내장허는 독립형 JTA 방식으로 이용할 수 있다. 

**이 방식을 사용하면 JTA를 지원히는 WAS 가 아닌 톰켓과 같은 서블릿 컨테이너에서도 JTA 기능을 이용하는 것이 가능하다**. 

**서버에 포함돼서 서비스로 동작하는 것은아니지만 JTA의 다중트랜잭션 리소스를 위한글로벌 트랜잭션 기능을활용할수 있다.** 

- 스프링 안에서 간단한 설정을 추가하는 것만으로 JTA 의 기능을 시용할 수 있다는 점에서 매력적이다.
  독립형 JTA 트랜잭션 매니저는 ObjectWeb의 JTA 엔진인 JOTM 과 Atomikos의 TransactionalEssentials가 대표적이다. 
  두가지 모두 오픈소스 제품이므로 자유롭게 가져다 쓸 수 있다. Atomikos 에서는 오픈소스 외에도 고급 기능을 가진 상용 제품인 ExtremeTransactions를 판매하기도 한다.

  

이 두 가지 모두 스프링의 JtaTransactionManager와 결합해서 JTA 트랜잭션 서비스로 사용할수있다.
Atomikos 의 TransactionalEssentials를 스프링에 적용한 예를 살펴보자.
**먼저 리스트 2-67 과 같이 Atomikos 의 JTA TransactionManager 와 JTA UserTransaction을 빈으로 등록한다.** 
**이 두 가지 JTA 서비스는 서버에서 제공해주지 않기 때문에 스프링의 빈으로 등록해서 서비스를 이용해야 한다.** 

스프링의 트랜잭션 매니저와 여기서 사용한 JTA 트랜잭션 매니저는 다른 것이므로 혼동해서는 안 된다. 
스프링의 JtaTransactionManager는 JTA 트랜잭션 매니저를 스프링 애플리케이션이 이용 하게 해주는 트랜잭션 추상화를 위한 클래스일 뿐이다.



리스트 2-ff1 JTA 트랜잭션 매니저와 사용자 트랜잭션 등록

~~~xml
<bean id="atomikosTransactionManager" class="com.atomikos.icatch . jta.UserTransactionManager" lmtMethod="init" destroy-method="close">
<property name="forceShutdown"><value>true</value></property>
</bean>

<bean id="atomikosUserTransaction" class="com.atomikos.icatch.jta.UserTransactionlmp">
<property name="transactionTimeout"><value>300</value></property> 
</bean>
~~~



다음은 리스트 2 -68과 같이 스프링 JtaTransactionManager를 등록하고 서벼의 트랜잭션 서비스 대신 앞에서 빈으로 빈으로 등록해둔 Atomikos JTA 서비스를 이용하도 록프로퍼티를설정해줘야한다.

리스트 2-58JTATransactionManager 등록

~~~xml
&lt;bean id=“transactionManager" class="org. springframework. transaction. j ta. JtaTransactionManager"&gt; <property name="transactionManager" ref="atomikosTransactionManager" /> <property name="userTransaction" ref="atomikosUserTransaction" /> &lt;/bean&gt;
~~~







다음은 XA를 지원하는 DataSource를 빈으로 등록할 차례다. 
글로벌/분산 트랜잭션을 사용히는 만큼 여러 개의 DB를 사용하도록 하나 이상의 DataSource를 등록한다.
**DataSource는 JTA 트랜잭션 매니저와 XA 프로토콜을 통해 트랜잭션이 동작하도록 만들어야 한다.** 
따라서 일반 DataSource 대신 XA를 지원하는 XA DataSource를 사용해야 한다. 
**Atomikos는 XA 지원 드라이버 를 사용할 수도 있고. XA를 지원하지 않는 드라이버를 Atomikos 의 도웅을 통해 XA 드라이버처럼 사용하게 만들 수도 있다.** 
여기서는 MySQL 이 제공히는 XA DataSource 인 MysqlXADataSource를 사용해보겠다.
먼저 리스트 2-69와 같이 첫 번째 DB를 위한 DataSource를 등록해보자. JTA 에서 사용할 DataSource 에는 고유한 리소스 이름을 지정해줘야 한다.



리스트 2• 39 XA DataSource 등록

~~~xml
&lt;bean id="dataSource1" class=“ com.atomikos.jdbc .AtomikosDataSourceBean"
init-method="init" destroy캐lethod="close"&gt; 
<property name="uniqueResourceName" value="MySQLXA1" />
&lt;property name="xaDataSourceClassName" value="com .mysql. j dbc. j dbc2 .optional.MysqlXADataSource“ /&gt; 
<property name="xaProperties"> 
<props> 
	<prop key="user">jtauser</prop> 
    <prop key="password">jtapassword</prop> 
     <prop key="url">jdbc :mysql :/localhost/tx1</prop> 
</props>
</property> 
<property name="poolSize" value="l" /> &lt;/bean&gt;
~~~

같은 방법으로 리스트 2-70과 같이 두 번째와 세 번째 DataSource를 등록한다.



리스트 2-70 나머지 XA DataSource 등록

~~~xml
<bean id="dataSource2" class="com.atomikos.jdbc.AtomikosDataSourceBean"> 
    <property name="uniqueResourceName" value="MySQLXA2" />
</bean>
<bean id="dataSource3" class="com.atomikos.jdbc.AtomikosDataSourceBean"> 
  <property name="uniqueResourceName" value="MySQLXA3" />
</bean>
~~~



이제 각각의 데이터 소스를 사용하는 JDBC DAO나 iBatis SqlMapClient 또는
JPA EntityManagerFactory. 하이버네이트 SessionFactory를 등록하고 DAO를 만든다. 이때 각 데이터 액세스 기술에서 사용되는 DataSourceTransactionManager 나
JpaTransactionManager 같은 트랜잭션 매니저는 등록할 멸요가 없다.
이제 모든 준비가 묻났다. 세 가지 DB를 사용하는， 다른 기술로 만들어진 DAO들이 JTA를 통해 하나의 트랜잭션 안에서 동작함을 확인할 수 있을 것이다. 이렇게 3 개의 DB를 시용하는 JTA 설정과 학습 태스트는 예제 코드의 tx/JtaTxTest ，j ava와 tx/
jtatxtest-context ， xml에 나와 있으니 참고하기 바란다.







### WAS 트랜잭션 매니저의 고급 기능 사용하기

스프링의 JtaTransactionManager는 JTA 의 표준 스펙을 따르는 API를 사용해 트랜잭션을 관리한다. 그런데 WebLogic 이나 OC4J. WebSphere 등의 고급 WAS 에서는 표준 JTA는 지원하지 않는. WAS 가 제공하는 고급 트랜잭션 기능을 활용할 수 있다.
WAS 별 전용 트랜잭션 매니저를 살펴보자.	

- WebSphereUowTransactionManager

  WebSphereUowTransactionManager를 JtaTransactionManager 대신 사용하면 IBM
  WebSphere 의 UOWManager를 통해서 WebSphere 가 제공히는 트랜잭션 서비스의 기능을 최대한 활용할 수 있다. 
  **IBM WebSphere 팀의 공식적인 기술지원을 통해서 개발된 만큼 안정성을 보장받을 수 있다.** 
  **JTA 에서 기본적으로 보장되지 않는 트랜잭션 일시중단 기능이 제공되며 ， 이를 통해 REQUIRES_NEW 같은 트랜잭션 전파속성을 사용할수있다 .**

- WebLogicJtaTransactionManager

  WebLogic 서버의 트랜잭션 서비스를 최대한 활용할 수 있게 해준다. 트랜잭션 이름， 트랜잭션별 격리수준설정， 트랜잭션의 일시중지와 재시작등을모두활용할수 있다. 

  **또 WebLogic 서버의 트랜잭션 모니터를 통해 스프링에서 진행되는 트랜잭션을 관찰할 수 있게 해준다.**

- OC4JJtaTransactionManager

  OC4J 서버의 트랜잭션 기능에 최적화된 트랜잭션 매니저다. 트랜잭션별 격리수준 설정을 지원하며 **OC4J 의 트랜잭션 모니터에서 스프링의 트랜잭션을 볼 수 있게 해준다.** 오라클팀이 만들어서 스프링에 제공한 코드를 바탕으로 만틀어졌다.

위 세 가지 서버를 사용히는 경우라면 JtaTransactionManager 대신 해당 서버 전용 트랜잭션 매니저를 사용하는 편이 좋다. 

**서버에 따라 트랜잭션 매니저의 종류를 변경하 기가 귀찮다면 . JtaTransactionManager 빈을 등록하는 대신 스프링이 제공하는 서버 자동인식 기능을 가진 전용 태그를 시용할 수 있다.**
 <tx:jta-transaction-manager />

tx 스키마의 jta-transactlon-manager 태그를 이용해 JTA 트랜잭션 매니저를 등록 할수있다. 
**이 방식의장점은서버를자동인식해서 적절한 JTA 트랜잭션을등록해준다는 점이다**. 
이 설정을 가진 애플리케이션을 WebSphere 에 가져가면 WebSphere용 JTA 트랜잭션 매니저가 등록되고.OC4J 에 배치하면 OC4J용 트랜잭션 매니저가 자동등록 된다. 
세 개의 서버 외에 배치됐을 때는 기본인 JtaTransactionManager 가 사용된다.































</tx:method></tx:method></tx:method></tx:attributes></tx:method></tx:annotation-driven></aop:config></tx:attributes></Member></aop:pointcut></aop:config></aop:config></aop:config>

                </div>
            </section>

            <!-- Email subscribe form at the bottom of the page -->
<!--            
                <section class="subscribe-form">
                    <h3 class="subscribe-form-title">Subscribe to 웹개발자</h3>
                    <p>Get the latest posts delivered right to your inbox</p>
                    <span id="searchform" method="post" action="/subscribe/" class="">
    <input class="confirm" type="hidden" name="confirm"  />
    <input class="location" type="hidden" name="location"  />
    <input class="referrer" type="hidden" name="referrer"  />

    <div class="form-group">
        <input class="subscribe-email" onkeyup="myFunc()"
               id="searchtext" type="text" name="searchtext"
               placeholder="Search..." />
    </div>
    <script type="text/javascript">
        function myFunc() {
            if(event.keyCode == 13) {
                var url = encodeURIComponent($("#searchtext").val());
                location.href = "/search.html?query=" + url;
            }
        }
    </script>
</span>
                </section>
            -->

            <footer class="post-full-footer">
                <!-- Everything inside the #author tags pulls data from the author -->
                <!-- #author-->
                
                    
                        <section class="author-card">
                            
                                <img class="author-profile-image" src="/assets/built/images/author-logo.jpg" alt="seongtaekkim" />
                            
                            <section class="author-card-content">
                                <h4 class="author-card-name"><a href="/author/seongtaekkim">seongtaekkim</a></h4>
                                
                                    <p>springframework, oracle</p>
                                
                            </section>
                        </section>
                        <div class="post-full-footer-right">
                            <a class="author-card-button" href="/author/seongtaekkim">Read More</a>
                        </div>
                    
                
                <!-- /author  -->
            </footer>

            <!-- If you use Disqus comments, just uncomment this block.
            The only thing you need to change is "test-apkdzgmqhj" - which
            should be replaced with your own Disqus site-id. -->
            
                <section class="post-full-comments">
                    <div id="disqus_thread"></div>
                    <script>
                        var disqus_config = function () {
                            var this_page_url = 'https://seongtaekkim.github.io/spring-toby2_2';
                            var this_page_identifier = '/spring-toby2_2';
                            var this_page_title = '토비의스프링2권 2장';
                        };
                        (function() {
                            var d = document, s = d.createElement('script');
                            s.src = 'https://xxxxxxxx.disqus.com/embed.js';
                            s.setAttribute('data-timestamp', +new Date());
                            (d.head || d.body).appendChild(s);
                        })();
                    </script>
                </section>
            

        </article>

    </div>
</main>

<!-- Links to Previous/Next posts -->
<aside class="read-next outer">
    <div class="inner">
        <div class="read-next-feed">
            
                
                
                
                
                    <article class="read-next-card"
                        
                            style="background-image: url(/assets/built/images/cover1.jpg)"
                        
                    >
                        <header class="read-next-card-header">
                            <small class="read-next-card-header-sitetitle">&mdash; 웹개발자 &mdash;</small>
                            
                                <h3 class="read-next-card-header-title"><a href="/tag/spring/">Spring</a></h3>
                            
                        </header>
                        <div class="read-next-divider"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 14.5s2 3 5 3 5.5-2.463 5.5-5.5S21 6.5 18 6.5c-5 0-7 11-12 11C2.962 17.5.5 15.037.5 12S3 6.5 6 6.5s4.5 3.5 4.5 3.5"/></svg>
</div>
                        <div class="read-next-card-content">
                            <ul>
                                
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                
                                  
                                    
                                        
                                        
                                            <li><a href="/springframework-bean(1)">스프링 bean생성원리 분석(1)</a></li>
                                        
                                    
                                  
                                
                                  
                                
                                  
                                    
                                        
                                        
                                            <li><a href="/springframework-architecture">스프링 따라하기</a></li>
                                        
                                    
                                  
                                
                                  
                                    
                                        
                                        
                                            <li><a href="/springframework-remake">스프링 따라하기</a></li>
                                        
                                    
                                  
                                
                                  
                                
                                  
                                    
                                  
                                
                                  
                                    
                                        
                                        
                                    
                                  
                                
                                  
                                    
                                        
                                        
                                    
                                  
                                
                                  
                                    
                                        
                                        
                                    
                                  
                                
                            </ul>
                        </div>
                        <footer class="read-next-card-footer">
                            <a href="/tag/spring/">
                                
                                    See all 6 posts  →
                                
                            </a>
                        </footer>
                    </article>
                
            

            <!-- If there's a next post, display it using the same markup included from - partials/post-card.hbs -->
            
                

    <article class="post-card  no-image">
        
        <div class="post-card-content">
            <a class="post-card-content-link" href="/tobyspring1-1-summary">
                <header class="post-card-header">
                    

                    <h2 class="post-card-title">Tobyspring1 1 Summary</h2>
                </header>
                <section class="post-card-excerpt">
                    
                        <p>SringFramework - Bean

</p>
                    
                </section>
            </a>
            <footer class="post-card-meta">
                
                    
                
                <span class="reading-time">
                    
                    
                      1 min read
                    
                </span>
            </footer>
        </div>
    </article>

            

            <!-- If there's a previous post, display it using the same markup included from - partials/post-card.hbs -->
            
                

    <article class="post-card post-template">
        
            <a class="post-card-image-link" href="/spring-toby1_8">
                <div class="post-card-image" style="background-image: url(/assets/built/images/bus.jpg)"></div>
            </a>
        
        <div class="post-card-content">
            <a class="post-card-content-link" href="/spring-toby1_8">
                <header class="post-card-header">
                    
                        
                            
                                <span class="post-card-tags">Spring</span>
                            
                        
                    

                    <h2 class="post-card-title">토비의스프링1권 8장 내용</h2>
                </header>
                <section class="post-card-excerpt">
                    
                        <p>– 토비의스프링 1권 정리

    토비의스프링1권 8장
    토비의스프링1권 9장


</p>
                    
                </section>
            </a>
            <footer class="post-card-meta">
                
                    
                        
                        <img class="author-profile-image" src="/assets/built/images/author-logo.jpg" alt="seongtaekkim" />
                        
                        <span class="post-card-author">
                            <a href="/author/seongtaekkim/">seongtaekkim</a>
                        </span>
                    
                
                <span class="reading-time">
                    
                    
                      17 min read
                    
                </span>
            </footer>
        </div>
    </article>

            

        </div>
    </div>
</aside>

<!-- Floating header which appears on-scroll, included from includes/floating-header.hbs -->
<div class="floating-header">
    <div class="floating-header-logo">
        <a href="https://seongtaekkim.github.io/">
            
            <span>웹개발자</span>
        </a>
    </div>
    <span class="floating-header-divider">&mdash;</span>
    <div class="floating-header-title">토비의스프링2권 2장</div>
    <div class="floating-header-share">
        <div class="floating-header-share-label">Share this <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
    <path d="M7.5 15.5V4a1.5 1.5 0 1 1 3 0v4.5h2a1 1 0 0 1 1 1h2a1 1 0 0 1 1 1H18a1.5 1.5 0 0 1 1.5 1.5v3.099c0 .929-.13 1.854-.385 2.748L17.5 23.5h-9c-1.5-2-5.417-8.673-5.417-8.673a1.2 1.2 0 0 1 1.76-1.605L7.5 15.5zm6-6v2m-3-3.5v3.5m6-1v2"/>
</svg>
</div>
        <a class="floating-header-share-tw" href="https://twitter.com/share?text=%ED%86%A0%EB%B9%84%EC%9D%98%EC%8A%A4%ED%94%84%EB%A7%812%EA%B6%8C+2%EC%9E%A5&amp;url=https://seongtaekkim.github.io/spring-toby2_2"
            onclick="window.open(this.href, 'share-twitter', 'width=550,height=235');return false;">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><path d="M30.063 7.313c-.813 1.125-1.75 2.125-2.875 2.938v.75c0 1.563-.188 3.125-.688 4.625a15.088 15.088 0 0 1-2.063 4.438c-.875 1.438-2 2.688-3.25 3.813a15.015 15.015 0 0 1-4.625 2.563c-1.813.688-3.75 1-5.75 1-3.25 0-6.188-.875-8.875-2.625.438.063.875.125 1.375.125 2.688 0 5.063-.875 7.188-2.5-1.25 0-2.375-.375-3.375-1.125s-1.688-1.688-2.063-2.875c.438.063.813.125 1.125.125.5 0 1-.063 1.5-.25-1.313-.25-2.438-.938-3.313-1.938a5.673 5.673 0 0 1-1.313-3.688v-.063c.813.438 1.688.688 2.625.688a5.228 5.228 0 0 1-1.875-2c-.5-.875-.688-1.813-.688-2.75 0-1.063.25-2.063.75-2.938 1.438 1.75 3.188 3.188 5.25 4.25s4.313 1.688 6.688 1.813a5.579 5.579 0 0 1 1.5-5.438c1.125-1.125 2.5-1.688 4.125-1.688s3.063.625 4.188 1.813a11.48 11.48 0 0 0 3.688-1.375c-.438 1.375-1.313 2.438-2.563 3.188 1.125-.125 2.188-.438 3.313-.875z"/></svg>

        </a>
        <a class="floating-header-share-fb" href="https://www.facebook.com/sharer/sharer.php?u=https://seongtaekkim.github.io/spring-toby2_2"
            onclick="window.open(this.href, 'share-facebook','width=580,height=296');return false;">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><path d="M19 6h5V0h-5c-3.86 0-7 3.14-7 7v3H8v6h4v16h6V16h5l1-6h-6V7c0-.542.458-1 1-1z"/></svg>

        </a>
    </div>
    <progress class="progress" value="0">
        <div class="progress-container">
            <span class="progress-bar"></span>
        </div>
    </progress>
</div>


<!-- /post -->

<!-- The #contentFor helper here will send everything inside it up to the matching #block helper found in default.hbs -->


        <!-- Previous/next page links - displayed on every page -->
        

        <!-- The footer at the very bottom of the screen -->
        <footer class="site-footer outer">
            <div class="site-footer-content inner">
                <section class="copyright"><a href="https://seongtaekkim.github.io/">웹개발자</a> &copy; 2021</section>
                <section class="poweredby">Proudly published with <a href="https://jekyllrb.com/">Jekyll</a> &
                    <a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a> using
                    <a href="https://github.com/jekyllt/jasper2" target="_blank" rel="noopener">Jasper2</a></section>
                <nav class="site-footer-nav">
                    <a href="/">Latest Posts</a>
                    
                    
                    <a href="https://ghost.org" target="_blank" rel="noopener">Ghost</a>
                </nav>
            </div>
        </footer>

    </div>

    <!-- The big email subscribe modal content -->
    
    <div id="subscribe" class="subscribe-overlay">
        <a class="subscribe-overlay-close" href="#"></a>
        <div class="subscribe-overlay-content">
            
            <h1 class="subscribe-overlay-title">Search 웹개발자</h1>
            <p class="subscribe-overlay-description">
                lunr.js를 이용한 posts 검색 </p>
            <span id="searchform" method="post" action="/subscribe/" class="">
    <input class="confirm" type="hidden" name="confirm"  />
    <input class="location" type="hidden" name="location"  />
    <input class="referrer" type="hidden" name="referrer"  />

    <div class="form-group">
        <input class="subscribe-email" onkeyup="myFunc()"
               id="searchtext" type="text" name="searchtext"
               placeholder="Search..." />
    </div>
    <script type="text/javascript">
        function myFunc() {
            if(event.keyCode == 13) {
                var url = encodeURIComponent($("#searchtext").val());
                location.href = "/search.html?query=" + url;
            }
        }
    </script>
</span>
        </div>
    </div>
    

    <!-- highlight.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.10.0/components/prism-abap.min.js"></script>
    <script>$(document).ready(function() {
      $('pre code').each(function(i, block) {
        hljs.highlightBlock(block);
      });
    });</script>

    <!-- jQuery + Fitvids, which makes all video embeds responsive -->
    <script
        src="https://code.jquery.com/jquery-3.2.1.min.js"
        integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4="
        crossorigin="anonymous">
    </script>
    <script type="text/javascript" src="/assets/js/jquery.fitvids.js"></script>
    <script type="text/javascript" src="https://demo.ghost.io/assets/js/jquery.fitvids.js?v=724281a32e"></script>


    <!-- Paginator increased to "infinit" in _config.yml -->
    <!-- if paginator.posts  -->
    <!-- <script>
        var maxPages = parseInt('');
    </script>
    <script src="/assets/js/infinitescroll.js"></script> -->
    <!-- /endif -->

    


    <!-- Add Google Analytics  -->
    <!-- Google Analytics Tracking code -->
 <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-xxxxxxxx-x', 'auto');
  ga('send', 'pageview');

 </script>


    <!-- The #block helper will pull in data from the #contentFor other template files. In this case, there's some JavaScript which we only want to use in post.hbs, but it needs to be included down here, after jQuery has already loaded. -->
    
        <script>

// NOTE: Scroll performance is poor in Safari
// - this appears to be due to the events firing much more slowly in Safari.
//   Dropping the scroll event and using only a raf loop results in smoother
//   scrolling but continuous processing even when not scrolling
$(document).ready(function () {
    // Start fitVids
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
    // End fitVids

    var progressBar = document.querySelector('progress');
    var header = document.querySelector('.floating-header');
    var title = document.querySelector('.post-full-title');

    var lastScrollY = window.scrollY;
    var lastWindowHeight = window.innerHeight;
    var lastDocumentHeight = $(document).height();
    var ticking = false;

    function onScroll() {
        lastScrollY = window.scrollY;
        requestTick();
    }

    function onResize() {
        lastWindowHeight = window.innerHeight;
        lastDocumentHeight = $(document).height();
        requestTick();
    }

    function requestTick() {
        if (!ticking) {
            requestAnimationFrame(update);
        }
        ticking = true;
    }

    function update() {
        var trigger = title.getBoundingClientRect().top + window.scrollY;
        var triggerOffset = title.offsetHeight + 35;
        var progressMax = lastDocumentHeight - lastWindowHeight;

        // show/hide floating header
        if (lastScrollY >= trigger + triggerOffset) {
            header.classList.add('floating-active');
        } else {
            header.classList.remove('floating-active');
        }

        progressBar.setAttribute('max', progressMax);
        progressBar.setAttribute('value', lastScrollY);

        ticking = false;
    }

    window.addEventListener('scroll', onScroll, {passive: true});
    window.addEventListener('resize', onResize, false);

    update();
});
</script>

    

    <!-- Ghost outputs important scripts and data with this tag - it should always be the very last thing before the closing body tag -->
    <!-- ghost_foot -->

</body>
</html>
